/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}

/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "f010bf7693f379d5b0b6"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 1;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };

/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _express = __webpack_require__(186);

	var _express2 = _interopRequireDefault(_express);

	var _serverConfig = __webpack_require__(302);

	var _serverConfig2 = _interopRequireDefault(_serverConfig);

	var _Spots = __webpack_require__(448);

	var _Spots2 = _interopRequireDefault(_Spots);

	var _Users = __webpack_require__(544);

	var _Users2 = _interopRequireDefault(_Users);

	var _fbAuth = __webpack_require__(546);

	var _localAuth = __webpack_require__(568);

	var _localAuth2 = _interopRequireDefault(_localAuth);

	var _primaryRoutes = __webpack_require__(572);

	var _primaryRoutes2 = _interopRequireDefault(_primaryRoutes);

	var _authRoutes = __webpack_require__(573);

	var _authRoutes2 = _interopRequireDefault(_authRoutes);

	var _apiRoutes = __webpack_require__(575);

	var _apiRoutes2 = _interopRequireDefault(_apiRoutes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var app = (0, _express2.default)();
	var port = process.env.PORT || 8000;

	console.log('User', _Users2.default);
	// Server and auth configuration
	(0, _localAuth2.default)(_Users2.default);
	(0, _fbAuth.facebookAuthConfig)(_Users2.default);
	(0, _serverConfig2.default)(app, _Users2.default);

	// Render the main splash page upon arrival
	(0, _primaryRoutes2.default)(app);

	// Wire up routes for authentication
	(0, _authRoutes2.default)(app);

	// RESTFUL routes for retrieving data from the database
	(0, _apiRoutes2.default)(app);

	// start the server
	app.listen(port, function () {
	  console.log('server started on port');
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ function(module, exports) {

	'use strict';

	// shim for using process in browser

	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function cachedSetTimeout() {
	            throw new Error('setTimeout is not defined');
	        };
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function cachedClearTimeout() {
	            throw new Error('clearTimeout is not defined');
	        };
	    }
	})();
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	module.exports = __webpack_require__(187);

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(188).EventEmitter;
	var mixin = __webpack_require__(189);
	var proto = __webpack_require__(190);
	var Route = __webpack_require__(207);
	var Router = __webpack_require__(206);
	var req = __webpack_require__(281);
	var res = __webpack_require__(297);

	/**
	 * Expose `createApplication()`.
	 */

	exports = module.exports = createApplication;

	/**
	 * Create an express application.
	 *
	 * @return {Function}
	 * @api public
	 */

	function createApplication() {
	  var app = function app(req, res, next) {
	    app.handle(req, res, next);
	  };

	  mixin(app, EventEmitter.prototype, false);
	  mixin(app, proto, false);

	  app.request = { __proto__: req, app: app };
	  app.response = { __proto__: res, app: app };
	  app.init();
	  return app;
	}

	/**
	 * Expose the prototypes.
	 */

	exports.application = proto;
	exports.request = req;
	exports.response = res;

	/**
	 * Expose constructors.
	 */

	exports.Route = Route;
	exports.Router = Router;

	/**
	 * Expose middleware
	 */

	exports.query = __webpack_require__(224);
	exports.static = __webpack_require__(301);

	/**
	 * Replace removed middleware with an appropriate error message.
	 */

	['json', 'urlencoded', 'bodyParser', 'compress', 'cookieSession', 'session', 'logger', 'cookieParser', 'favicon', 'responseTime', 'errorHandler', 'timeout', 'methodOverride', 'vhost', 'csrf', 'directory', 'limit', 'multipart', 'staticCache'].forEach(function (name) {
	  Object.defineProperty(exports, name, {
	    get: function get() {
	      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
	    },
	    configurable: true
	  });
	});

/***/ },
/* 188 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function (type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events) this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler)) return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++) {
	      listeners[i].apply(this, args);
	    }
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function (type, listener) {
	  var m;

	  if (!isFunction(listener)) throw TypeError('listener must be a function');

	  if (!this._events) this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function (type, listener) {
	  if (!isFunction(listener)) throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function (type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener)) throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type]) return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener || isFunction(list.listener) && list.listener === listener) {
	    delete this._events[type];
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0) return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function (type) {
	  var key, listeners;

	  if (!this._events) return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length) {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    }
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function (type) {
	  var ret;
	  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function (type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function (emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

/***/ },
/* 189 */
/***/ function(module, exports) {

	/*!
	 * merge-descriptors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = merge;

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Merge the property descriptors of `src` into `dest`
	 *
	 * @param {object} dest Object to add descriptors to
	 * @param {object} src Object to clone descriptors from
	 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	 * @returns {object} Reference to dest
	 * @public
	 */

	function merge(dest, src, redefine) {
	  if (!dest) {
	    throw new TypeError('argument dest is required');
	  }

	  if (!src) {
	    throw new TypeError('argument src is required');
	  }

	  if (redefine === undefined) {
	    // Default to true
	    redefine = true;
	  }

	  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
	    if (!redefine && hasOwnProperty.call(dest, name)) {
	      // Skip desriptor
	      return;
	    }

	    // Copy descriptor
	    var descriptor = Object.getOwnPropertyDescriptor(src, name);
	    Object.defineProperty(dest, name, descriptor);
	  });

	  return dest;
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var finalhandler = __webpack_require__(191);
	var Router = __webpack_require__(206);
	var methods = __webpack_require__(211);
	var middleware = __webpack_require__(223);
	var query = __webpack_require__(224);
	var debug = __webpack_require__(197)('express:application');
	var View = __webpack_require__(229);
	var http = __webpack_require__(293);
	var compileETag = __webpack_require__(231).compileETag;
	var compileQueryParser = __webpack_require__(231).compileQueryParser;
	var compileTrust = __webpack_require__(231).compileTrust;
	var deprecate = __webpack_require__(214)('express');
	var flatten = __webpack_require__(208);
	var merge = __webpack_require__(213);
	var resolve = __webpack_require__(230).resolve;
	var slice = Array.prototype.slice;

	/**
	 * Application prototype.
	 */

	var app = exports = module.exports = {};

	/**
	 * Variable for trust proxy inheritance back-compat
	 * @private
	 */

	var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

	/**
	 * Initialize the server.
	 *
	 *   - setup default configuration
	 *   - setup default middleware
	 *   - setup route reflection methods
	 *
	 * @private
	 */

	app.init = function init() {
	  this.cache = {};
	  this.engines = {};
	  this.settings = {};

	  this.defaultConfiguration();
	};

	/**
	 * Initialize application configuration.
	 * @private
	 */

	app.defaultConfiguration = function defaultConfiguration() {
	  var env = process.env.NODE_ENV || 'development';

	  // default settings
	  this.enable('x-powered-by');
	  this.set('etag', 'weak');
	  this.set('env', env);
	  this.set('query parser', 'extended');
	  this.set('subdomain offset', 2);
	  this.set('trust proxy', false);

	  // trust proxy inherit back-compat
	  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
	    configurable: true,
	    value: true
	  });

	  debug('booting in %s mode', env);

	  this.on('mount', function onmount(parent) {
	    // inherit trust proxy
	    if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings['trust proxy fn'] === 'function') {
	      delete this.settings['trust proxy'];
	      delete this.settings['trust proxy fn'];
	    }

	    // inherit protos
	    this.request.__proto__ = parent.request;
	    this.response.__proto__ = parent.response;
	    this.engines.__proto__ = parent.engines;
	    this.settings.__proto__ = parent.settings;
	  });

	  // setup locals
	  this.locals = Object.create(null);

	  // top-most app is mounted at /
	  this.mountpath = '/';

	  // default locals
	  this.locals.settings = this.settings;

	  // default configuration
	  this.set('view', View);
	  this.set('views', resolve('views'));
	  this.set('jsonp callback name', 'callback');

	  if (env === 'production') {
	    this.enable('view cache');
	  }

	  Object.defineProperty(this, 'router', {
	    get: function get() {
	      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
	    }
	  });
	};

	/**
	 * lazily adds the base router if it has not yet been added.
	 *
	 * We cannot add the base router in the defaultConfiguration because
	 * it reads app settings which might be set after that has run.
	 *
	 * @private
	 */
	app.lazyrouter = function lazyrouter() {
	  if (!this._router) {
	    this._router = new Router({
	      caseSensitive: this.enabled('case sensitive routing'),
	      strict: this.enabled('strict routing')
	    });

	    this._router.use(query(this.get('query parser fn')));
	    this._router.use(middleware.init(this));
	  }
	};

	/**
	 * Dispatch a req, res pair into the application. Starts pipeline processing.
	 *
	 * If no callback is provided, then default error handlers will respond
	 * in the event of an error bubbling through the stack.
	 *
	 * @private
	 */

	app.handle = function handle(req, res, callback) {
	  var router = this._router;

	  // final handler
	  var done = callback || finalhandler(req, res, {
	    env: this.get('env'),
	    onerror: logerror.bind(this)
	  });

	  // no routes
	  if (!router) {
	    debug('no routes defined on app');
	    done();
	    return;
	  }

	  router.handle(req, res, done);
	};

	/**
	 * Proxy `Router#use()` to add middleware to the app router.
	 * See Router#use() documentation for details.
	 *
	 * If the _fn_ parameter is an express app, then it will be
	 * mounted at the _route_ specified.
	 *
	 * @public
	 */

	app.use = function use(fn) {
	  var offset = 0;
	  var path = '/';

	  // default path to '/'
	  // disambiguate app.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;

	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }

	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }

	  var fns = flatten(slice.call(arguments, offset));

	  if (fns.length === 0) {
	    throw new TypeError('app.use() requires middleware functions');
	  }

	  // setup router
	  this.lazyrouter();
	  var router = this._router;

	  fns.forEach(function (fn) {
	    // non-express app
	    if (!fn || !fn.handle || !fn.set) {
	      return router.use(path, fn);
	    }

	    debug('.use app under %s', path);
	    fn.mountpath = path;
	    fn.parent = this;

	    // restore .app property on req and res
	    router.use(path, function mounted_app(req, res, next) {
	      var orig = req.app;
	      fn.handle(req, res, function (err) {
	        req.__proto__ = orig.request;
	        res.__proto__ = orig.response;
	        next(err);
	      });
	    });

	    // mounted an app
	    fn.emit('mount', this);
	  }, this);

	  return this;
	};

	/**
	 * Proxy to the app `Router#route()`
	 * Returns a new `Route` instance for the _path_.
	 *
	 * Routes are isolated middleware stacks for specific paths.
	 * See the Route api docs for details.
	 *
	 * @public
	 */

	app.route = function route(path) {
	  this.lazyrouter();
	  return this._router.route(path);
	};

	/**
	 * Register the given template engine callback `fn`
	 * as `ext`.
	 *
	 * By default will `require()` the engine based on the
	 * file extension. For example if you try to render
	 * a "foo.jade" file Express will invoke the following internally:
	 *
	 *     app.engine('jade', require('jade').__express);
	 *
	 * For engines that do not provide `.__express` out of the box,
	 * or if you wish to "map" a different extension to the template engine
	 * you may use this method. For example mapping the EJS template engine to
	 * ".html" files:
	 *
	 *     app.engine('html', require('ejs').renderFile);
	 *
	 * In this case EJS provides a `.renderFile()` method with
	 * the same signature that Express expects: `(path, options, callback)`,
	 * though note that it aliases this method as `ejs.__express` internally
	 * so if you're using ".ejs" extensions you dont need to do anything.
	 *
	 * Some template engines do not follow this convention, the
	 * [Consolidate.js](https://github.com/tj/consolidate.js)
	 * library was created to map all of node's popular template
	 * engines to follow this convention, thus allowing them to
	 * work seamlessly within Express.
	 *
	 * @param {String} ext
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	app.engine = function engine(ext, fn) {
	  if (typeof fn !== 'function') {
	    throw new Error('callback function required');
	  }

	  // get file extension
	  var extension = ext[0] !== '.' ? '.' + ext : ext;

	  // store engine
	  this.engines[extension] = fn;

	  return this;
	};

	/**
	 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
	 * can be an array of names.
	 *
	 * See the Router#param() docs for more details.
	 *
	 * @param {String|Array} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	app.param = function param(name, fn) {
	  this.lazyrouter();

	  if (Array.isArray(name)) {
	    for (var i = 0; i < name.length; i++) {
	      this.param(name[i], fn);
	    }

	    return this;
	  }

	  this._router.param(name, fn);

	  return this;
	};

	/**
	 * Assign `setting` to `val`, or return `setting`'s value.
	 *
	 *    app.set('foo', 'bar');
	 *    app.get('foo');
	 *    // => "bar"
	 *
	 * Mounted servers inherit their parent server's settings.
	 *
	 * @param {String} setting
	 * @param {*} [val]
	 * @return {Server} for chaining
	 * @public
	 */

	app.set = function set(setting, val) {
	  if (arguments.length === 1) {
	    // app.get(setting)
	    return this.settings[setting];
	  }

	  debug('set "%s" to %o', setting, val);

	  // set value
	  this.settings[setting] = val;

	  // trigger matched settings
	  switch (setting) {
	    case 'etag':
	      this.set('etag fn', compileETag(val));
	      break;
	    case 'query parser':
	      this.set('query parser fn', compileQueryParser(val));
	      break;
	    case 'trust proxy':
	      this.set('trust proxy fn', compileTrust(val));

	      // trust proxy inherit back-compat
	      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
	        configurable: true,
	        value: false
	      });

	      break;
	  }

	  return this;
	};

	/**
	 * Return the app's absolute pathname
	 * based on the parent(s) that have
	 * mounted it.
	 *
	 * For example if the application was
	 * mounted as "/admin", which itself
	 * was mounted as "/blog" then the
	 * return value would be "/blog/admin".
	 *
	 * @return {String}
	 * @private
	 */

	app.path = function path() {
	  return this.parent ? this.parent.path() + this.mountpath : '';
	};

	/**
	 * Check if `setting` is enabled (truthy).
	 *
	 *    app.enabled('foo')
	 *    // => false
	 *
	 *    app.enable('foo')
	 *    app.enabled('foo')
	 *    // => true
	 *
	 * @param {String} setting
	 * @return {Boolean}
	 * @public
	 */

	app.enabled = function enabled(setting) {
	  return Boolean(this.set(setting));
	};

	/**
	 * Check if `setting` is disabled.
	 *
	 *    app.disabled('foo')
	 *    // => true
	 *
	 *    app.enable('foo')
	 *    app.disabled('foo')
	 *    // => false
	 *
	 * @param {String} setting
	 * @return {Boolean}
	 * @public
	 */

	app.disabled = function disabled(setting) {
	  return !this.set(setting);
	};

	/**
	 * Enable `setting`.
	 *
	 * @param {String} setting
	 * @return {app} for chaining
	 * @public
	 */

	app.enable = function enable(setting) {
	  return this.set(setting, true);
	};

	/**
	 * Disable `setting`.
	 *
	 * @param {String} setting
	 * @return {app} for chaining
	 * @public
	 */

	app.disable = function disable(setting) {
	  return this.set(setting, false);
	};

	/**
	 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
	 */

	methods.forEach(function (method) {
	  app[method] = function (path) {
	    if (method === 'get' && arguments.length === 1) {
	      // app.get(setting)
	      return this.set(path);
	    }

	    this.lazyrouter();

	    var route = this._router.route(path);
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});

	/**
	 * Special-cased "all" method, applying the given route `path`,
	 * middleware, and callback to _every_ HTTP method.
	 *
	 * @param {String} path
	 * @param {Function} ...
	 * @return {app} for chaining
	 * @public
	 */

	app.all = function all(path) {
	  this.lazyrouter();

	  var route = this._router.route(path);
	  var args = slice.call(arguments, 1);

	  for (var i = 0; i < methods.length; i++) {
	    route[methods[i]].apply(route, args);
	  }

	  return this;
	};

	// del -> delete alias

	app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

	/**
	 * Render the given view `name` name with `options`
	 * and a callback accepting an error and the
	 * rendered template string.
	 *
	 * Example:
	 *
	 *    app.render('email', { name: 'Tobi' }, function(err, html){
	 *      // ...
	 *    })
	 *
	 * @param {String} name
	 * @param {Object|Function} options or fn
	 * @param {Function} callback
	 * @public
	 */

	app.render = function render(name, options, callback) {
	  var cache = this.cache;
	  var done = callback;
	  var engines = this.engines;
	  var opts = options;
	  var renderOptions = {};
	  var view;

	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // merge app.locals
	  merge(renderOptions, this.locals);

	  // merge options._locals
	  if (opts._locals) {
	    merge(renderOptions, opts._locals);
	  }

	  // merge options
	  merge(renderOptions, opts);

	  // set .cache unless explicitly provided
	  if (renderOptions.cache == null) {
	    renderOptions.cache = this.enabled('view cache');
	  }

	  // primed cache
	  if (renderOptions.cache) {
	    view = cache[name];
	  }

	  // view
	  if (!view) {
	    var View = this.get('view');

	    view = new View(name, {
	      defaultEngine: this.get('view engine'),
	      root: this.get('views'),
	      engines: engines
	    });

	    if (!view.path) {
	      var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
	      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
	      err.view = view;
	      return done(err);
	    }

	    // prime the cache
	    if (renderOptions.cache) {
	      cache[name] = view;
	    }
	  }

	  // render
	  tryRender(view, renderOptions, done);
	};

	/**
	 * Listen for connections.
	 *
	 * A node `http.Server` is returned, with this
	 * application (which is a `Function`) as its
	 * callback. If you wish to create both an HTTP
	 * and HTTPS server you may do so with the "http"
	 * and "https" modules as shown here:
	 *
	 *    var http = require('http')
	 *      , https = require('https')
	 *      , express = require('express')
	 *      , app = express();
	 *
	 *    http.createServer(app).listen(80);
	 *    https.createServer({ ... }, app).listen(443);
	 *
	 * @return {http.Server}
	 * @public
	 */

	app.listen = function listen() {
	  var server = http.createServer(this);
	  return server.listen.apply(server, arguments);
	};

	/**
	 * Log error using console.error.
	 *
	 * @param {Error} err
	 * @private
	 */

	function logerror(err) {
	  /* istanbul ignore next */
	  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
	}

	/**
	 * Try rendering a view.
	 * @private
	 */

	function tryRender(view, options, callback) {
	  try {
	    view.render(options, callback);
	  } catch (err) {
	    callback(err);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process, Buffer) {/*!
	 * finalhandler
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = __webpack_require__(197)('finalhandler');
	var escapeHtml = __webpack_require__(200);
	var onFinished = __webpack_require__(201);
	var statuses = __webpack_require__(203);
	var unpipe = __webpack_require__(205);

	/**
	 * Module variables.
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
	  process.nextTick(fn.bind.apply(fn, arguments));
	};
	var isFinished = onFinished.isFinished;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = finalhandler;

	/**
	 * Create a function to handle the final response.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {Object} [options]
	 * @return {Function}
	 * @public
	 */

	function finalhandler(req, res, options) {
	  var opts = options || {};

	  // get environment
	  var env = opts.env || process.env.NODE_ENV || 'development';

	  // get error callback
	  var onerror = opts.onerror;

	  return function (err) {
	    var headers = Object.create(null);
	    var status;

	    // ignore 404 on in-flight response
	    if (!err && res._header) {
	      debug('cannot 404 after headers sent');
	      return;
	    }

	    // unhandled error
	    if (err) {
	      // respect status code from error
	      status = getErrorStatusCode(err) || res.statusCode;

	      // default status code to 500 if outside valid range
	      if (typeof status !== 'number' || status < 400 || status > 599) {
	        status = 500;
	      }

	      // respect err.headers
	      if (err.headers && (err.status === status || err.statusCode === status)) {
	        var keys = Object.keys(err.headers);
	        for (var i = 0; i < keys.length; i++) {
	          var key = keys[i];
	          headers[key] = err.headers[key];
	        }
	      }

	      // production gets a basic error message
	      var msg = env === 'production' ? statuses[status] : err.stack || err.toString();
	      msg = escapeHtml(msg).replace(/\n/g, '<br>').replace(/\x20{2}/g, ' &nbsp;') + '\n';
	    } else {
	      status = 404;
	      msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n';
	    }

	    debug('default %s', status);

	    // schedule onerror callback
	    if (err && onerror) {
	      defer(onerror, err, req, res);
	    }

	    // cannot actually respond
	    if (res._header) {
	      debug('cannot %d after headers sent', status);
	      req.socket.destroy();
	      return;
	    }

	    // send response
	    send(req, res, status, headers, msg);
	  };
	}

	/**
	 * Get status code from Error object.
	 *
	 * @param {Error} err
	 * @return {number}
	 * @private
	 */

	function getErrorStatusCode(err) {
	  // check err.status
	  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
	    return err.status;
	  }

	  // check err.statusCode
	  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
	    return err.statusCode;
	  }

	  return undefined;
	}

	/**
	 * Send response.
	 *
	 * @param {IncomingMessage} req
	 * @param {OutgoingMessage} res
	 * @param {number} status
	 * @param {object} headers
	 * @param {string} body
	 * @private
	 */

	function send(req, res, status, headers, body) {
	  function write() {
	    // response status
	    res.statusCode = status;
	    res.statusMessage = statuses[status];

	    // response headers
	    var keys = Object.keys(headers);
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      res.setHeader(key, headers[key]);
	    }

	    // security header for content sniffing
	    res.setHeader('X-Content-Type-Options', 'nosniff');

	    // standard headers
	    res.setHeader('Content-Type', 'text/html; charset=utf-8');
	    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));

	    if (req.method === 'HEAD') {
	      res.end();
	      return;
	    }

	    res.end(body, 'utf8');
	  }

	  if (isFinished(req)) {
	    write();
	    return;
	  }

	  // unpipe everything from the request
	  unpipe(req);

	  // flush the request
	  onFinished(req, write);
	  req.resume();
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate, __webpack_require__(4), __webpack_require__(193).Buffer))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {"use strict";

	var nextTick = __webpack_require__(4).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function () {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function () {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function (timeout) {
	  timeout.close();
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function () {};
	Timeout.prototype.close = function () {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function (item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function (item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function (item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout) item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate, __webpack_require__(192).clearImmediate))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict';

	var base64 = __webpack_require__(194);
	var ieee754 = __webpack_require__(195);
	var isArray = __webpack_require__(196);

	exports.Buffer = Buffer;
	exports.SlowBuffer = SlowBuffer;
	exports.INSPECT_MAX_BYTES = 50;
	Buffer.poolSize = 8192; // not used by this implementation

	var rootParent = {};

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

	function typedArraySupport() {
	  function Bar() {}
	  try {
	    var arr = new Uint8Array(1);
	    arr.foo = function () {
	      return 42;
	    };
	    arr.constructor = Bar;
	    return arr.foo() === 42 && // typed array instances can be augmented
	    arr.constructor === Bar && // constructor can be set
	    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
	  } catch (e) {
	    return false;
	  }
	}

	function kMaxLength() {
	  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer(arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1]);
	    return new Buffer(arg);
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0;
	    this.parent = undefined;
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg);
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
	  }

	  // Unusual.
	  return fromObject(this, arg);
	}

	function fromNumber(that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0;
	    }
	  }
	  return that;
	}

	function fromString(that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0;
	  that = allocate(that, length);

	  that.write(string, encoding);
	  return that;
	}

	function fromObject(that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object);

	  if (isArray(object)) return fromArray(that, object);

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string');
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object);
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object);
	    }
	  }

	  if (object.length) return fromArrayLike(that, object);

	  return fromJsonObject(that, object);
	}

	function fromBuffer(that, buffer) {
	  var length = checked(buffer.length) | 0;
	  that = allocate(that, length);
	  buffer.copy(that, 0, 0, length);
	  return that;
	}

	function fromArray(that, array) {
	  var length = checked(array.length) | 0;
	  that = allocate(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that;
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray(that, array) {
	  var length = checked(array.length) | 0;
	  that = allocate(that, length);
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that;
	}

	function fromArrayBuffer(that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength;
	    that = Buffer._augment(new Uint8Array(array));
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array));
	  }
	  return that;
	}

	function fromArrayLike(that, array) {
	  var length = checked(array.length) | 0;
	  that = allocate(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that;
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject(that, object) {
	  var array;
	  var length = 0;

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data;
	    length = checked(array.length) | 0;
	  }
	  that = allocate(that, length);

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that;
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined;
	  Buffer.prototype.parent = undefined;
	}

	function allocate(that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length));
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length;
	    that._isBuffer = true;
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
	  if (fromPool) that.parent = rootParent;

	  return that;
	}

	function checked(length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
	  }
	  return length | 0;
	}

	function SlowBuffer(subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);

	  var buf = new Buffer(subject, encoding);
	  delete buf.parent;
	  return buf;
	}

	Buffer.isBuffer = function isBuffer(b) {
	  return !!(b != null && b._isBuffer);
	};

	Buffer.compare = function compare(a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers');
	  }

	  if (a === b) return 0;

	  var x = a.length;
	  var y = b.length;

	  var i = 0;
	  var len = Math.min(x, y);
	  while (i < len) {
	    if (a[i] !== b[i]) break;

	    ++i;
	  }

	  if (i !== len) {
	    x = a[i];
	    y = b[i];
	  }

	  if (x < y) return -1;
	  if (y < x) return 1;
	  return 0;
	};

	Buffer.isEncoding = function isEncoding(encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true;
	    default:
	      return false;
	  }
	};

	Buffer.concat = function concat(list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.');

	  if (list.length === 0) {
	    return new Buffer(0);
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length;
	    }
	  }

	  var buf = new Buffer(length);
	  var pos = 0;
	  for (i = 0; i < list.length; i++) {
	    var item = list[i];
	    item.copy(buf, pos);
	    pos += item.length;
	  }
	  return buf;
	};

	function byteLength(string, encoding) {
	  if (typeof string !== 'string') string = '' + string;

	  var len = string.length;
	  if (len === 0) return 0;

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len;
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length;
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2;
	      case 'hex':
	        return len >>> 1;
	      case 'base64':
	        return base64ToBytes(string).length;
	      default:
	        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength;

	function slowToString(encoding, start, end) {
	  var loweredCase = false;

	  start = start | 0;
	  end = end === undefined || end === Infinity ? this.length : end | 0;

	  if (!encoding) encoding = 'utf8';
	  if (start < 0) start = 0;
	  if (end > this.length) end = this.length;
	  if (end <= start) return '';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end);

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end);

	      case 'ascii':
	        return asciiSlice(this, start, end);

	      case 'binary':
	        return binarySlice(this, start, end);

	      case 'base64':
	        return base64Slice(this, start, end);

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end);

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	Buffer.prototype.toString = function toString() {
	  var length = this.length | 0;
	  if (length === 0) return '';
	  if (arguments.length === 0) return utf8Slice(this, 0, length);
	  return slowToString.apply(this, arguments);
	};

	Buffer.prototype.equals = function equals(b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
	  if (this === b) return true;
	  return Buffer.compare(this, b) === 0;
	};

	Buffer.prototype.inspect = function inspect() {
	  var str = '';
	  var max = exports.INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>';
	};

	Buffer.prototype.compare = function compare(b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
	  if (this === b) return 0;
	  return Buffer.compare(this, b);
	};

	Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;else if (byteOffset < -0x80000000) byteOffset = -0x80000000;
	  byteOffset >>= 0;

	  if (this.length === 0) return -1;
	  if (byteOffset >= this.length) return -1;

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1; // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset);
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset);
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
	    }
	    return arrayIndexOf(this, [val], byteOffset);
	  }

	  function arrayIndexOf(arr, val, byteOffset) {
	    var foundIndex = -1;
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
	      } else {
	        foundIndex = -1;
	      }
	    }
	    return -1;
	  }

	  throw new TypeError('val must be string, number or Buffer');
	};

	// `get` is deprecated
	Buffer.prototype.get = function get(offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.');
	  return this.readUInt8(offset);
	};

	// `set` is deprecated
	Buffer.prototype.set = function set(v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.');
	  return this.writeUInt8(v, offset);
	};

	function hexWrite(buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string');

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) throw new Error('Invalid hex string');
	    buf[offset + i] = parsed;
	  }
	  return i;
	}

	function utf8Write(buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
	}

	function asciiWrite(buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length);
	}

	function binaryWrite(buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length);
	}

	function base64Write(buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length);
	}

	function ucs2Write(buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
	}

	Buffer.prototype.write = function write(string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	    // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	    // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	    // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding;
	    encoding = offset;
	    offset = length | 0;
	    length = swap;
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds');
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length);

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length);

	      case 'ascii':
	        return asciiWrite(this, string, offset, length);

	      case 'binary':
	        return binaryWrite(this, string, offset, length);

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length);

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length);

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer.prototype.toJSON = function toJSON() {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  };
	};

	function base64Slice(buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf);
	  } else {
	    return base64.fromByteArray(buf.slice(start, end));
	  }
	}

	function utf8Slice(buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break;
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break;
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break;
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res);
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray(codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
	  }
	  return res;
	}

	function asciiSlice(buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret;
	}

	function binarySlice(buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret;
	}

	function hexSlice(buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i]);
	  }
	  return out;
	}

	function utf16leSlice(buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res;
	}

	Buffer.prototype.slice = function slice(start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end));
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this;

	  return newBuf;
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset(offset, ext, length) {
	  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
	}

	Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val;
	};

	Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val;
	};

	Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset];
	};

	Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | this[offset + 1] << 8;
	};

	Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] << 8 | this[offset + 1];
	};

	Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
	};

	Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
	};

	Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val;
	};

	Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val;
	};

	Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return this[offset];
	  return (0xff - this[offset] + 1) * -1;
	};

	Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | this[offset + 1] << 8;
	  return val & 0x8000 ? val | 0xFFFF0000 : val;
	};

	Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | this[offset] << 8;
	  return val & 0x8000 ? val | 0xFFFF0000 : val;
	};

	Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
	};

	Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
	};

	Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return ieee754.read(this, offset, true, 23, 4);
	};

	Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return ieee754.read(this, offset, false, 23, 4);
	};

	Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return ieee754.read(this, offset, true, 52, 8);
	};

	Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return ieee754.read(this, offset, false, 52, 8);
	};

	function checkInt(buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance');
	  if (value > max || value < min) throw new RangeError('value is out of bounds');
	  if (offset + ext > buf.length) throw new RangeError('index out of range');
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = value / mul & 0xFF;
	  }

	  return offset + byteLength;
	};

	Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = value / mul & 0xFF;
	  }

	  return offset + byteLength;
	};

	Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = value & 0xff;
	  return offset + 1;
	};

	function objectWriteUInt16(buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2;
	};

	Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2;
	};

	function objectWriteUInt32(buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = value >>> 24;
	    this[offset + 2] = value >>> 16;
	    this[offset + 1] = value >>> 8;
	    this[offset] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4;
	};

	Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4;
	};

	Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = value < 0 ? 1 : 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength;
	};

	Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = value < 0 ? 1 : 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength;
	};

	Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = value & 0xff;
	  return offset + 1;
	};

	Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2;
	};

	Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2;
	};

	Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    this[offset + 2] = value >>> 16;
	    this[offset + 3] = value >>> 24;
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4;
	};

	Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4;
	};

	function checkIEEE754(buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds');
	  if (offset + ext > buf.length) throw new RangeError('index out of range');
	  if (offset < 0) throw new RangeError('index out of range');
	}

	function writeFloat(buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4;
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert);
	};

	Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert);
	};

	function writeDouble(buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8;
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert);
	};

	Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert);
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy(target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0;
	  if (target.length === 0 || this.length === 0) return 0;

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds');
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
	  if (end < 0) throw new RangeError('sourceEnd out of bounds');

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart);
	  }

	  return len;
	};

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill(value, start, end) {
	  if (!value) value = 0;
	  if (!start) start = 0;
	  if (!end) end = this.length;

	  if (end < start) throw new RangeError('end < start');

	  // Fill 0 bytes; we're done
	  if (end === start) return;
	  if (this.length === 0) return;

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds');
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds');

	  var i;
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value;
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString());
	    var len = bytes.length;
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len];
	    }
	  }

	  return this;
	};

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return new Buffer(this).buffer;
	    } else {
	      var buf = new Uint8Array(this.length);
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i];
	      }
	      return buf.buffer;
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
	  }
	};

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype;

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment(arr) {
	  arr.constructor = Buffer;
	  arr._isBuffer = true;

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set;

	  // deprecated
	  arr.get = BP.get;
	  arr.set = BP.set;

	  arr.write = BP.write;
	  arr.toString = BP.toString;
	  arr.toLocaleString = BP.toString;
	  arr.toJSON = BP.toJSON;
	  arr.equals = BP.equals;
	  arr.compare = BP.compare;
	  arr.indexOf = BP.indexOf;
	  arr.copy = BP.copy;
	  arr.slice = BP.slice;
	  arr.readUIntLE = BP.readUIntLE;
	  arr.readUIntBE = BP.readUIntBE;
	  arr.readUInt8 = BP.readUInt8;
	  arr.readUInt16LE = BP.readUInt16LE;
	  arr.readUInt16BE = BP.readUInt16BE;
	  arr.readUInt32LE = BP.readUInt32LE;
	  arr.readUInt32BE = BP.readUInt32BE;
	  arr.readIntLE = BP.readIntLE;
	  arr.readIntBE = BP.readIntBE;
	  arr.readInt8 = BP.readInt8;
	  arr.readInt16LE = BP.readInt16LE;
	  arr.readInt16BE = BP.readInt16BE;
	  arr.readInt32LE = BP.readInt32LE;
	  arr.readInt32BE = BP.readInt32BE;
	  arr.readFloatLE = BP.readFloatLE;
	  arr.readFloatBE = BP.readFloatBE;
	  arr.readDoubleLE = BP.readDoubleLE;
	  arr.readDoubleBE = BP.readDoubleBE;
	  arr.writeUInt8 = BP.writeUInt8;
	  arr.writeUIntLE = BP.writeUIntLE;
	  arr.writeUIntBE = BP.writeUIntBE;
	  arr.writeUInt16LE = BP.writeUInt16LE;
	  arr.writeUInt16BE = BP.writeUInt16BE;
	  arr.writeUInt32LE = BP.writeUInt32LE;
	  arr.writeUInt32BE = BP.writeUInt32BE;
	  arr.writeIntLE = BP.writeIntLE;
	  arr.writeIntBE = BP.writeIntBE;
	  arr.writeInt8 = BP.writeInt8;
	  arr.writeInt16LE = BP.writeInt16LE;
	  arr.writeInt16BE = BP.writeInt16BE;
	  arr.writeInt32LE = BP.writeInt32LE;
	  arr.writeInt32BE = BP.writeInt32BE;
	  arr.writeFloatLE = BP.writeFloatLE;
	  arr.writeFloatBE = BP.writeFloatBE;
	  arr.writeDoubleLE = BP.writeDoubleLE;
	  arr.writeDoubleBE = BP.writeDoubleBE;
	  arr.fill = BP.fill;
	  arr.inspect = BP.inspect;
	  arr.toArrayBuffer = BP.toArrayBuffer;

	  return arr;
	};

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean(str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return '';
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str;
	}

	function stringtrim(str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	}

	function toHex(n) {
	  if (n < 16) return '0' + n.toString(16);
	  return n.toString(16);
	}

	function utf8ToBytes(string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue;
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue;
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue;
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue;
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break;
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break;
	      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break;
	      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break;
	      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	    } else {
	      throw new Error('Invalid code point');
	    }
	  }

	  return bytes;
	}

	function asciiToBytes(str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray;
	}

	function utf16leToBytes(str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break;

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray;
	}

	function base64ToBytes(str) {
	  return base64.toByteArray(base64clean(str));
	}

	function blitBuffer(src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if (i + offset >= dst.length || i >= src.length) break;
	    dst[i + offset] = src[i];
	  }
	  return i;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer, (function() { return this; }())))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

		var PLUS = '+'.charCodeAt(0);
		var SLASH = '/'.charCodeAt(0);
		var NUMBER = '0'.charCodeAt(0);
		var LOWER = 'a'.charCodeAt(0);
		var UPPER = 'A'.charCodeAt(0);
		var PLUS_URL_SAFE = '-'.charCodeAt(0);
		var SLASH_URL_SAFE = '_'.charCodeAt(0);

		function decode(elt) {
			var code = elt.charCodeAt(0);
			if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'
			if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'
			if (code < NUMBER) return -1; //no match
			if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
			if (code < UPPER + 26) return code - UPPER;
			if (code < LOWER + 26) return code - LOWER + 26;
		}

		function b64ToByteArray(b64) {
			var i, j, l, tmp, placeHolders, arr;

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4');
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length;
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders);

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length;

			var L = 0;

			function push(v) {
				arr[L++] = v;
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
				push((tmp & 0xFF0000) >> 16);
				push((tmp & 0xFF00) >> 8);
				push(tmp & 0xFF);
			}

			if (placeHolders === 2) {
				tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
				push(tmp & 0xFF);
			} else if (placeHolders === 1) {
				tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
				push(tmp >> 8 & 0xFF);
				push(tmp & 0xFF);
			}

			return arr;
		}

		function uint8ToBase64(uint8) {
			var i,
			    extraBytes = uint8.length % 3,
			    // if we have 1 byte left, pad 2 bytes
			output = "",
			    temp,
			    length;

			function encode(num) {
				return lookup.charAt(num);
			}

			function tripletToBase64(num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
				output += tripletToBase64(temp);
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1];
					output += encode(temp >> 2);
					output += encode(temp << 4 & 0x3F);
					output += '==';
					break;
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
					output += encode(temp >> 10);
					output += encode(temp >> 4 & 0x3F);
					output += encode(temp << 2 & 0x3F);
					output += '=';
					break;
			}

			return output;
		}

		exports.toByteArray = b64ToByteArray;
		exports.fromByteArray = uint8ToBase64;
	})( false ? undefined.base64js = {} : exports);

/***/ },
/* 195 */
/***/ function(module, exports) {

	"use strict";

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? nBytes - 1 : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & (1 << -nBits) - 1;
	  s >>= -nBits;
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : (s ? -1 : 1) * Infinity;
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
	  var i = isLE ? 0 : nBytes - 1;
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};

/***/ },
/* 196 */
/***/ function(module, exports) {

	'use strict';

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(198);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return 'WebkitAppearance' in document.documentElement.style ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  window.console && (console.firebug || console.exception && console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function (v) {
	  return JSON.stringify(v);
	};

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(199);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {}
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ },
/* 199 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function (val, options) {
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long ? long(val) : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ },
/* 200 */
/***/ function(module, exports) {

	/*!
	 * escape-html
	 * Copyright(c) 2012-2013 TJ Holowaychuk
	 * Copyright(c) 2015 Andreas Lubbe
	 * Copyright(c) 2015 Tiancheng "Timothy" Gu
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = escapeHtml;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#39;';
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process) {/*!
	 * on-finished
	 * Copyright(c) 2013 Jonathan Ong
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = onFinished;
	module.exports.isFinished = isFinished;

	/**
	 * Module dependencies.
	 * @private
	 */

	var first = __webpack_require__(202);

	/**
	 * Variables.
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
	  process.nextTick(fn.bind.apply(fn, arguments));
	};

	/**
	 * Invoke callback when the response has finished, useful for
	 * cleaning up resources afterwards.
	 *
	 * @param {object} msg
	 * @param {function} listener
	 * @return {object}
	 * @public
	 */

	function onFinished(msg, listener) {
	  if (isFinished(msg) !== false) {
	    defer(listener, null, msg);
	    return msg;
	  }

	  // attach the listener to the message
	  attachListener(msg, listener);

	  return msg;
	}

	/**
	 * Determine if message is already finished.
	 *
	 * @param {object} msg
	 * @return {boolean}
	 * @public
	 */

	function isFinished(msg) {
	  var socket = msg.socket;

	  if (typeof msg.finished === 'boolean') {
	    // OutgoingMessage
	    return Boolean(msg.finished || socket && !socket.writable);
	  }

	  if (typeof msg.complete === 'boolean') {
	    // IncomingMessage
	    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	  }

	  // don't know
	  return undefined;
	}

	/**
	 * Attach a finished listener to the message.
	 *
	 * @param {object} msg
	 * @param {function} callback
	 * @private
	 */

	function attachFinishedListener(msg, callback) {
	  var eeMsg;
	  var eeSocket;
	  var finished = false;

	  function onFinish(error) {
	    eeMsg.cancel();
	    eeSocket.cancel();

	    finished = true;
	    callback(error);
	  }

	  // finished on first message event
	  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);

	  function onSocket(socket) {
	    // remove listener
	    msg.removeListener('socket', onSocket);

	    if (finished) return;
	    if (eeMsg !== eeSocket) return;

	    // finished on first socket event
	    eeSocket = first([[socket, 'error', 'close']], onFinish);
	  }

	  if (msg.socket) {
	    // socket already assigned
	    onSocket(msg.socket);
	    return;
	  }

	  // wait for socket to be assigned
	  msg.on('socket', onSocket);

	  if (msg.socket === undefined) {
	    // node.js 0.8 patch
	    patchAssignSocket(msg, onSocket);
	  }
	}

	/**
	 * Attach the listener to the message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */

	function attachListener(msg, listener) {
	  var attached = msg.__onFinished;

	  // create a private single listener with queue
	  if (!attached || !attached.queue) {
	    attached = msg.__onFinished = createListener(msg);
	    attachFinishedListener(msg, attached);
	  }

	  attached.queue.push(listener);
	}

	/**
	 * Create listener on message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */

	function createListener(msg) {
	  function listener(err) {
	    if (msg.__onFinished === listener) msg.__onFinished = null;
	    if (!listener.queue) return;

	    var queue = listener.queue;
	    listener.queue = null;

	    for (var i = 0; i < queue.length; i++) {
	      queue[i](err, msg);
	    }
	  }

	  listener.queue = [];

	  return listener;
	}

	/**
	 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	 *
	 * @param {ServerResponse} res
	 * @param {function} callback
	 * @private
	 */

	function patchAssignSocket(res, callback) {
	  var assignSocket = res.assignSocket;

	  if (typeof assignSocket !== 'function') return;

	  // res.on('socket', callback) is broken in 0.8
	  res.assignSocket = function _assignSocket(socket) {
	    assignSocket.call(this, socket);
	    callback(socket);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate, __webpack_require__(4)))

/***/ },
/* 202 */
/***/ function(module, exports) {

	/*!
	 * ee-first
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = first;

	/**
	 * Get the first event in a set of event emitters and event pairs.
	 *
	 * @param {array} stuff
	 * @param {function} done
	 * @public
	 */

	function first(stuff, done) {
	  if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');

	  var cleanups = [];

	  for (var i = 0; i < stuff.length; i++) {
	    var arr = stuff[i];

	    if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');

	    var ee = arr[0];

	    for (var j = 1; j < arr.length; j++) {
	      var event = arr[j];
	      var fn = listener(event, callback);

	      // listen to the event
	      ee.on(event, fn);
	      // push this listener to the list of cleanups
	      cleanups.push({
	        ee: ee,
	        event: event,
	        fn: fn
	      });
	    }
	  }

	  function callback() {
	    cleanup();
	    done.apply(null, arguments);
	  }

	  function cleanup() {
	    var x;
	    for (var i = 0; i < cleanups.length; i++) {
	      x = cleanups[i];
	      x.ee.removeListener(x.event, x.fn);
	    }
	  }

	  function thunk(fn) {
	    done = fn;
	  }

	  thunk.cancel = cleanup;

	  return thunk;
	}

	/**
	 * Create the event listener.
	 * @private
	 */

	function listener(event, done) {
	  return function onevent(arg1) {
	    var args = new Array(arguments.length);
	    var ee = this;
	    var err = event === 'error' ? arg1 : null;

	    // copy args to prevent arguments escaping scope
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    done(err, ee, event, args);
	  };
	}

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * statuses
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var codes = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./codes.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = status;

	// array of status codes
	status.codes = populateStatusesMap(status, codes);

	// status codes for redirects
	status.redirect = {
	  300: true,
	  301: true,
	  302: true,
	  303: true,
	  305: true,
	  307: true,
	  308: true
	};

	// status codes for empty bodies
	status.empty = {
	  204: true,
	  205: true,
	  304: true
	};

	// status codes for when you should retry the request
	status.retry = {
	  502: true,
	  503: true,
	  504: true
	};

	/**
	 * Populate the statuses map for given codes.
	 * @private
	 */

	function populateStatusesMap(statuses, codes) {
	  var arr = [];

	  Object.keys(codes).forEach(function forEachCode(code) {
	    var message = codes[code];
	    var status = Number(code);

	    // Populate properties
	    statuses[status] = message;
	    statuses[message] = status;
	    statuses[message.toLowerCase()] = status;

	    // Add to array
	    arr.push(status);
	  });

	  return arr;
	}

	/**
	 * Get the status code.
	 *
	 * Given a number, this will throw if it is not a known status
	 * code, otherwise the code will be returned. Given a string,
	 * the string will be parsed for a number and return the code
	 * if valid, otherwise will lookup the code assuming this is
	 * the status message.
	 *
	 * @param {string|number} code
	 * @returns {string}
	 * @public
	 */

	function status(code) {
	  if (typeof code === 'number') {
	    if (!status[code]) throw new Error('invalid status code: ' + code);
	    return code;
	  }

	  if (typeof code !== 'string') {
	    throw new TypeError('code must be a number or string');
	  }

	  // '403'
	  var n = parseInt(code, 10);
	  if (!isNaN(n)) {
	    if (!status[n]) throw new Error('invalid status code: ' + n);
	    return n;
	  }

	  n = status[code.toLowerCase()];
	  if (!n) throw new Error('invalid status message: "' + code + '"');
	  return n;
	}

/***/ },
/* 204 */,
/* 205 */
/***/ function(module, exports) {

	/*!
	 * unpipe
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = unpipe;

	/**
	 * Determine if there are Node.js pipe-like data listeners.
	 * @private
	 */

	function hasPipeDataListeners(stream) {
	  var listeners = stream.listeners('data');

	  for (var i = 0; i < listeners.length; i++) {
	    if (listeners[i].name === 'ondata') {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * Unpipe a stream from all destinations.
	 *
	 * @param {object} stream
	 * @public
	 */

	function unpipe(stream) {
	  if (!stream) {
	    throw new TypeError('argument stream is required');
	  }

	  if (typeof stream.unpipe === 'function') {
	    // new-style
	    stream.unpipe();
	    return;
	  }

	  // Node.js 0.8 hack
	  if (!hasPipeDataListeners(stream)) {
	    return;
	  }

	  var listener;
	  var listeners = stream.listeners('close');

	  for (var i = 0; i < listeners.length; i++) {
	    listener = listeners[i];

	    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
	      continue;
	    }

	    // invoke the listener
	    listener.call(stream);
	  }
	}

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Route = __webpack_require__(207);
	var Layer = __webpack_require__(209);
	var methods = __webpack_require__(211);
	var mixin = __webpack_require__(213);
	var debug = __webpack_require__(197)('express:router');
	var deprecate = __webpack_require__(214)('express');
	var flatten = __webpack_require__(208);
	var parseUrl = __webpack_require__(215);

	/**
	 * Module variables.
	 * @private
	 */

	var objectRegExp = /^\[object (\S+)\]$/;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;

	/**
	 * Initialize a new `Router` with the given `options`.
	 *
	 * @param {Object} options
	 * @return {Router} which is an callable function
	 * @public
	 */

	var proto = module.exports = function (options) {
	  var opts = options || {};

	  function router(req, res, next) {
	    router.handle(req, res, next);
	  }

	  // mixin Router class functions
	  router.__proto__ = proto;

	  router.params = {};
	  router._params = [];
	  router.caseSensitive = opts.caseSensitive;
	  router.mergeParams = opts.mergeParams;
	  router.strict = opts.strict;
	  router.stack = [];

	  return router;
	};

	/**
	 * Map the given param placeholder `name`(s) to the given callback.
	 *
	 * Parameter mapping is used to provide pre-conditions to routes
	 * which use normalized placeholders. For example a _:user_id_ parameter
	 * could automatically load a user's information from the database without
	 * any additional code,
	 *
	 * The callback uses the same signature as middleware, the only difference
	 * being that the value of the placeholder is passed, in this case the _id_
	 * of the user. Once the `next()` function is invoked, just like middleware
	 * it will continue on to execute the route, or subsequent parameter functions.
	 *
	 * Just like in middleware, you must either respond to the request or call next
	 * to avoid stalling the request.
	 *
	 *  app.param('user_id', function(req, res, next, id){
	 *    User.find(id, function(err, user){
	 *      if (err) {
	 *        return next(err);
	 *      } else if (!user) {
	 *        return next(new Error('failed to load user'));
	 *      }
	 *      req.user = user;
	 *      next();
	 *    });
	 *  });
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	proto.param = function param(name, fn) {
	  // param logic
	  if (typeof name === 'function') {
	    deprecate('router.param(fn): Refactor to use path params');
	    this._params.push(name);
	    return;
	  }

	  // apply param functions
	  var params = this._params;
	  var len = params.length;
	  var ret;

	  if (name[0] === ':') {
	    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
	    name = name.substr(1);
	  }

	  for (var i = 0; i < len; ++i) {
	    if (ret = params[i](name, fn)) {
	      fn = ret;
	    }
	  }

	  // ensure we end up with a
	  // middleware function
	  if ('function' !== typeof fn) {
	    throw new Error('invalid param() call for ' + name + ', got ' + fn);
	  }

	  (this.params[name] = this.params[name] || []).push(fn);
	  return this;
	};

	/**
	 * Dispatch a req, res into the router.
	 * @private
	 */

	proto.handle = function handle(req, res, out) {
	  var self = this;

	  debug('dispatching %s %s', req.method, req.url);

	  var search = 1 + req.url.indexOf('?');
	  var pathlength = search ? search - 1 : req.url.length;
	  var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');
	  var protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn)) : '';
	  var idx = 0;
	  var removed = '';
	  var slashAdded = false;
	  var paramcalled = {};

	  // store options for OPTIONS request
	  // only used if OPTIONS request
	  var options = [];

	  // middleware and routes
	  var stack = self.stack;

	  // manage inter-router variables
	  var parentParams = req.params;
	  var parentUrl = req.baseUrl || '';
	  var done = restore(out, req, 'baseUrl', 'next', 'params');

	  // setup next layer
	  req.next = next;

	  // for options requests, respond with a default if nothing else responds
	  if (req.method === 'OPTIONS') {
	    done = wrap(done, function (old, err) {
	      if (err || options.length === 0) return old(err);
	      sendOptionsResponse(res, options, old);
	    });
	  }

	  // setup basic req values
	  req.baseUrl = parentUrl;
	  req.originalUrl = req.originalUrl || req.url;

	  next();

	  function next(err) {
	    var layerError = err === 'route' ? null : err;

	    // remove added slash
	    if (slashAdded) {
	      req.url = req.url.substr(1);
	      slashAdded = false;
	    }

	    // restore altered req.url
	    if (removed.length !== 0) {
	      req.baseUrl = parentUrl;
	      req.url = protohost + removed + req.url.substr(protohost.length);
	      removed = '';
	    }

	    // no more matching layers
	    if (idx >= stack.length) {
	      setImmediate(done, layerError);
	      return;
	    }

	    // get pathname of request
	    var path = getPathname(req);

	    if (path == null) {
	      return done(layerError);
	    }

	    // find next matching layer
	    var layer;
	    var match;
	    var route;

	    while (match !== true && idx < stack.length) {
	      layer = stack[idx++];
	      match = matchLayer(layer, path);
	      route = layer.route;

	      if (typeof match !== 'boolean') {
	        // hold on to layerError
	        layerError = layerError || match;
	      }

	      if (match !== true) {
	        continue;
	      }

	      if (!route) {
	        // process non-route handlers normally
	        continue;
	      }

	      if (layerError) {
	        // routes do not match with a pending error
	        match = false;
	        continue;
	      }

	      var method = req.method;
	      var has_method = route._handles_method(method);

	      // build up automatic options response
	      if (!has_method && method === 'OPTIONS') {
	        appendMethods(options, route._options());
	      }

	      // don't even bother matching route
	      if (!has_method && method !== 'HEAD') {
	        match = false;
	        continue;
	      }
	    }

	    // no match
	    if (match !== true) {
	      return done(layerError);
	    }

	    // store route for dispatch on change
	    if (route) {
	      req.route = route;
	    }

	    // Capture one-time layer values
	    req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
	    var layerPath = layer.path;

	    // this should be done for the layer
	    self.process_params(layer, paramcalled, req, res, function (err) {
	      if (err) {
	        return next(layerError || err);
	      }

	      if (route) {
	        return layer.handle_request(req, res, next);
	      }

	      trim_prefix(layer, layerError, layerPath, path);
	    });
	  }

	  function trim_prefix(layer, layerError, layerPath, path) {
	    var c = path[layerPath.length];
	    if (c && '/' !== c && '.' !== c) return next(layerError);

	    // Trim off the part of the url that matches the route
	    // middleware (.use stuff) needs to have the path stripped
	    if (layerPath.length !== 0) {
	      debug('trim prefix (%s) from url %s', layerPath, req.url);
	      removed = layerPath;
	      req.url = protohost + req.url.substr(protohost.length + removed.length);

	      // Ensure leading slash
	      if (!fqdn && req.url[0] !== '/') {
	        req.url = '/' + req.url;
	        slashAdded = true;
	      }

	      // Setup base URL (no trailing slash)
	      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);
	    }

	    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

	    if (layerError) {
	      layer.handle_error(layerError, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};

	/**
	 * Process any parameters for the layer.
	 * @private
	 */

	proto.process_params = function process_params(layer, called, req, res, done) {
	  var params = this.params;

	  // captured parameters from the layer, keys and values
	  var keys = layer.keys;

	  // fast track
	  if (!keys || keys.length === 0) {
	    return done();
	  }

	  var i = 0;
	  var name;
	  var paramIndex = 0;
	  var key;
	  var paramVal;
	  var paramCallbacks;
	  var paramCalled;

	  // process params in order
	  // param callbacks can be async
	  function param(err) {
	    if (err) {
	      return done(err);
	    }

	    if (i >= keys.length) {
	      return done();
	    }

	    paramIndex = 0;
	    key = keys[i++];

	    if (!key) {
	      return done();
	    }

	    name = key.name;
	    paramVal = req.params[name];
	    paramCallbacks = params[name];
	    paramCalled = called[name];

	    if (paramVal === undefined || !paramCallbacks) {
	      return param();
	    }

	    // param previously called with same value or error occurred
	    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {
	      // restore value
	      req.params[name] = paramCalled.value;

	      // next param
	      return param(paramCalled.error);
	    }

	    called[name] = paramCalled = {
	      error: null,
	      match: paramVal,
	      value: paramVal
	    };

	    paramCallback();
	  }

	  // single param callbacks
	  function paramCallback(err) {
	    var fn = paramCallbacks[paramIndex++];

	    // store updated value
	    paramCalled.value = req.params[key.name];

	    if (err) {
	      // store error
	      paramCalled.error = err;
	      param(err);
	      return;
	    }

	    if (!fn) return param();

	    try {
	      fn(req, res, paramCallback, paramVal, key.name);
	    } catch (e) {
	      paramCallback(e);
	    }
	  }

	  param();
	};

	/**
	 * Use the given middleware function, with optional path, defaulting to "/".
	 *
	 * Use (like `.all`) will run for any http METHOD, but it will not add
	 * handlers for those methods so OPTIONS requests will not consider `.use`
	 * functions even if they could respond.
	 *
	 * The other difference is that _route_ path is stripped and not visible
	 * to the handler function. The main effect of this feature is that mounted
	 * handlers can operate without any code changes regardless of the "prefix"
	 * pathname.
	 *
	 * @public
	 */

	proto.use = function use(fn) {
	  var offset = 0;
	  var path = '/';

	  // default path to '/'
	  // disambiguate router.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;

	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }

	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }

	  var callbacks = flatten(slice.call(arguments, offset));

	  if (callbacks.length === 0) {
	    throw new TypeError('Router.use() requires middleware functions');
	  }

	  for (var i = 0; i < callbacks.length; i++) {
	    var fn = callbacks[i];

	    if (typeof fn !== 'function') {
	      throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));
	    }

	    // add the middleware
	    debug('use %s %s', path, fn.name || '<anonymous>');

	    var layer = new Layer(path, {
	      sensitive: this.caseSensitive,
	      strict: false,
	      end: false
	    }, fn);

	    layer.route = undefined;

	    this.stack.push(layer);
	  }

	  return this;
	};

	/**
	 * Create a new Route for the given path.
	 *
	 * Each route contains a separate middleware stack and VERB handlers.
	 *
	 * See the Route api documentation for details on adding handlers
	 * and middleware to routes.
	 *
	 * @param {String} path
	 * @return {Route}
	 * @public
	 */

	proto.route = function route(path) {
	  var route = new Route(path);

	  var layer = new Layer(path, {
	    sensitive: this.caseSensitive,
	    strict: this.strict,
	    end: true
	  }, route.dispatch.bind(route));

	  layer.route = route;

	  this.stack.push(layer);
	  return route;
	};

	// create Router#VERB functions
	methods.concat('all').forEach(function (method) {
	  proto[method] = function (path) {
	    var route = this.route(path);
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});

	// append methods to a list of methods
	function appendMethods(list, addition) {
	  for (var i = 0; i < addition.length; i++) {
	    var method = addition[i];
	    if (list.indexOf(method) === -1) {
	      list.push(method);
	    }
	  }
	}

	// get pathname of request
	function getPathname(req) {
	  try {
	    return parseUrl(req).pathname;
	  } catch (err) {
	    return undefined;
	  }
	}

	// get type for error message
	function gettype(obj) {
	  var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);

	  if (type !== 'object') {
	    return type;
	  }

	  // inspect [[Class]] for objects
	  return toString.call(obj).replace(objectRegExp, '$1');
	}

	/**
	 * Match path to a layer.
	 *
	 * @param {Layer} layer
	 * @param {string} path
	 * @private
	 */

	function matchLayer(layer, path) {
	  try {
	    return layer.match(path);
	  } catch (err) {
	    return err;
	  }
	}

	// merge params with parent params
	function mergeParams(params, parent) {
	  if ((typeof parent === 'undefined' ? 'undefined' : _typeof(parent)) !== 'object' || !parent) {
	    return params;
	  }

	  // make copy of parent for base
	  var obj = mixin({}, parent);

	  // simple non-numeric merging
	  if (!(0 in params) || !(0 in parent)) {
	    return mixin(obj, params);
	  }

	  var i = 0;
	  var o = 0;

	  // determine numeric gaps
	  while (i in params) {
	    i++;
	  }

	  while (o in parent) {
	    o++;
	  }

	  // offset numeric indices in params before merge
	  for (i--; i >= 0; i--) {
	    params[i + o] = params[i];

	    // create holes for the merge when necessary
	    if (i < o) {
	      delete params[i];
	    }
	  }

	  return mixin(obj, params);
	}

	// restore obj props after function
	function restore(fn, obj) {
	  var props = new Array(arguments.length - 2);
	  var vals = new Array(arguments.length - 2);

	  for (var i = 0; i < props.length; i++) {
	    props[i] = arguments[i + 2];
	    vals[i] = obj[props[i]];
	  }

	  return function (err) {
	    // restore vals
	    for (var i = 0; i < props.length; i++) {
	      obj[props[i]] = vals[i];
	    }

	    return fn.apply(this, arguments);
	  };
	}

	// send an OPTIONS response
	function sendOptionsResponse(res, options, next) {
	  try {
	    var body = options.join(',');
	    res.set('Allow', body);
	    res.send(body);
	  } catch (err) {
	    next(err);
	  }
	}

	// wrap a function
	function wrap(old, fn) {
	  return function proxy() {
	    var args = new Array(arguments.length + 1);

	    args[0] = old;
	    for (var i = 0, len = arguments.length; i < len; i++) {
	      args[i + 1] = arguments[i];
	    }

	    fn.apply(this, args);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = __webpack_require__(197)('express:router:route');
	var flatten = __webpack_require__(208);
	var Layer = __webpack_require__(209);
	var methods = __webpack_require__(211);

	/**
	 * Module variables.
	 * @private
	 */

	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Route;

	/**
	 * Initialize `Route` with the given `path`,
	 *
	 * @param {String} path
	 * @public
	 */

	function Route(path) {
	  this.path = path;
	  this.stack = [];

	  debug('new %s', path);

	  // route handlers for various http methods
	  this.methods = {};
	}

	/**
	 * Determine if the route handles a given method.
	 * @private
	 */

	Route.prototype._handles_method = function _handles_method(method) {
	  if (this.methods._all) {
	    return true;
	  }

	  var name = method.toLowerCase();

	  if (name === 'head' && !this.methods['head']) {
	    name = 'get';
	  }

	  return Boolean(this.methods[name]);
	};

	/**
	 * @return {Array} supported HTTP methods
	 * @private
	 */

	Route.prototype._options = function _options() {
	  var methods = Object.keys(this.methods);

	  // append automatic head
	  if (this.methods.get && !this.methods.head) {
	    methods.push('head');
	  }

	  for (var i = 0; i < methods.length; i++) {
	    // make upper case
	    methods[i] = methods[i].toUpperCase();
	  }

	  return methods;
	};

	/**
	 * dispatch req, res into this route
	 * @private
	 */

	Route.prototype.dispatch = function dispatch(req, res, done) {
	  var idx = 0;
	  var stack = this.stack;
	  if (stack.length === 0) {
	    return done();
	  }

	  var method = req.method.toLowerCase();
	  if (method === 'head' && !this.methods['head']) {
	    method = 'get';
	  }

	  req.route = this;

	  next();

	  function next(err) {
	    if (err && err === 'route') {
	      return done();
	    }

	    var layer = stack[idx++];
	    if (!layer) {
	      return done(err);
	    }

	    if (layer.method && layer.method !== method) {
	      return next(err);
	    }

	    if (err) {
	      layer.handle_error(err, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};

	/**
	 * Add a handler for all HTTP verbs to this route.
	 *
	 * Behaves just like middleware and can respond or call `next`
	 * to continue processing.
	 *
	 * You can use multiple `.all` call to add multiple handlers.
	 *
	 *   function check_something(req, res, next){
	 *     next();
	 *   };
	 *
	 *   function validate_user(req, res, next){
	 *     next();
	 *   };
	 *
	 *   route
	 *   .all(validate_user)
	 *   .all(check_something)
	 *   .get(function(req, res, next){
	 *     res.send('hello world');
	 *   });
	 *
	 * @param {function} handler
	 * @return {Route} for chaining
	 * @api public
	 */

	Route.prototype.all = function all() {
	  var handles = flatten(slice.call(arguments));

	  for (var i = 0; i < handles.length; i++) {
	    var handle = handles[i];

	    if (typeof handle !== 'function') {
	      var type = toString.call(handle);
	      var msg = 'Route.all() requires callback functions but got a ' + type;
	      throw new TypeError(msg);
	    }

	    var layer = Layer('/', {}, handle);
	    layer.method = undefined;

	    this.methods._all = true;
	    this.stack.push(layer);
	  }

	  return this;
	};

	methods.forEach(function (method) {
	  Route.prototype[method] = function () {
	    var handles = flatten(slice.call(arguments));

	    for (var i = 0; i < handles.length; i++) {
	      var handle = handles[i];

	      if (typeof handle !== 'function') {
	        var type = toString.call(handle);
	        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;
	        throw new Error(msg);
	      }

	      debug('%s %s', method, this.path);

	      var layer = Layer('/', {}, handle);
	      layer.method = method;

	      this.methods[method] = true;
	      this.stack.push(layer);
	    }

	    return this;
	  };
	});

/***/ },
/* 208 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Expose `arrayFlatten`.
	 */

	module.exports = arrayFlatten;

	/**
	 * Recursive flatten function with depth.
	 *
	 * @param  {Array}  array
	 * @param  {Array}  result
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function flattenWithDepth(array, result, depth) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i];

	    if (depth > 0 && Array.isArray(value)) {
	      flattenWithDepth(value, result, depth - 1);
	    } else {
	      result.push(value);
	    }
	  }

	  return result;
	}

	/**
	 * Recursive flatten function. Omitting depth is slightly faster.
	 *
	 * @param  {Array} array
	 * @param  {Array} result
	 * @return {Array}
	 */
	function flattenForever(array, result) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i];

	    if (Array.isArray(value)) {
	      flattenForever(value, result);
	    } else {
	      result.push(value);
	    }
	  }

	  return result;
	}

	/**
	 * Flatten an array, with the ability to define a depth.
	 *
	 * @param  {Array}  array
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function arrayFlatten(array, depth) {
	  if (depth == null) {
	    return flattenForever(array, []);
	  }

	  return flattenWithDepth(array, [], depth);
	}

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var pathRegexp = __webpack_require__(210);
	var debug = __webpack_require__(197)('express:router:layer');

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Layer;

	function Layer(path, options, fn) {
	  if (!(this instanceof Layer)) {
	    return new Layer(path, options, fn);
	  }

	  debug('new %s', path);
	  var opts = options || {};

	  this.handle = fn;
	  this.name = fn.name || '<anonymous>';
	  this.params = undefined;
	  this.path = undefined;
	  this.regexp = pathRegexp(path, this.keys = [], opts);

	  if (path === '/' && opts.end === false) {
	    this.regexp.fast_slash = true;
	  }
	}

	/**
	 * Handle the error for the layer.
	 *
	 * @param {Error} error
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */

	Layer.prototype.handle_error = function handle_error(error, req, res, next) {
	  var fn = this.handle;

	  if (fn.length !== 4) {
	    // not a standard error handler
	    return next(error);
	  }

	  try {
	    fn(error, req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};

	/**
	 * Handle the request for the layer.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */

	Layer.prototype.handle_request = function handle(req, res, next) {
	  var fn = this.handle;

	  if (fn.length > 3) {
	    // not a standard request handler
	    return next();
	  }

	  try {
	    fn(req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};

	/**
	 * Check if this route matches `path`, if so
	 * populate `.params`.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */

	Layer.prototype.match = function match(path) {
	  if (path == null) {
	    // no path, nothing matches
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }

	  if (this.regexp.fast_slash) {
	    // fast path non-ending match for / (everything matches)
	    this.params = {};
	    this.path = '';
	    return true;
	  }

	  var m = this.regexp.exec(path);

	  if (!m) {
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }

	  // store values
	  this.params = {};
	  this.path = m[0];

	  var keys = this.keys;
	  var params = this.params;

	  for (var i = 1; i < m.length; i++) {
	    var key = keys[i - 1];
	    var prop = key.name;
	    var val = decode_param(m[i]);

	    if (val !== undefined || !hasOwnProperty.call(params, prop)) {
	      params[prop] = val;
	    }
	  }

	  return true;
	};

	/**
	 * Decode param value.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function decode_param(val) {
	  if (typeof val !== 'string' || val.length === 0) {
	    return val;
	  }

	  try {
	    return decodeURIComponent(val);
	  } catch (err) {
	    if (err instanceof URIError) {
	      err.message = 'Failed to decode param \'' + val + '\'';
	      err.status = err.statusCode = 400;
	    }

	    throw err;
	  }
	}

/***/ },
/* 210 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Expose `pathtoRegexp`.
	 */

	module.exports = pathtoRegexp;

	/**
	 * Match matching groups in a regular expression.
	 */
	var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

	/**
	 * Normalize the given path string,
	 * returning a regular expression.
	 *
	 * An empty array should be passed,
	 * which will contain the placeholder
	 * key names. For example "/user/:id" will
	 * then contain ["id"].
	 *
	 * @param  {String|RegExp|Array} path
	 * @param  {Array} keys
	 * @param  {Object} options
	 * @return {RegExp}
	 * @api private
	 */

	function pathtoRegexp(path, keys, options) {
	  options = options || {};
	  keys = keys || [];
	  var strict = options.strict;
	  var end = options.end !== false;
	  var flags = options.sensitive ? '' : 'i';
	  var extraOffset = 0;
	  var keysOffset = keys.length;
	  var i = 0;
	  var name = 0;
	  var m;

	  if (path instanceof RegExp) {
	    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
	      keys.push({
	        name: name++,
	        optional: false,
	        offset: m.index
	      });
	    }

	    return path;
	  }

	  if (Array.isArray(path)) {
	    // Map array parts into regexps and return their source. We also pass
	    // the same keys and options instance into every generation to get
	    // consistent matching groups before we join the sources together.
	    path = path.map(function (value) {
	      return pathtoRegexp(value, keys, options).source;
	    });

	    return new RegExp('(?:' + path.join('|') + ')', flags);
	  }

	  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?')).replace(/\/\(/g, '/(?:').replace(/([\/\.])/g, '\\$1').replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
	    slash = slash || '';
	    format = format || '';
	    capture = capture || '([^\\/' + format + ']+?)';
	    optional = optional || '';

	    keys.push({
	      name: key,
	      optional: !!optional,
	      offset: offset + extraOffset
	    });

	    var result = '' + (optional ? '' : slash) + '(?:' + format + (optional ? slash : '') + capture + (star ? '((?:[\\/' + format + '].+?)?)' : '') + ')' + optional;

	    extraOffset += result.length - match.length;

	    return result;
	  }).replace(/\*/g, function (star, index) {
	    var len = keys.length;

	    while (len-- > keysOffset && keys[len].offset > index) {
	      keys[len].offset += 3; // Replacement length minus asterisk length.
	    }

	    return '(.*)';
	  });

	  // This is a workaround for handling unnamed matching groups.
	  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
	    var escapeCount = 0;
	    var index = m.index;

	    while (path.charAt(--index) === '\\') {
	      escapeCount++;
	    }

	    // It's possible to escape the bracket.
	    if (escapeCount % 2 === 1) {
	      continue;
	    }

	    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
	      keys.splice(keysOffset + i, 0, {
	        name: name++, // Unnamed matching groups must be consistently linear.
	        optional: false,
	        offset: m.index
	      });
	    }

	    i++;
	  }

	  // If the path is non-ending, match until the end or a slash.
	  path += end ? '$' : path[path.length - 1] === '/' ? '' : '(?=\\/|$)';

	  return new RegExp(path, flags);
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * methods
	 * Copyright(c) 2013-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var http = __webpack_require__(212);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

	/**
	 * Get the current Node.js methods.
	 * @private
	 */

	function getCurrentNodeMethods() {
	  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
	    return method.toLowerCase();
	  });
	}

	/**
	 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	 * @private
	 */

	function getBasicNodeMethods() {
	  return ['get', 'post', 'put', 'head', 'delete', 'options', 'trace', 'copy', 'lock', 'mkcol', 'move', 'purge', 'propfind', 'proppatch', 'unlock', 'report', 'mkactivity', 'checkout', 'merge', 'm-search', 'notify', 'subscribe', 'unsubscribe', 'patch', 'search', 'connect'];
	}

/***/ },
/* 212 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 213 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Merge object b with object a.
	 *
	 *     var a = { foo: 'bar' }
	 *       , b = { bar: 'baz' };
	 *
	 *     merge(a, b);
	 *     // => { foo: 'bar', bar: 'baz' }
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object}
	 * @api public
	 */

	exports = module.exports = function (a, b) {
	  if (a && b) {
	    for (var key in b) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	/*!
	 * depd
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = depd;

	/**
	 * Create deprecate for namespace in caller.
	 */

	function depd(namespace) {
	  if (!namespace) {
	    throw new TypeError('argument namespace is required');
	  }

	  function deprecate(message) {
	    // no-op in browser
	  }

	  deprecate._file = undefined;
	  deprecate._ignored = true;
	  deprecate._namespace = namespace;
	  deprecate._traced = false;
	  deprecate._warned = Object.create(null);

	  deprecate.function = wrapfunction;
	  deprecate.property = wrapproperty;

	  return deprecate;
	}

	/**
	 * Return a wrapped function in a deprecation message.
	 *
	 * This is a no-op version of the wrapper, which does nothing but call
	 * validation.
	 */

	function wrapfunction(fn, message) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('argument fn must be a function');
	  }

	  return fn;
	}

	/**
	 * Wrap property in a deprecation message.
	 *
	 * This is a no-op version of the wrapper, which does nothing but call
	 * validation.
	 */

	function wrapproperty(obj, prop, message) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && typeof obj !== 'function') {
	    throw new TypeError('argument obj must be object');
	  }

	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

	  if (!descriptor) {
	    throw new TypeError('must call property on owner object');
	  }

	  if (!descriptor.configurable) {
	    throw new TypeError('property must be configurable');
	  }

	  return;
	}

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * parseurl
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var url = __webpack_require__(216);
	var parse = url.parse;
	var Url = url.Url;

	/**
	 * Pattern for a simple path case.
	 * See: https://github.com/joyent/node/pull/7878
	 */

	var simplePathRegExp = /^(\/\/?(?!\/)[^\?#\s]*)(\?[^#\s]*)?$/;

	/**
	 * Exports.
	 */

	module.exports = parseurl;
	module.exports.original = originalurl;

	/**
	 * Parse the `req` url with memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @api public
	 */

	function parseurl(req) {
	  var url = req.url;

	  if (url === undefined) {
	    // URL is undefined
	    return undefined;
	  }

	  var parsed = req._parsedUrl;

	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed;
	  }

	  // Parse the URL
	  parsed = fastparse(url);
	  parsed._raw = url;

	  return req._parsedUrl = parsed;
	};

	/**
	 * Parse the `req` original url with fallback and memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @api public
	 */

	function originalurl(req) {
	  var url = req.originalUrl;

	  if (typeof url !== 'string') {
	    // Fallback
	    return parseurl(req);
	  }

	  var parsed = req._parsedOriginalUrl;

	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed;
	  }

	  // Parse the URL
	  parsed = fastparse(url);
	  parsed._raw = url;

	  return req._parsedOriginalUrl = parsed;
	};

	/**
	 * Parse the `str` url with fast-path short-cut.
	 *
	 * @param {string} str
	 * @return {Object}
	 * @api private
	 */

	function fastparse(str) {
	  // Try fast path regexp
	  // See: https://github.com/joyent/node/pull/7878
	  var simplePath = typeof str === 'string' && simplePathRegExp.exec(str);

	  // Construct simple URL
	  if (simplePath) {
	    var pathname = simplePath[1];
	    var search = simplePath[2] || null;
	    var url = Url !== undefined ? new Url() : {};
	    url.path = str;
	    url.href = str;
	    url.pathname = pathname;
	    url.search = search;
	    url.query = search && search.substr(1);

	    return url;
	  }

	  return parse(str);
	}

	/**
	 * Determine if parsed is still fresh for url.
	 *
	 * @param {string} url
	 * @param {object} parsedUrl
	 * @return {boolean}
	 * @api private
	 */

	function fresh(url, parsedUrl) {
	  return (typeof parsedUrl === 'undefined' ? 'undefined' : _typeof(parsedUrl)) === 'object' && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url;
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(217);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,


	// RFC 2396: characters reserved for delimiting URLs.
	// We actually just auto-escape these.
	delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


	// RFC 2396: characters not allowed for various reasons.
	unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


	// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	autoEscape = ['\''].concat(unwise),

	// Characters that are never ever allowed in a hostname.
	// Note that any invalid chars are also handled, but these
	// are the ones that are *expected* to be seen, so we fast-path
	// them.
	nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,

	// protocols that can allow "unsafe" and "unwise" chars.
	unsafeProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that never have a hostname.
	hostlessProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that always contain a // bit.
	slashedProtocol = {
	  'http': true,
	  'https': true,
	  'ftp': true,
	  'gopher': true,
	  'file': true,
	  'http:': true,
	  'https:': true,
	  'ftp:': true,
	  'gopher:': true,
	  'file:': true
	},
	    querystring = __webpack_require__(220);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }

	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function () {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query && isObject(this.query) && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || query && '?' + query || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function (relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function (k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function (k) {
	      if (k !== 'protocol') result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function (k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift())) {}
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
	      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
	      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = relative.host || relative.host === '' ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === '';

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || result.host && srcPath.length;

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return arg == null;
	}

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function (root) {

		/** Detect free variables */
		var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
		var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
		var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
			root = freeGlobal;
		}

		/**
	  * The `punycode` object.
	  * @name punycode
	  * @type Object
	  */
		var punycode,


		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647,
		    // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		    tMin = 1,
		    tMax = 26,
		    skew = 38,
		    damp = 700,
		    initialBias = 72,
		    initialN = 128,
		    // 0x80
		delimiter = '-',
		    // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		    regexNonASCII = /[^\x20-\x7E]/,
		    // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
		    // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},


		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		    floor = Math.floor,
		    stringFromCharCode = String.fromCharCode,


		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
	  * A generic error utility function.
	  * @private
	  * @param {String} type The error type.
	  * @returns {Error} Throws a `RangeError` with the applicable error message.
	  */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
	  * A generic `Array#map` utility function.
	  * @private
	  * @param {Array} array The array to iterate over.
	  * @param {Function} callback The function that gets called for every array
	  * item.
	  * @returns {Array} A new array of values returned by the callback function.
	  */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
	  * A simple `Array#map`-like wrapper to work with domain name strings or email
	  * addresses.
	  * @private
	  * @param {String} domain The domain name or email address.
	  * @param {Function} callback The function that gets called for every
	  * character.
	  * @returns {Array} A new string of characters returned by the callback
	  * function.
	  */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
	  * Creates an array containing the numeric code points of each Unicode
	  * character in the string. While JavaScript uses UCS-2 internally,
	  * this function will convert a pair of surrogate halves (each of which
	  * UCS-2 exposes as separate characters) into a single code point,
	  * matching UTF-16.
	  * @see `punycode.ucs2.encode`
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode.ucs2
	  * @name decode
	  * @param {String} string The Unicode input string (UCS-2).
	  * @returns {Array} The new array of code points.
	  */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
	  * Creates a string based on an array of numeric code points.
	  * @see `punycode.ucs2.decode`
	  * @memberOf punycode.ucs2
	  * @name encode
	  * @param {Array} codePoints The array of numeric code points.
	  * @returns {String} The new Unicode string (UCS-2).
	  */
		function ucs2encode(array) {
			return map(array, function (value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
	  * Converts a basic code point into a digit/integer.
	  * @see `digitToBasic()`
	  * @private
	  * @param {Number} codePoint The basic numeric code point value.
	  * @returns {Number} The numeric value of a basic code point (for use in
	  * representing integers) in the range `0` to `base - 1`, or `base` if
	  * the code point does not represent a value.
	  */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
	  * Converts a digit/integer into a basic code point.
	  * @see `basicToDigit()`
	  * @private
	  * @param {Number} digit The numeric value of a basic code point.
	  * @returns {Number} The basic code point whose value (when used for
	  * representing integers) is `digit`, which needs to be in the range
	  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	  * used; else, the lowercase form is used. The behavior is undefined
	  * if `flag` is non-zero and `digit` has no uppercase form.
	  */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
	  * Bias adaptation function as per section 3.4 of RFC 3492.
	  * http://tools.ietf.org/html/rfc3492#section-3.4
	  * @private
	  */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
	  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	  * symbols.
	  * @memberOf punycode
	  * @param {String} input The Punycode string of ASCII-only symbols.
	  * @returns {String} The resulting string of Unicode symbols.
	  */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,

			/** Cached calculation results */
			baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;
				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
			}

			return ucs2encode(output);
		}

		/**
	  * Converts a string of Unicode symbols (e.g. a domain name label) to a
	  * Punycode string of ASCII-only symbols.
	  * @memberOf punycode
	  * @param {String} input The string of Unicode symbols.
	  * @returns {String} The resulting Punycode string of ASCII-only symbols.
	  */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],

			/** `inputLength` will hold the number of code points in `input`. */
			inputLength,

			/** Cached calculation results */
			handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base;; /* no condition */k += base) {
							t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;
			}
			return output.join('');
		}

		/**
	  * Converts a Punycode string representing a domain name or an email address
	  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	  * it doesn't matter if you call it on a string that has already been
	  * converted to Unicode.
	  * @memberOf punycode
	  * @param {String} input The Punycoded domain name or email address to
	  * convert to Unicode.
	  * @returns {String} The Unicode representation of the given Punycode
	  * string.
	  */
		function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		}

		/**
	  * Converts a Unicode string representing a domain name or an email address to
	  * Punycode. Only the non-ASCII parts of the domain name will be converted,
	  * i.e. it doesn't matter if you call it with a domain that's already in
	  * ASCII.
	  * @memberOf punycode
	  * @param {String} input The domain name or email address to convert, as a
	  * Unicode string.
	  * @returns {String} The Punycode representation of the given domain name or
	  * email address.
	  */
		function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
	   * A string representing the current Punycode.js version number.
	   * @memberOf punycode
	   * @type String
	   */
			'version': '1.3.2',
			/**
	   * An object of methods to convert from JavaScript's internal character
	   * representation (UCS-2) to Unicode code points, and back.
	   * @see <https://mathiasbynens.be/notes/javascript-encoding>
	   * @memberOf punycode
	   * @type Object
	   */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if ("function" == 'function' && _typeof(__webpack_require__(219)) == 'object' && __webpack_require__(219)) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(218)(module), (function() { return this; }())))

/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 219 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(221);
	exports.encode = exports.stringify = __webpack_require__(222);

/***/ },
/* 221 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function (qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr,
	        vstr,
	        k,
	        v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};

/***/ },
/* 222 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return Object.keys(obj).map(function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};

/***/ },
/* 223 */
/***/ function(module, exports) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Initialization middleware, exposing the
	 * request and response to each other, as well
	 * as defaulting the X-Powered-By header field.
	 *
	 * @param {Function} app
	 * @return {Function}
	 * @api private
	 */

	exports.init = function (app) {
	  return function expressInit(req, res, next) {
	    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
	    req.res = res;
	    res.req = req;
	    req.next = next;

	    req.__proto__ = app.request;
	    res.__proto__ = app.response;

	    res.locals = res.locals || Object.create(null);

	    next();
	  };
	};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var parseUrl = __webpack_require__(215);
	var qs = __webpack_require__(225);

	/**
	 * @param {Object} options
	 * @return {Function}
	 * @api public
	 */

	module.exports = function query(options) {
	  var opts = Object.create(options || null);
	  var queryparse = qs.parse;

	  if (typeof options === 'function') {
	    queryparse = options;
	    opts = undefined;
	  }

	  if (opts !== undefined && opts.allowPrototypes === undefined) {
	    // back-compat for qs module
	    opts.allowPrototypes = true;
	  }

	  return function query(req, res, next) {
	    if (!req.query) {
	      var val = parseUrl(req).query;
	      req.query = queryparse(val, opts);
	    }

	    next();
	  };
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stringify = __webpack_require__(226);
	var Parse = __webpack_require__(228);

	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Utils = __webpack_require__(227);

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var defaults = {
	    delimiter: '&',
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true,
	    encoder: Utils.encode
	};

	var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encoder ? encoder(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
	        if (encoder) {
	            return [encoder(prefix) + '=' + encoder(obj)];
	        }
	        return [prefix + '=' + String(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        } else {
	            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        }
	    }

	    return values;
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = encode ? typeof options.encoder === 'function' ? options.encoder : defaults.encoder : null;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;

	    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	    }

	    return keys.join(delimiter);
	};

/***/ },
/* 227 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var hexTable = function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }

	    return array;
	}();

	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (c === 0x2D || // -
	        c === 0x2E || // .
	        c === 0x5F || // _
	        c === 0x7E || // ~
	        c >= 0x30 && c <= 0x39 || // 0-9
	        c >= 0x41 && c <= 0x5A || // a-z
	        c >= 0x61 && c <= 0x7A // A-Z
	        ) {
	                out += string.charAt(i);
	                continue;
	            }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
	        out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
	    }

	    return out;
	};

	exports.compact = function (obj, references) {
	    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	        return obj;
	    }

	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0; i < obj.length; ++i) {
	            if (obj[i] && _typeof(obj[i]) === 'object') {
	                compacted.push(exports.compact(obj[i], refs));
	            } else if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};

	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(227);

	var defaults = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false,
	    decoder: Utils.decode
	};

	var parseValues = function parseValues(str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[options.decoder(part)] = '';

	            if (options.strictNullHandling) {
	                obj[options.decoder(part)] = null;
	            }
	        } else {
	            var key = options.decoder(part.slice(0, pos));
	            var val = options.decoder(part.slice(pos + 1));

	            if (Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = [].concat(obj[key]).concat(val);
	            } else {
	                obj[key] = val;
	            }
	        }
	    }

	    return obj;
	};

	var parseObject = function parseObject(chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
	            obj = [];
	            obj[index] = parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};

	var parseKeys = function parseKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options);
	};

	module.exports = function (str, opts) {
	    var options = opts || {};

	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }

	    return Utils.compact(obj);
	};

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = __webpack_require__(197)('express:view');
	var path = __webpack_require__(230);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var utils = __webpack_require__(231);

	/**
	 * Module variables.
	 * @private
	 */

	var dirname = path.dirname;
	var basename = path.basename;
	var extname = path.extname;
	var join = path.join;
	var resolve = path.resolve;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = View;

	/**
	 * Initialize a new `View` with the given `name`.
	 *
	 * Options:
	 *
	 *   - `defaultEngine` the default template engine name
	 *   - `engines` template engine require() cache
	 *   - `root` root path for view lookup
	 *
	 * @param {string} name
	 * @param {object} options
	 * @public
	 */

	function View(name, options) {
	  var opts = options || {};

	  this.defaultEngine = opts.defaultEngine;
	  this.ext = extname(name);
	  this.name = name;
	  this.root = opts.root;

	  if (!this.ext && !this.defaultEngine) {
	    throw new Error('No default engine was specified and no extension was provided.');
	  }

	  var fileName = name;

	  if (!this.ext) {
	    // get extension from default engine name
	    this.ext = this.defaultEngine[0] !== '.' ? '.' + this.defaultEngine : this.defaultEngine;

	    fileName += this.ext;
	  }

	  if (!opts.engines[this.ext]) {
	    // load engine
	    opts.engines[this.ext] = __webpack_require__(280)(this.ext.substr(1)).__express;
	  }

	  // store loaded engine
	  this.engine = opts.engines[this.ext];

	  // lookup path
	  this.path = this.lookup(fileName);
	}

	/**
	 * Lookup view by the given `name`
	 *
	 * @param {string} name
	 * @private
	 */

	View.prototype.lookup = function lookup(name) {
	  var path;
	  var roots = [].concat(this.root);

	  debug('lookup "%s"', name);

	  for (var i = 0; i < roots.length && !path; i++) {
	    var root = roots[i];

	    // resolve the path
	    var loc = resolve(root, name);
	    var dir = dirname(loc);
	    var file = basename(loc);

	    // resolve the file
	    path = this.resolve(dir, file);
	  }

	  return path;
	};

	/**
	 * Render with the given options.
	 *
	 * @param {object} options
	 * @param {function} callback
	 * @private
	 */

	View.prototype.render = function render(options, callback) {
	  debug('render "%s"', this.path);
	  this.engine(this.path, options, callback);
	};

	/**
	 * Resolve the file within the given directory.
	 *
	 * @param {string} dir
	 * @param {string} file
	 * @private
	 */

	View.prototype.resolve = function resolve(dir, file) {
	  var ext = this.ext;

	  // <path>.<ext>
	  var path = join(dir, file);
	  var stat = tryStat(path);

	  if (stat && stat.isFile()) {
	    return path;
	  }

	  // <path>/index.<ext>
	  path = join(dir, basename(file, ext), 'index' + ext);
	  stat = tryStat(path);

	  if (stat && stat.isFile()) {
	    return path;
	  }
	};

	/**
	 * Return a stat, maybe.
	 *
	 * @param {string} path
	 * @return {fs.Stats}
	 * @private
	 */

	function tryStat(path) {
	  debug('stat "%s"', path);

	  try {
	    return fs.statSync(path);
	  } catch (e) {
	    return undefined;
	  }
	}

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function splitPath(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function () {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = i >= 0 ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function (path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function (p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function (path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function () {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function (p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};

	// path.relative(from, to)
	// posix version
	exports.relative = function (from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function (path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};

	exports.basename = function (path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};

	exports.extname = function (path) {
	  return splitPath(path)[3];
	};

	function filter(xs, f) {
	  if (xs.filter) return xs.filter(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    if (f(xs[i], i, xs)) res.push(xs[i]);
	  }
	  return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
	  return str.substr(start, len);
	} : function (str, start, len) {
	  if (start < 0) start = str.length + start;
	  return str.substr(start, len);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @api private
	 */

	var contentDisposition = __webpack_require__(232);
	var contentType = __webpack_require__(233);
	var deprecate = __webpack_require__(214)('express');
	var flatten = __webpack_require__(208);
	var mime = __webpack_require__(234).mime;
	var basename = __webpack_require__(230).basename;
	var etag = __webpack_require__(255);
	var proxyaddr = __webpack_require__(277);
	var qs = __webpack_require__(225);
	var querystring = __webpack_require__(220);

	/**
	 * Return strong ETag for `body`.
	 *
	 * @param {String|Buffer} body
	 * @param {String} [encoding]
	 * @return {String}
	 * @api private
	 */

	exports.etag = function (body, encoding) {
	  var buf = !Buffer.isBuffer(body) ? new Buffer(body, encoding) : body;

	  return etag(buf, { weak: false });
	};

	/**
	 * Return weak ETag for `body`.
	 *
	 * @param {String|Buffer} body
	 * @param {String} [encoding]
	 * @return {String}
	 * @api private
	 */

	exports.wetag = function wetag(body, encoding) {
	  var buf = !Buffer.isBuffer(body) ? new Buffer(body, encoding) : body;

	  return etag(buf, { weak: true });
	};

	/**
	 * Check if `path` looks absolute.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */

	exports.isAbsolute = function (path) {
	  if ('/' === path[0]) return true;
	  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
	  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
	};

	/**
	 * Flatten the given `arr`.
	 *
	 * @param {Array} arr
	 * @return {Array}
	 * @api private
	 */

	exports.flatten = deprecate.function(flatten, 'utils.flatten: use array-flatten npm module instead');

	/**
	 * Normalize the given `type`, for example "html" becomes "text/html".
	 *
	 * @param {String} type
	 * @return {Object}
	 * @api private
	 */

	exports.normalizeType = function (type) {
	  return ~type.indexOf('/') ? acceptParams(type) : { value: mime.lookup(type), params: {} };
	};

	/**
	 * Normalize `types`, for example "html" becomes "text/html".
	 *
	 * @param {Array} types
	 * @return {Array}
	 * @api private
	 */

	exports.normalizeTypes = function (types) {
	  var ret = [];

	  for (var i = 0; i < types.length; ++i) {
	    ret.push(exports.normalizeType(types[i]));
	  }

	  return ret;
	};

	/**
	 * Generate Content-Disposition header appropriate for the filename.
	 * non-ascii filenames are urlencoded and a filename* parameter is added
	 *
	 * @param {String} filename
	 * @return {String}
	 * @api private
	 */

	exports.contentDisposition = deprecate.function(contentDisposition, 'utils.contentDisposition: use content-disposition npm module instead');

	/**
	 * Parse accept params `str` returning an
	 * object with `.value`, `.quality` and `.params`.
	 * also includes `.originalIndex` for stable sorting
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */

	function acceptParams(str, index) {
	  var parts = str.split(/ *; */);
	  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

	  for (var i = 1; i < parts.length; ++i) {
	    var pms = parts[i].split(/ *= */);
	    if ('q' === pms[0]) {
	      ret.quality = parseFloat(pms[1]);
	    } else {
	      ret.params[pms[0]] = pms[1];
	    }
	  }

	  return ret;
	}

	/**
	 * Compile "etag" value to function.
	 *
	 * @param  {Boolean|String|Function} val
	 * @return {Function}
	 * @api private
	 */

	exports.compileETag = function (val) {
	  var fn;

	  if (typeof val === 'function') {
	    return val;
	  }

	  switch (val) {
	    case true:
	      fn = exports.wetag;
	      break;
	    case false:
	      break;
	    case 'strong':
	      fn = exports.etag;
	      break;
	    case 'weak':
	      fn = exports.wetag;
	      break;
	    default:
	      throw new TypeError('unknown value for etag function: ' + val);
	  }

	  return fn;
	};

	/**
	 * Compile "query parser" value to function.
	 *
	 * @param  {String|Function} val
	 * @return {Function}
	 * @api private
	 */

	exports.compileQueryParser = function compileQueryParser(val) {
	  var fn;

	  if (typeof val === 'function') {
	    return val;
	  }

	  switch (val) {
	    case true:
	      fn = querystring.parse;
	      break;
	    case false:
	      fn = newObject;
	      break;
	    case 'extended':
	      fn = parseExtendedQueryString;
	      break;
	    case 'simple':
	      fn = querystring.parse;
	      break;
	    default:
	      throw new TypeError('unknown value for query parser function: ' + val);
	  }

	  return fn;
	};

	/**
	 * Compile "proxy trust" value to function.
	 *
	 * @param  {Boolean|String|Number|Array|Function} val
	 * @return {Function}
	 * @api private
	 */

	exports.compileTrust = function (val) {
	  if (typeof val === 'function') return val;

	  if (val === true) {
	    // Support plain true/false
	    return function () {
	      return true;
	    };
	  }

	  if (typeof val === 'number') {
	    // Support trusting hop count
	    return function (a, i) {
	      return i < val;
	    };
	  }

	  if (typeof val === 'string') {
	    // Support comma-separated values
	    val = val.split(/ *, */);
	  }

	  return proxyaddr.compile(val || []);
	};

	/**
	 * Set the charset in a given Content-Type string.
	 *
	 * @param {String} type
	 * @param {String} charset
	 * @return {String}
	 * @api private
	 */

	exports.setCharset = function setCharset(type, charset) {
	  if (!type || !charset) {
	    return type;
	  }

	  // parse type
	  var parsed = contentType.parse(type);

	  // set charset
	  parsed.parameters.charset = charset;

	  // format type
	  return contentType.format(parsed);
	};

	/**
	 * Parse an extended query string with qs.
	 *
	 * @return {Object}
	 * @private
	 */

	function parseExtendedQueryString(str) {
	  return qs.parse(str, {
	    allowPrototypes: true
	  });
	}

	/**
	 * Return new empty object.
	 *
	 * @return {Object}
	 * @api private
	 */

	function newObject() {
	  return {};
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * content-disposition
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = contentDisposition;
	module.exports.parse = parse;

	/**
	 * Module dependencies.
	 */

	var basename = __webpack_require__(230).basename;

	/**
	 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	 */

	var encodeUriAttrCharRegExp = /[\x00-\x20"'\(\)*,\/:;<=>?@\[\\\]\{\}\x7f]/g;

	/**
	 * RegExp to match percent encoding escape.
	 */

	var hexEscapeRegExp = /%[0-9A-Fa-f]{2}/;
	var hexEscapeReplaceRegExp = /%([0-9A-Fa-f]{2})/g;

	/**
	 * RegExp to match non-latin1 characters.
	 */

	var nonLatin1RegExp = /[^\x20-\x7e\xa0-\xff]/g;

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */

	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */

	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp for various RFC 2616 grammar
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * HT            = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */

	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\x20-\x7e\x80-\xff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

	/**
	 * RegExp for various RFC 5987 grammar
	 *
	 * ext-value     = charset  "'" [ language ] "'" value-chars
	 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	 * mime-charset  = 1*mime-charsetc
	 * mime-charsetc = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "%" / "&"
	 *               / "+" / "-" / "^" / "_" / "`"
	 *               / "{" / "}" / "~"
	 * language      = ( 2*3ALPHA [ extlang ] )
	 *               / 4ALPHA
	 *               / 5*8ALPHA
	 * extlang       = *3( "-" 3ALPHA )
	 * value-chars   = *( pct-encoded / attr-char )
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * attr-char     = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	 *               / "^" / "_" / "`" / "|" / "~"
	 */

	var extValueRegExp = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+\-\.^_`|~])+)$/;

	/**
	 * RegExp for various RFC 6266 grammar
	 *
	 * disposition-type = "inline" | "attachment" | disp-ext-type
	 * disp-ext-type    = token
	 * disposition-parm = filename-parm | disp-ext-parm
	 * filename-parm    = "filename" "=" value
	 *                  | "filename*" "=" ext-value
	 * disp-ext-parm    = token "=" value
	 *                  | ext-token "=" ext-value
	 * ext-token        = <the characters in token, followed by "*">
	 */

	var dispositionTypeRegExp = /^([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *(?:$|;)/;

	/**
	 * Create an attachment Content-Disposition header.
	 *
	 * @param {string} [filename]
	 * @param {object} [options]
	 * @param {string} [options.type=attachment]
	 * @param {string|boolean} [options.fallback=true]
	 * @return {string}
	 * @api public
	 */

	function contentDisposition(filename, options) {
	  var opts = options || {};

	  // get type
	  var type = opts.type || 'attachment';

	  // get parameters
	  var params = createparams(filename, opts.fallback);

	  // format into string
	  return format(new ContentDisposition(type, params));
	}

	/**
	 * Create parameters object from filename and fallback.
	 *
	 * @param {string} [filename]
	 * @param {string|boolean} [fallback=true]
	 * @return {object}
	 * @api private
	 */

	function createparams(filename, fallback) {
	  if (filename === undefined) {
	    return;
	  }

	  var params = {};

	  if (typeof filename !== 'string') {
	    throw new TypeError('filename must be a string');
	  }

	  // fallback defaults to true
	  if (fallback === undefined) {
	    fallback = true;
	  }

	  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
	    throw new TypeError('fallback must be a string or boolean');
	  }

	  if (typeof fallback === 'string' && nonLatin1RegExp.test(fallback)) {
	    throw new TypeError('fallback must be ISO-8859-1 string');
	  }

	  // restrict to file base name
	  var name = basename(filename);

	  // determine if name is suitable for quoted string
	  var isQuotedString = textRegExp.test(name);

	  // generate fallback name
	  var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename(fallback);
	  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

	  // set extended filename parameter
	  if (hasFallback || !isQuotedString || hexEscapeRegExp.test(name)) {
	    params['filename*'] = name;
	  }

	  // set filename parameter
	  if (isQuotedString || hasFallback) {
	    params.filename = hasFallback ? fallbackName : name;
	  }

	  return params;
	}

	/**
	 * Format object to Content-Disposition header.
	 *
	 * @param {object} obj
	 * @param {string} obj.type
	 * @param {object} [obj.parameters]
	 * @return {string}
	 * @api private
	 */

	function format(obj) {
	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || typeof type !== 'string' || !tokenRegExp.test(type)) {
	    throw new TypeError('invalid type');
	  }

	  // start with normalized type
	  var string = String(type).toLowerCase();

	  // append parameters
	  if (parameters && (typeof parameters === 'undefined' ? 'undefined' : _typeof(parameters)) === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      var val = param.substr(-1) === '*' ? ustring(parameters[param]) : qstring(parameters[param]);

	      string += '; ' + param + '=' + val;
	    }
	  }

	  return string;
	}

	/**
	 * Decode a RFC 6987 field value (gracefully).
	 *
	 * @param {string} str
	 * @return {string}
	 * @api private
	 */

	function decodefield(str) {
	  var match = extValueRegExp.exec(str);

	  if (!match) {
	    throw new TypeError('invalid extended field value');
	  }

	  var charset = match[1].toLowerCase();
	  var encoded = match[2];
	  var value;

	  // to binary string
	  var binary = encoded.replace(hexEscapeReplaceRegExp, pdecode);

	  switch (charset) {
	    case 'iso-8859-1':
	      value = getlatin1(binary);
	      break;
	    case 'utf-8':
	      value = new Buffer(binary, 'binary').toString('utf8');
	      break;
	    default:
	      throw new TypeError('unsupported charset in extended field');
	  }

	  return value;
	}

	/**
	 * Get ISO-8859-1 version of string.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function getlatin1(val) {
	  // simple Unicode -> ISO-8859-1 transformation
	  return String(val).replace(nonLatin1RegExp, '?');
	}

	/**
	 * Parse Content-Disposition header string.
	 *
	 * @param {string} string
	 * @return {object}
	 * @api private
	 */

	function parse(string) {
	  if (!string || typeof string !== 'string') {
	    throw new TypeError('argument string is required');
	  }

	  var match = dispositionTypeRegExp.exec(string);

	  if (!match) {
	    throw new TypeError('invalid type format');
	  }

	  // normalize type
	  var index = match[0].length;
	  var type = match[1].toLowerCase();

	  var key;
	  var names = [];
	  var params = {};
	  var value;

	  // calculate index to start at
	  index = paramRegExp.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index;

	  // match parameters
	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format');
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (names.indexOf(key) !== -1) {
	      throw new TypeError('invalid duplicate parameter');
	    }

	    names.push(key);

	    if (key.indexOf('*') + 1 === key.length) {
	      // decode extended value
	      key = key.slice(0, -1);
	      value = decodefield(value);

	      // overwrite existing value
	      params[key] = value;
	      continue;
	    }

	    if (typeof params[key] === 'string') {
	      continue;
	    }

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
	    }

	    params[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format');
	  }

	  return new ContentDisposition(type, params);
	}

	/**
	 * Percent decode a single character.
	 *
	 * @param {string} str
	 * @param {string} hex
	 * @return {string}
	 * @api private
	 */

	function pdecode(str, hex) {
	  return String.fromCharCode(parseInt(hex, 16));
	}

	/**
	 * Percent encode a single character.
	 *
	 * @param {string} char
	 * @return {string}
	 * @api private
	 */

	function pencode(char) {
	  var hex = String(char).charCodeAt(0).toString(16).toUpperCase();
	  return hex.length === 1 ? '%0' + hex : '%' + hex;
	}

	/**
	 * Quote a string for HTTP.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val);

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"';
	}

	/**
	 * Encode a Unicode string for HTTP (RFC 5987).
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function ustring(val) {
	  var str = String(val);

	  // percent encode as UTF-8
	  var encoded = encodeURIComponent(str).replace(encodeUriAttrCharRegExp, pencode);

	  return 'UTF-8\'\'' + encoded;
	}

	/**
	 * Class for parsed Content-Disposition header for v8 optimization
	 */

	function ContentDisposition(type, parameters) {
	  this.type = type;
	  this.parameters = parameters;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 233 */
/***/ function(module, exports) {

	/*!
	 * content-type
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	 *
	 * parameter     = token "=" ( token / quoted-string )
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	 * obs-text      = %x80-FF
	 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var paramRegExp = /; *([!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) */g;
	var textRegExp = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/;

	/**
	 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	 *
	 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	 * obs-text    = %x80-FF
	 */
	var qescRegExp = /\\([\u000b\u0020-\u00ff])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * media-type = type "/" subtype
	 * type       = token
	 * subtype    = token
	 */
	var typeRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+\/[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/;

	/**
	 * Module exports.
	 * @public
	 */

	exports.format = format;
	exports.parse = parse;

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @public
	 */

	function format(obj) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
	    throw new TypeError('argument obj is required');
	  }

	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || !typeRegExp.test(type)) {
	    throw new TypeError('invalid type');
	  }

	  var string = type;

	  // append parameters
	  if (parameters && (typeof parameters === 'undefined' ? 'undefined' : _typeof(parameters)) === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name');
	      }

	      string += '; ' + param + '=' + qstring(parameters[param]);
	    }
	  }

	  return string;
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required');
	  }

	  if ((typeof string === 'undefined' ? 'undefined' : _typeof(string)) === 'object') {
	    // support req/res-like objects as argument
	    string = getcontenttype(string);

	    if (typeof string !== 'string') {
	      throw new TypeError('content-type header is missing from object');
	    }
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string');
	  }

	  var index = string.indexOf(';');
	  var type = index !== -1 ? string.substr(0, index).trim() : string.trim();

	  if (!typeRegExp.test(type)) {
	    throw new TypeError('invalid media type');
	  }

	  var key;
	  var match;
	  var obj = new ContentType(type.toLowerCase());
	  var value;

	  paramRegExp.lastIndex = index;

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format');
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
	    }

	    obj.parameters[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format');
	  }

	  return obj;
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type');
	  }

	  if (_typeof(obj.headers) === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type'];
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring(val) {
	  var str = String(val);

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str;
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value');
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"';
	}

	/**
	 * Class to represent a content type.
	 * @private
	 */
	function ContentType(type) {
	  this.parameters = Object.create(null);
	  this.type = type;
	}

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * send
	 * Copyright(c) 2012 TJ Holowaychuk
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var createError = __webpack_require__(235);
	var debug = __webpack_require__(197)('send');
	var deprecate = __webpack_require__(214)('send');
	var destroy = __webpack_require__(238);
	var encodeUrl = __webpack_require__(254);
	var escapeHtml = __webpack_require__(200);
	var etag = __webpack_require__(255);
	var EventEmitter = __webpack_require__(188).EventEmitter;
	var fresh = __webpack_require__(273);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var mime = __webpack_require__(274);
	var ms = __webpack_require__(199);
	var onFinished = __webpack_require__(201);
	var parseRange = __webpack_require__(276);
	var path = __webpack_require__(230);
	var statuses = __webpack_require__(203);
	var Stream = __webpack_require__(239);
	var util = __webpack_require__(263);

	/**
	 * Path function references.
	 * @private
	 */

	var extname = path.extname;
	var join = path.join;
	var normalize = path.normalize;
	var resolve = path.resolve;
	var sep = path.sep;

	/**
	 * Regular expression for identifying a bytes Range header.
	 * @private
	 */

	var BYTES_RANGE_REGEXP = /^ *bytes=/;

	/**
	 * Maximum value allowed for the max age.
	 * @private
	 */

	var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year

	/**
	 * Regular expression to match a path with a directory up component.
	 * @private
	 */

	var UP_PATH_REGEXP = /(?:^|[\\\/])\.\.(?:[\\\/]|$)/;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = send;
	module.exports.mime = mime;

	/**
	 * Shim EventEmitter.listenerCount for node.js < 0.10
	 */

	/* istanbul ignore next */
	var listenerCount = EventEmitter.listenerCount || function (emitter, type) {
	  return emitter.listeners(type).length;
	};

	/**
	 * Return a `SendStream` for `req` and `path`.
	 *
	 * @param {object} req
	 * @param {string} path
	 * @param {object} [options]
	 * @return {SendStream}
	 * @public
	 */

	function send(req, path, options) {
	  return new SendStream(req, path, options);
	}

	/**
	 * Initialize a `SendStream` with the given `path`.
	 *
	 * @param {Request} req
	 * @param {String} path
	 * @param {object} [options]
	 * @private
	 */

	function SendStream(req, path, options) {
	  Stream.call(this);

	  var opts = options || {};

	  this.options = opts;
	  this.path = path;
	  this.req = req;

	  this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;

	  this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;

	  this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;

	  this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : 'ignore';

	  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
	    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
	  }

	  this._hidden = Boolean(opts.hidden);

	  if (opts.hidden !== undefined) {
	    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead');
	  }

	  // legacy support
	  if (opts.dotfiles === undefined) {
	    this._dotfiles = undefined;
	  }

	  this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, 'extensions option') : [];

	  this._index = opts.index !== undefined ? normalizeList(opts.index, 'index option') : ['index.html'];

	  this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;

	  this._maxage = opts.maxAge || opts.maxage;
	  this._maxage = typeof this._maxage === 'string' ? ms(this._maxage) : Number(this._maxage);
	  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;

	  this._root = opts.root ? resolve(opts.root) : null;

	  if (!this._root && opts.from) {
	    this.from(opts.from);
	  }
	}

	/**
	 * Inherits from `Stream`.
	 */

	util.inherits(SendStream, Stream);

	/**
	 * Enable or disable etag generation.
	 *
	 * @param {Boolean} val
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.etag = deprecate.function(function etag(val) {
	  this._etag = Boolean(val);
	  debug('etag %s', this._etag);
	  return this;
	}, 'send.etag: pass etag as option');

	/**
	 * Enable or disable "hidden" (dot) files.
	 *
	 * @param {Boolean} path
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.hidden = deprecate.function(function hidden(val) {
	  this._hidden = Boolean(val);
	  this._dotfiles = undefined;
	  debug('hidden %s', this._hidden);
	  return this;
	}, 'send.hidden: use dotfiles option');

	/**
	 * Set index `paths`, set to a falsy
	 * value to disable index support.
	 *
	 * @param {String|Boolean|Array} paths
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.index = deprecate.function(function index(paths) {
	  var index = !paths ? [] : normalizeList(paths, 'paths argument');
	  debug('index %o', paths);
	  this._index = index;
	  return this;
	}, 'send.index: pass index as option');

	/**
	 * Set root `path`.
	 *
	 * @param {String} path
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.root = function root(path) {
	  this._root = resolve(String(path));
	  debug('root %s', this._root);
	  return this;
	};

	SendStream.prototype.from = deprecate.function(SendStream.prototype.root, 'send.from: pass root as option');

	SendStream.prototype.root = deprecate.function(SendStream.prototype.root, 'send.root: pass root as option');

	/**
	 * Set max-age to `maxAge`.
	 *
	 * @param {Number} maxAge
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
	  this._maxage = typeof maxAge === 'string' ? ms(maxAge) : Number(maxAge);
	  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
	  debug('max-age %d', this._maxage);
	  return this;
	}, 'send.maxage: pass maxAge as option');

	/**
	 * Emit error with `status`.
	 *
	 * @param {number} status
	 * @param {Error} [error]
	 * @private
	 */

	SendStream.prototype.error = function error(status, error) {
	  // emit if listeners instead of responding
	  if (listenerCount(this, 'error') !== 0) {
	    return this.emit('error', createError(error, status, {
	      expose: false
	    }));
	  }

	  var res = this.res;
	  var msg = statuses[status];

	  // clear existing headers
	  clearHeaders(res);

	  // add error headers
	  if (error && error.headers) {
	    setHeaders(res, error.headers);
	  }

	  // send basic response
	  res.statusCode = status;
	  res.setHeader('Content-Type', 'text/plain; charset=UTF-8');
	  res.setHeader('Content-Length', Buffer.byteLength(msg));
	  res.setHeader('X-Content-Type-Options', 'nosniff');
	  res.end(msg);
	};

	/**
	 * Check if the pathname ends with "/".
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
	  return this.path[this.path.length - 1] === '/';
	};

	/**
	 * Check if this is a conditional GET request.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isConditionalGET = function isConditionalGET() {
	  return this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
	};

	/**
	 * Strip content-* header fields.
	 *
	 * @private
	 */

	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
	  var res = this.res;
	  var headers = Object.keys(res._headers || {});

	  for (var i = 0; i < headers.length; i++) {
	    var header = headers[i];
	    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
	      res.removeHeader(header);
	    }
	  }
	};

	/**
	 * Respond with 304 not modified.
	 *
	 * @api private
	 */

	SendStream.prototype.notModified = function notModified() {
	  var res = this.res;
	  debug('not modified');
	  this.removeContentHeaderFields();
	  res.statusCode = 304;
	  res.end();
	};

	/**
	 * Raise error that headers already sent.
	 *
	 * @api private
	 */

	SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
	  var err = new Error('Can\'t set headers after they are sent.');
	  debug('headers already sent');
	  this.error(500, err);
	};

	/**
	 * Check if the request is cacheable, aka
	 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isCachable = function isCachable() {
	  var statusCode = this.res.statusCode;
	  return statusCode >= 200 && statusCode < 300 || statusCode === 304;
	};

	/**
	 * Handle stat() error.
	 *
	 * @param {Error} error
	 * @private
	 */

	SendStream.prototype.onStatError = function onStatError(error) {
	  switch (error.code) {
	    case 'ENAMETOOLONG':
	    case 'ENOENT':
	    case 'ENOTDIR':
	      this.error(404, error);
	      break;
	    default:
	      this.error(500, error);
	      break;
	  }
	};

	/**
	 * Check if the cache is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isFresh = function isFresh() {
	  return fresh(this.req.headers, this.res._headers);
	};

	/**
	 * Check if the range is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isRangeFresh = function isRangeFresh() {
	  var ifRange = this.req.headers['if-range'];

	  if (!ifRange) {
	    return true;
	  }

	  return ~ifRange.indexOf('"') ? ~ifRange.indexOf(this.res._headers['etag']) : Date.parse(this.res._headers['last-modified']) <= Date.parse(ifRange);
	};

	/**
	 * Redirect to path.
	 *
	 * @param {string} path
	 * @private
	 */

	SendStream.prototype.redirect = function redirect(path) {
	  if (listenerCount(this, 'directory') !== 0) {
	    this.emit('directory');
	    return;
	  }

	  if (this.hasTrailingSlash()) {
	    this.error(403);
	    return;
	  }

	  var loc = encodeUrl(collapseLeadingSlashes(path + '/'));
	  var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n';
	  var res = this.res;

	  // redirect
	  res.statusCode = 301;
	  res.setHeader('Content-Type', 'text/html; charset=UTF-8');
	  res.setHeader('Content-Length', Buffer.byteLength(msg));
	  res.setHeader('X-Content-Type-Options', 'nosniff');
	  res.setHeader('Location', loc);
	  res.end(msg);
	};

	/**
	 * Pipe to `res.
	 *
	 * @param {Stream} res
	 * @return {Stream} res
	 * @api public
	 */

	SendStream.prototype.pipe = function pipe(res) {
	  // root path
	  var root = this._root;

	  // references
	  this.res = res;

	  // decode the path
	  var path = decode(this.path);
	  if (path === -1) {
	    this.error(400);
	    return res;
	  }

	  // null byte(s)
	  if (~path.indexOf('\0')) {
	    this.error(400);
	    return res;
	  }

	  var parts;
	  if (root !== null) {
	    // malicious path
	    if (UP_PATH_REGEXP.test(normalize('.' + sep + path))) {
	      debug('malicious path "%s"', path);
	      this.error(403);
	      return res;
	    }

	    // join / normalize from optional root dir
	    path = normalize(join(root, path));
	    root = normalize(root + sep);

	    // explode path parts
	    parts = path.substr(root.length).split(sep);
	  } else {
	    // ".." is malicious without "root"
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      this.error(403);
	      return res;
	    }

	    // explode path parts
	    parts = normalize(path).split(sep);

	    // resolve the path
	    path = resolve(path);
	  }

	  // dotfile handling
	  if (containsDotFile(parts)) {
	    var access = this._dotfiles;

	    // legacy support
	    if (access === undefined) {
	      access = parts[parts.length - 1][0] === '.' ? this._hidden ? 'allow' : 'ignore' : 'allow';
	    }

	    debug('%s dotfile "%s"', access, path);
	    switch (access) {
	      case 'allow':
	        break;
	      case 'deny':
	        this.error(403);
	        return res;
	      case 'ignore':
	      default:
	        this.error(404);
	        return res;
	    }
	  }

	  // index file support
	  if (this._index.length && this.path[this.path.length - 1] === '/') {
	    this.sendIndex(path);
	    return res;
	  }

	  this.sendFile(path);
	  return res;
	};

	/**
	 * Transfer `path`.
	 *
	 * @param {String} path
	 * @api public
	 */

	SendStream.prototype.send = function send(path, stat) {
	  var len = stat.size;
	  var options = this.options;
	  var opts = {};
	  var res = this.res;
	  var req = this.req;
	  var ranges = req.headers.range;
	  var offset = options.start || 0;

	  if (res._header) {
	    // impossible to send now
	    this.headersAlreadySent();
	    return;
	  }

	  debug('pipe "%s"', path);

	  // set header fields
	  this.setHeader(path, stat);

	  // set content-type
	  this.type(path);

	  // conditional GET support
	  if (this.isConditionalGET() && this.isCachable() && this.isFresh()) {
	    this.notModified();
	    return;
	  }

	  // adjust len to start/end options
	  len = Math.max(0, len - offset);
	  if (options.end !== undefined) {
	    var bytes = options.end - offset + 1;
	    if (len > bytes) len = bytes;
	  }

	  // Range support
	  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
	    // parse
	    ranges = parseRange(len, ranges, {
	      combine: true
	    });

	    // If-Range support
	    if (!this.isRangeFresh()) {
	      debug('range stale');
	      ranges = -2;
	    }

	    // unsatisfiable
	    if (ranges === -1) {
	      debug('range unsatisfiable');

	      // Content-Range
	      res.setHeader('Content-Range', contentRange('bytes', len));

	      // 416 Requested Range Not Satisfiable
	      return this.error(416, {
	        headers: { 'Content-Range': res.getHeader('Content-Range') }
	      });
	    }

	    // valid (syntactically invalid/multiple ranges are treated as a regular response)
	    if (ranges !== -2 && ranges.length === 1) {
	      debug('range %j', ranges);

	      // Content-Range
	      res.statusCode = 206;
	      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));

	      // adjust for requested range
	      offset += ranges[0].start;
	      len = ranges[0].end - ranges[0].start + 1;
	    }
	  }

	  // clone options
	  for (var prop in options) {
	    opts[prop] = options[prop];
	  }

	  // set read options
	  opts.start = offset;
	  opts.end = Math.max(offset, offset + len - 1);

	  // content-length
	  res.setHeader('Content-Length', len);

	  // HEAD support
	  if (req.method === 'HEAD') {
	    res.end();
	    return;
	  }

	  this.stream(path, opts);
	};

	/**
	 * Transfer file for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendFile = function sendFile(path) {
	  var i = 0;
	  var self = this;

	  debug('stat "%s"', path);
	  fs.stat(path, function onstat(err, stat) {
	    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
	      // not found, check extensions
	      return next(err);
	    }
	    if (err) return self.onStatError(err);
	    if (stat.isDirectory()) return self.redirect(self.path);
	    self.emit('file', path, stat);
	    self.send(path, stat);
	  });

	  function next(err) {
	    if (self._extensions.length <= i) {
	      return err ? self.onStatError(err) : self.error(404);
	    }

	    var p = path + '.' + self._extensions[i++];

	    debug('stat "%s"', p);
	    fs.stat(p, function (err, stat) {
	      if (err) return next(err);
	      if (stat.isDirectory()) return next();
	      self.emit('file', p, stat);
	      self.send(p, stat);
	    });
	  }
	};

	/**
	 * Transfer index for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendIndex = function sendIndex(path) {
	  var i = -1;
	  var self = this;

	  function next(err) {
	    if (++i >= self._index.length) {
	      if (err) return self.onStatError(err);
	      return self.error(404);
	    }

	    var p = join(path, self._index[i]);

	    debug('stat "%s"', p);
	    fs.stat(p, function (err, stat) {
	      if (err) return next(err);
	      if (stat.isDirectory()) return next();
	      self.emit('file', p, stat);
	      self.send(p, stat);
	    });
	  }

	  next();
	};

	/**
	 * Stream `path` to the response.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @api private
	 */

	SendStream.prototype.stream = function stream(path, options) {
	  // TODO: this is all lame, refactor meeee
	  var finished = false;
	  var self = this;
	  var res = this.res;

	  // pipe
	  var stream = fs.createReadStream(path, options);
	  this.emit('stream', stream);
	  stream.pipe(res);

	  // response finished, done with the fd
	  onFinished(res, function onfinished() {
	    finished = true;
	    destroy(stream);
	  });

	  // error handling code-smell
	  stream.on('error', function onerror(err) {
	    // request already finished
	    if (finished) return;

	    // clean up stream
	    finished = true;
	    destroy(stream);

	    // error
	    self.onStatError(err);
	  });

	  // end
	  stream.on('end', function onend() {
	    self.emit('end');
	  });
	};

	/**
	 * Set content-type based on `path`
	 * if it hasn't been explicitly set.
	 *
	 * @param {String} path
	 * @api private
	 */

	SendStream.prototype.type = function type(path) {
	  var res = this.res;

	  if (res.getHeader('Content-Type')) return;

	  var type = mime.lookup(path);

	  if (!type) {
	    debug('no content-type');
	    return;
	  }

	  var charset = mime.charsets.lookup(type);

	  debug('content-type %s', type);
	  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
	};

	/**
	 * Set response header fields, most
	 * fields may be pre-defined.
	 *
	 * @param {String} path
	 * @param {Object} stat
	 * @api private
	 */

	SendStream.prototype.setHeader = function setHeader(path, stat) {
	  var res = this.res;

	  this.emit('headers', res, path, stat);

	  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
	    debug('accept ranges');
	    res.setHeader('Accept-Ranges', 'bytes');
	  }

	  if (this._cacheControl && !res.getHeader('Cache-Control')) {
	    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);
	    debug('cache-control %s', cacheControl);
	    res.setHeader('Cache-Control', cacheControl);
	  }

	  if (this._lastModified && !res.getHeader('Last-Modified')) {
	    var modified = stat.mtime.toUTCString();
	    debug('modified %s', modified);
	    res.setHeader('Last-Modified', modified);
	  }

	  if (this._etag && !res.getHeader('ETag')) {
	    var val = etag(stat);
	    debug('etag %s', val);
	    res.setHeader('ETag', val);
	  }
	};

	/**
	 * Clear all headers from a response.
	 *
	 * @param {object} res
	 * @private
	 */

	function clearHeaders(res) {
	  res._headers = {};
	  res._headerNames = {};
	}

	/**
	 * Collapse all leading slashes into a single slash
	 *
	 * @param {string} str
	 * @private
	 */
	function collapseLeadingSlashes(str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break;
	    }
	  }

	  return i > 1 ? '/' + str.substr(i) : str;
	}

	/**
	 * Determine if path parts contain a dotfile.
	 *
	 * @api private
	 */

	function containsDotFile(parts) {
	  for (var i = 0; i < parts.length; i++) {
	    if (parts[i][0] === '.') {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * Create a Content-Range header.
	 *
	 * @param {string} type
	 * @param {number} size
	 * @param {array} [range]
	 */

	function contentRange(type, size, range) {
	  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
	}

	/**
	 * decodeURIComponent.
	 *
	 * Allows V8 to only deoptimize this fn instead of all
	 * of send().
	 *
	 * @param {String} path
	 * @api private
	 */

	function decode(path) {
	  try {
	    return decodeURIComponent(path);
	  } catch (err) {
	    return -1;
	  }
	}

	/**
	 * Normalize the index option into an array.
	 *
	 * @param {boolean|string|array} val
	 * @param {string} name
	 * @private
	 */

	function normalizeList(val, name) {
	  var list = [].concat(val || []);

	  for (var i = 0; i < list.length; i++) {
	    if (typeof list[i] !== 'string') {
	      throw new TypeError(name + ' must be array of strings or false');
	    }
	  }

	  return list;
	}

	/**
	 * Set an object of headers on a response.
	 *
	 * @param {object} res
	 * @param {object} headers
	 * @private
	 */

	function setHeaders(res, headers) {
	  var keys = Object.keys(headers);

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    res.setHeader(key, headers[key]);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * http-errors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var setPrototypeOf = __webpack_require__(236);
	var statuses = __webpack_require__(203);
	var inherits = __webpack_require__(237);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = createError;
	module.exports.HttpError = createHttpErrorConstructor();

	// Populate exports for all constructors
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

	/**
	 * Create a new HTTP Error.
	 *
	 * @returns {Error}
	 * @public
	 */

	function createError() {
	  // so much arity going on ~_~
	  var err;
	  var msg;
	  var status = 500;
	  var props = {};
	  for (var i = 0; i < arguments.length; i++) {
	    var arg = arguments[i];
	    if (arg instanceof Error) {
	      err = arg;
	      status = err.status || err.statusCode || status;
	      continue;
	    }
	    switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {
	      case 'string':
	        msg = arg;
	        break;
	      case 'number':
	        status = arg;
	        break;
	      case 'object':
	        props = arg;
	        break;
	    }
	  }

	  if (typeof status !== 'number' || !statuses[status]) {
	    status = 500;
	  }

	  // constructor
	  var HttpError = createError[status];

	  if (!err) {
	    // create error
	    err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
	    Error.captureStackTrace(err, createError);
	  }

	  if (!HttpError || !(err instanceof HttpError)) {
	    // add properties to generic error
	    err.expose = status < 500;
	    err.status = err.statusCode = status;
	  }

	  for (var key in props) {
	    if (key !== 'status' && key !== 'statusCode') {
	      err[key] = props[key];
	    }
	  }

	  return err;
	}

	/**
	 * Create HTTP error abstract base class.
	 * @private
	 */

	function createHttpErrorConstructor() {
	  function HttpError() {
	    throw new TypeError('cannot construct abstract class');
	  }

	  inherits(HttpError, Error);

	  return HttpError;
	}

	/**
	 * Create a constructor for a client error.
	 * @private
	 */

	function createClientErrorConstructor(HttpError, name, code) {
	  var className = name.match(/Error$/) ? name : name + 'Error';

	  function ClientError(message) {
	    // create the error object
	    var err = new Error(message != null ? message : statuses[code]);

	    // capture a stack trace to the construction point
	    Error.captureStackTrace(err, ClientError);

	    // adjust the [[Prototype]]
	    setPrototypeOf(err, ClientError.prototype);

	    // redefine the error name
	    Object.defineProperty(err, 'name', {
	      enumerable: false,
	      configurable: true,
	      value: className,
	      writable: true
	    });

	    return err;
	  }

	  inherits(ClientError, HttpError);

	  ClientError.prototype.status = code;
	  ClientError.prototype.statusCode = code;
	  ClientError.prototype.expose = true;

	  return ClientError;
	}

	/**
	 * Create a constructor for a server error.
	 * @private
	 */

	function createServerErrorConstructor(HttpError, name, code) {
	  var className = name.match(/Error$/) ? name : name + 'Error';

	  function ServerError(message) {
	    // create the error object
	    var err = new Error(message != null ? message : statuses[code]);

	    // capture a stack trace to the construction point
	    Error.captureStackTrace(err, ServerError);

	    // adjust the [[Prototype]]
	    setPrototypeOf(err, ServerError.prototype);

	    // redefine the error name
	    Object.defineProperty(err, 'name', {
	      enumerable: false,
	      configurable: true,
	      value: className,
	      writable: true
	    });

	    return err;
	  }

	  inherits(ServerError, HttpError);

	  ServerError.prototype.status = code;
	  ServerError.prototype.statusCode = code;
	  ServerError.prototype.expose = false;

	  return ServerError;
	}

	/**
	 * Populate the exports object with constructors for every error class.
	 * @private
	 */

	function populateConstructorExports(exports, codes, HttpError) {
	  codes.forEach(function forEachCode(code) {
	    var CodeError;
	    var name = toIdentifier(statuses[code]);

	    switch (String(code).charAt(0)) {
	      case '4':
	        CodeError = createClientErrorConstructor(HttpError, name, code);
	        break;
	      case '5':
	        CodeError = createServerErrorConstructor(HttpError, name, code);
	        break;
	    }

	    if (CodeError) {
	      // export the constructor
	      exports[code] = CodeError;
	      exports[name] = CodeError;
	    }
	  });

	  // backwards-compatibility
	  exports["I'mateapot"] = exports.ImATeapot;
	}

	/**
	 * Convert a string of words to a JavaScript identifier.
	 * @private
	 */

	function toIdentifier(str) {
	  return str.split(' ').map(function (token) {
	    return token.slice(0, 1).toUpperCase() + token.slice(1);
	  }).join('').replace(/[^ _0-9a-z]/gi, '');
	}

/***/ },
/* 236 */
/***/ function(module, exports) {

	"use strict";

	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);

	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
	}

	function mixinProperties(obj, proto) {
		for (var prop in proto) {
			obj[prop] = proto[prop];
		}
	}

/***/ },
/* 237 */
/***/ function(module, exports) {

	'use strict';

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * destroy
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var ReadStream = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).ReadStream;
	var Stream = __webpack_require__(239);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = destroy;

	/**
	 * Destroy a stream.
	 *
	 * @param {object} stream
	 * @public
	 */

	function destroy(stream) {
	  if (stream instanceof ReadStream) {
	    return destroyReadStream(stream);
	  }

	  if (!(stream instanceof Stream)) {
	    return stream;
	  }

	  if (typeof stream.destroy === 'function') {
	    stream.destroy();
	  }

	  return stream;
	}

	/**
	 * Destroy a ReadStream.
	 *
	 * @param {object} stream
	 * @private
	 */

	function destroyReadStream(stream) {
	  stream.destroy();

	  if (typeof stream.close === 'function') {
	    // node.js core bug work-around
	    stream.on('open', onOpenClose);
	  }

	  return stream;
	}

	/**
	 * On open handler to close stream.
	 * @private
	 */

	function onOpenClose() {
	  if (typeof this.fd === 'number') {
	    // actually close down the fd
	    this.close();
	  }
	}

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(188).EventEmitter;
	var inherits = __webpack_require__(237);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(240);
	Stream.Writable = __webpack_require__(250);
	Stream.Duplex = __webpack_require__(251);
	Stream.Transform = __webpack_require__(252);
	Stream.PassThrough = __webpack_require__(253);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;

	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function (dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }

	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports = module.exports = __webpack_require__(241);
	exports.Stream = __webpack_require__(239);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(246);
	exports.Duplex = __webpack_require__(245);
	exports.Transform = __webpack_require__(248);
	exports.PassThrough = __webpack_require__(249);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(239);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(242);
	/*</replacement>*/

	/*<replacement>*/
	var Buffer = __webpack_require__(193).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(188).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(239);

	/*<replacement>*/
	var util = __webpack_require__(243);
	util.inherits = __webpack_require__(237);
	/*</replacement>*/

	var StringDecoder;

	/*<replacement>*/
	var debug = __webpack_require__(244);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(245);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(247).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(245);

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended) onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);

	      if (!addToFront) state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	        if (state.needReadable) emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(247).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) {
	      n |= n >> p;
	    }n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended) return 0;

	  if (state.objectMode) return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
	  }

	  if (n <= 0) return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended) state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

	  if (!util.isNull(ret)) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) process.nextTick(function () {
	      emitReadable_(stream);
	    });else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function () {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause', src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function () {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function () {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0) return null;

	  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode) ret = list.join('');else ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode) ret = '';else ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function () {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 242 */
/***/ function(module, exports) {

	'use strict';

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return objectToString(e) === '[object Error]' || e instanceof Error;
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
	  typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 244 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(243);
	util.inherits = __webpack_require__(237);
	/*</replacement>*/

	var Readable = __webpack_require__(241);
	var Writable = __webpack_require__(246);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function (method) {
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(193).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = __webpack_require__(243);
	util.inherits = __webpack_require__(237);
	/*</replacement>*/

	var Stream = __webpack_require__(239);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(245);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(245);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};

	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function () {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function () {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (!util.isFunction(cb)) cb = function cb() {};

	  if (state.ended) writeAfterEnd(this, state, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb));else doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync) process.nextTick(function () {
	    state.pendingcb--;
	    cb(er);
	  });else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function () {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++) {
	      cbs.push(state.buffer[c].callback);
	    } // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length) state.buffer = state.buffer.slice(c);else state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(stream, state) {
	  return state.ending && state.length === 0 && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(193).Buffer;

	var isBufferEncoding = Buffer.isEncoding || function (encoding) {
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function (encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};

	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function (buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function (buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = buffer.length >= 3 ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function (buffer) {
	  var res = '';
	  if (buffer && buffer.length) res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(245);

	/*<replacement>*/
	var util = __webpack_require__(243);
	util.inherits = __webpack_require__(237);
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function TransformState(options, stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data)) stream.push(data);

	  if (cb) cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function () {
	    if (util.isFunction(this._flush)) this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(248);

	/*<replacement>*/
	var util = __webpack_require__(243);
	util.inherits = __webpack_require__(237);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = __webpack_require__(246);

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = __webpack_require__(245);

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = __webpack_require__(248);

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = __webpack_require__(249);

/***/ },
/* 254 */
/***/ function(module, exports) {

	/*!
	 * encodeurl
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = encodeUrl;

	/**
	 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	 * and including invalid escape sequences.
	 * @private
	 */

	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]))+/g;

	/**
	 * RegExp to match unmatched surrogate pair.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

	/**
	 * String to replace unmatched surrogate pair with.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1$2';

	/**
	 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	 *
	 * This function will take an already-encoded URL and encode all the non-URL
	 * code points. This function will not encode the "%" character unless it is
	 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	 * be encoded as `%25foo`).
	 *
	 * This encode is meant to be "safe" and does not throw errors. It will try as
	 * hard as it can to properly encode the given URL, including replacing any raw,
	 * unpaired surrogate pairs with the Unicode replacement character prior to
	 * encoding.
	 *
	 * @param {string} url
	 * @return {string}
	 * @public
	 */

	function encodeUrl(url) {
	  return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
	}

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * etag
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = etag;

	/**
	 * Module dependencies.
	 * @private
	 */

	var crypto = __webpack_require__(256);
	var Stats = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).Stats;

	/**
	 * Module variables.
	 * @private
	 */

	var base64PadCharRegExp = /=+$/;
	var toString = Object.prototype.toString;

	/**
	 * Generate an entity tag.
	 *
	 * @param {Buffer|string} entity
	 * @return {string}
	 * @private
	 */

	function entitytag(entity) {
	  if (entity.length === 0) {
	    // fast-path empty
	    return '"0-1B2M2Y8AsgTpgAmY7PhCfg"';
	  }

	  // compute hash of entity
	  var hash = crypto.createHash('md5').update(entity, 'utf8').digest('base64').replace(base64PadCharRegExp, '');

	  // compute length of entity
	  var len = typeof entity === 'string' ? Buffer.byteLength(entity, 'utf8') : entity.length;

	  return '"' + len.toString(16) + '-' + hash + '"';
	}

	/**
	 * Create a simple ETag.
	 *
	 * @param {string|Buffer|Stats} entity
	 * @param {object} [options]
	 * @param {boolean} [options.weak]
	 * @return {String}
	 * @public
	 */

	function etag(entity, options) {
	  if (entity == null) {
	    throw new TypeError('argument entity is required');
	  }

	  // support fs.Stats object
	  var isStats = isstats(entity);
	  var weak = options && typeof options.weak === 'boolean' ? options.weak : isStats;

	  // validate argument
	  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
	    throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
	  }

	  // generate entity tag
	  var tag = isStats ? stattag(entity) : entitytag(entity);

	  return weak ? 'W/' + tag : tag;
	}

	/**
	 * Determine if object is a Stats object.
	 *
	 * @param {object} obj
	 * @return {boolean}
	 * @api private
	 */

	function isstats(obj) {
	  // genuine fs.Stats
	  if (typeof Stats === 'function' && obj instanceof Stats) {
	    return true;
	  }

	  // quack quack
	  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]' && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]' && 'ino' in obj && typeof obj.ino === 'number' && 'size' in obj && typeof obj.size === 'number';
	}

	/**
	 * Generate a tag for a stat.
	 *
	 * @param {object} stat
	 * @return {string}
	 * @private
	 */

	function stattag(stat) {
	  var mtime = stat.mtime.getTime().toString(16);
	  var size = stat.size.toString(16);

	  return '"' + size + '-' + mtime + '"';
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var rng = __webpack_require__(257);

	function error() {
	  var m = [].slice.call(arguments).join(' ');
	  throw new Error([m, 'we accept pull requests', 'http://github.com/dominictarr/crypto-browserify'].join('\n'));
	}

	exports.createHash = __webpack_require__(259);

	exports.createHmac = __webpack_require__(270);

	exports.randomBytes = function (size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)));
	    } catch (err) {
	      callback(err);
	    }
	  } else {
	    return new Buffer(rng(size));
	  }
	};

	function each(a, f) {
	  for (var i in a) {
	    f(a[i], i);
	  }
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160'];
	};

	var p = __webpack_require__(271)(exports);
	exports.pbkdf2 = p.pbkdf2;
	exports.pbkdf2Sync = p.pbkdf2Sync;

	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials', 'createCipher', 'createCipheriv', 'createDecipher', 'createDecipheriv', 'createSign', 'createVerify', 'createDiffieHellman'], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet');
	  };
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {'use strict';

	(function () {
	  var g = ('undefined' === typeof window ? global : window) || {};
	  _crypto = g.crypto || g.msCrypto || __webpack_require__(258);
	  module.exports = function (size) {
	    // Modern Browsers
	    if (_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */

	      _crypto.getRandomValues(bytes);
	      return bytes;
	    } else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size);
	    } else throw new Error('secure random number generation not supported by this browser\n' + 'use chrome, FireFox or Internet Explorer 11');
	  };
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(193).Buffer))

/***/ },
/* 258 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var createHash = __webpack_require__(260);

	var md5 = toConstructor(__webpack_require__(267));
	var rmd160 = toConstructor(__webpack_require__(269));

	function toConstructor(fn) {
	  return function () {
	    var buffers = [];
	    var m = {
	      update: function update(data, enc) {
	        if (!Buffer.isBuffer(data)) data = new Buffer(data, enc);
	        buffers.push(data);
	        return this;
	      },
	      digest: function digest(enc) {
	        var buf = Buffer.concat(buffers);
	        var r = fn(buf);
	        buffers = null;
	        return enc ? r.toString(enc) : r;
	      }
	    };
	    return m;
	  };
	}

	module.exports = function (alg) {
	  if ('md5' === alg) return new md5();
	  if ('rmd160' === alg) return new rmd160();
	  return createHash(alg);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _exports = module.exports = function (alg) {
	  var Alg = _exports[alg];
	  if (!Alg) throw new Error(alg + ' is not supported (we accept pull requests)');
	  return new Alg();
	};

	var Buffer = __webpack_require__(193).Buffer;
	var Hash = __webpack_require__(261)(Buffer);

	_exports.sha1 = __webpack_require__(262)(Buffer, Hash);
	_exports.sha256 = __webpack_require__(265)(Buffer, Hash);
	_exports.sha512 = __webpack_require__(266)(Buffer, Hash);

/***/ },
/* 261 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash(blockSize, finalSize) {
	    this._block = new Buffer(blockSize); //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize;
	    this._blockSize = blockSize;
	    this._len = 0;
	    this._s = 0;
	  }

	  Hash.prototype.init = function () {
	    this._s = 0;
	    this._len = 0;
	  };

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8";
	      data = new Buffer(data, enc);
	    }

	    var l = this._len += data.length;
	    var s = this._s = this._s || 0;
	    var f = 0;
	    var buffer = this._block;

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - s % this._blockSize);
	      var ch = t - f;

	      for (var i = 0; i < ch; i++) {
	        buffer[s % this._blockSize + i] = data[i + f];
	      }

	      s += ch;
	      f += ch;

	      if (s % this._blockSize === 0) {
	        this._update(buffer);
	      }
	    }
	    this._s = s;

	    return this;
	  };

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8;

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80;

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1);

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block);
	      this._block.fill(0);
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4);

	    var hash = this._update(this._block) || this._hash();

	    return enc ? hash.toString(enc) : hash;
	  };

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass');
	  };

	  return Hash;
	};

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(263).inherits;

	module.exports = function (Buffer, Hash) {

	  var A = 0 | 0;
	  var B = 4 | 0;
	  var C = 8 | 0;
	  var D = 12 | 0;
	  var E = 16 | 0;

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80);

	  var POOL = [];

	  function Sha1() {
	    if (POOL.length) return POOL.pop().init();

	    if (!(this instanceof Sha1)) return new Sha1();
	    this._w = W;
	    Hash.call(this, 16 * 4, 14 * 4);

	    this._h = null;
	    this.init();
	  }

	  inherits(Sha1, Hash);

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301;
	    this._b = 0xefcdab89;
	    this._c = 0x98badcfe;
	    this._d = 0x10325476;
	    this._e = 0xc3d2e1f0;

	    Hash.prototype.init.call(this);
	    return this;
	  };

	  Sha1.prototype._POOL = POOL;
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e;

	    a = _a = this._a;
	    b = _b = this._b;
	    c = _c = this._c;
	    d = _d = this._d;
	    e = _e = this._e;

	    var w = this._w;

	    for (var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j * 4) : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);

	      var t = add(add(rol(a, 5), sha1_ft(j, b, c, d)), add(add(e, W), sha1_kt(j)));

	      e = d;
	      d = c;
	      c = rol(b, 30);
	      b = a;
	      a = t;
	    }

	    this._a = add(a, _a);
	    this._b = add(b, _b);
	    this._c = add(c, _c);
	    this._d = add(d, _d);
	    this._e = add(e, _e);
	  };

	  Sha1.prototype._hash = function () {
	    if (POOL.length < 100) POOL.push(this);
	    var H = new Buffer(20);
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a | 0, A);
	    H.writeInt32BE(this._b | 0, B);
	    H.writeInt32BE(this._c | 0, C);
	    H.writeInt32BE(this._d | 0, D);
	    H.writeInt32BE(this._e | 0, E);
	    return H;
	  };

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if (t < 20) return b & c | ~b & d;
	    if (t < 40) return b ^ c ^ d;
	    if (t < 60) return b & c | b & d | c & d;
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return x + y | 0;
	    //lets see how this goes on testling.
	    //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	    //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	    //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return num << cnt | num >>> 32 - cnt;
	  }

	  return Sha1;
	};

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function (f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function (x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s':
	        return String(args[i++]);
	      case '%d':
	        return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function (fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function () {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};

	var debugs = {};
	var debugEnviron;
	exports.debuglog = function (set) {
	  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function () {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function () {};
	    }
	  }
	  return debugs[set];
	};

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold': [1, 22],
	  'italic': [3, 23],
	  'underline': [4, 24],
	  'inverse': [7, 27],
	  'white': [37, 39],
	  'grey': [90, 39],
	  'black': [30, 39],
	  'blue': [34, 39],
	  'cyan': [36, 39],
	  'green': [32, 39],
	  'magenta': [35, 39],
	  'red': [31, 39],
	  'yellow': [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};

	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}

	function stylizeNoColor(str, styleType) {
	  return str;
	}

	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function (val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}

	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect && value && isFunction(value.inspect) &&
	  // Filter out the util module, it's inspect function is special
	  value.inspect !== exports.inspect &&
	  // Also filter out any prototype objects using the circular check.
	  !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '',
	      array = false,
	      braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function (key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}

	function formatPrimitive(ctx, value) {
	  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value)) return ctx.stylize('' + value, 'number');
	  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value)) return ctx.stylize('null', 'null');
	}

	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}

	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function (key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	    }
	  });
	  return output;
	}

	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function (line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function (line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}

	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function (prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
	  typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(264);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}

	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}

	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function () {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};

	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(237);

	exports._extend = function (origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))

/***/ },
/* 264 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = function isBuffer(arg) {
	  return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
	};

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(263).inherits;

	module.exports = function (Buffer, Hash) {

	  var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

	  var W = new Array(64);

	  function Sha256() {
	    this.init();

	    this._w = W; //new Array(64)

	    Hash.call(this, 16 * 4, 14 * 4);
	  }

	  inherits(Sha256, Hash);

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667 | 0;
	    this._b = 0xbb67ae85 | 0;
	    this._c = 0x3c6ef372 | 0;
	    this._d = 0xa54ff53a | 0;
	    this._e = 0x510e527f | 0;
	    this._f = 0x9b05688c | 0;
	    this._g = 0x1f83d9ab | 0;
	    this._h = 0x5be0cd19 | 0;

	    this._len = this._s = 0;

	    return this;
	  };

	  function S(X, n) {
	    return X >>> n | X << 32 - n;
	  }

	  function R(X, n) {
	    return X >>> n;
	  }

	  function Ch(x, y, z) {
	    return x & y ^ ~x & z;
	  }

	  function Maj(x, y, z) {
	    return x & y ^ x & z ^ y & z;
	  }

	  function Sigma0256(x) {
	    return S(x, 2) ^ S(x, 13) ^ S(x, 22);
	  }

	  function Sigma1256(x) {
	    return S(x, 6) ^ S(x, 11) ^ S(x, 25);
	  }

	  function Gamma0256(x) {
	    return S(x, 7) ^ S(x, 18) ^ R(x, 3);
	  }

	  function Gamma1256(x) {
	    return S(x, 17) ^ S(x, 19) ^ R(x, 10);
	  }

	  Sha256.prototype._update = function (M) {

	    var W = this._w;
	    var a, b, c, d, e, f, g, h;
	    var T1, T2;

	    a = this._a | 0;
	    b = this._b | 0;
	    c = this._c | 0;
	    d = this._d | 0;
	    e = this._e | 0;
	    f = this._f | 0;
	    g = this._g | 0;
	    h = this._h | 0;

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16 ? M.readInt32BE(j * 4) : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16];

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w;

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g;g = f;f = e;e = d + T1;d = c;c = b;b = a;a = T1 + T2;
	    }

	    this._a = a + this._a | 0;
	    this._b = b + this._b | 0;
	    this._c = c + this._c | 0;
	    this._d = d + this._d | 0;
	    this._e = e + this._e | 0;
	    this._f = f + this._f | 0;
	    this._g = g + this._g | 0;
	    this._h = h + this._h | 0;
	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32);

	    H.writeInt32BE(this._a, 0);
	    H.writeInt32BE(this._b, 4);
	    H.writeInt32BE(this._c, 8);
	    H.writeInt32BE(this._d, 12);
	    H.writeInt32BE(this._e, 16);
	    H.writeInt32BE(this._f, 20);
	    H.writeInt32BE(this._g, 24);
	    H.writeInt32BE(this._h, 28);

	    return H;
	  };

	  return Sha256;
	};

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(263).inherits;

	module.exports = function (Buffer, Hash) {
	  var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

	  var W = new Array(160);

	  function Sha512() {
	    this.init();
	    this._w = W;

	    Hash.call(this, 128, 112);
	  }

	  inherits(Sha512, Hash);

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667 | 0;
	    this._b = 0xbb67ae85 | 0;
	    this._c = 0x3c6ef372 | 0;
	    this._d = 0xa54ff53a | 0;
	    this._e = 0x510e527f | 0;
	    this._f = 0x9b05688c | 0;
	    this._g = 0x1f83d9ab | 0;
	    this._h = 0x5be0cd19 | 0;

	    this._al = 0xf3bcc908 | 0;
	    this._bl = 0x84caa73b | 0;
	    this._cl = 0xfe94f82b | 0;
	    this._dl = 0x5f1d36f1 | 0;
	    this._el = 0xade682d1 | 0;
	    this._fl = 0x2b3e6c1f | 0;
	    this._gl = 0xfb41bd6b | 0;
	    this._hl = 0x137e2179 | 0;

	    this._len = this._s = 0;

	    return this;
	  };

	  function S(X, Xl, n) {
	    return X >>> n | Xl << 32 - n;
	  }

	  function Ch(x, y, z) {
	    return x & y ^ ~x & z;
	  }

	  function Maj(x, y, z) {
	    return x & y ^ x & z ^ y & z;
	  }

	  Sha512.prototype._update = function (M) {

	    var W = this._w;
	    var a, b, c, d, e, f, g, h;
	    var al, bl, cl, dl, el, fl, gl, hl;

	    a = this._a | 0;
	    b = this._b | 0;
	    c = this._c | 0;
	    d = this._d | 0;
	    e = this._e | 0;
	    f = this._f | 0;
	    g = this._g | 0;
	    h = this._h | 0;

	    al = this._al | 0;
	    bl = this._bl | 0;
	    cl = this._cl | 0;
	    dl = this._dl | 0;
	    el = this._el | 0;
	    fl = this._fl | 0;
	    gl = this._gl | 0;
	    hl = this._hl | 0;

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2;

	      var Wi, Wil;

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4);
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4);
	      } else {
	        var x = W[j - 15 * 2];
	        var xl = W[j - 15 * 2 + 1];
	        var gamma0 = S(x, xl, 1) ^ S(x, xl, 8) ^ x >>> 7;
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7);

	        x = W[j - 2 * 2];
	        xl = W[j - 2 * 2 + 1];
	        var gamma1 = S(x, xl, 19) ^ S(xl, x, 29) ^ x >>> 6;
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6);

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7 = W[j - 7 * 2];
	        var Wi7l = W[j - 7 * 2 + 1];

	        var Wi16 = W[j - 16 * 2];
	        var Wi16l = W[j - 16 * 2 + 1];

	        Wil = gamma0l + Wi7l;
	        Wi = gamma0 + Wi7 + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
	        Wil = Wil + gamma1l;
	        Wi = Wi + gamma1 + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
	        Wil = Wil + Wi16l;
	        Wi = Wi + Wi16 + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);

	        W[j] = Wi;
	        W[j + 1] = Wil;
	      }

	      var maj = Maj(a, b, c);
	      var majl = Maj(al, bl, cl);

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7);
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7);
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9);
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9);

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j];
	      var Kil = K[j + 1];

	      var ch = Ch(e, f, g);
	      var chl = Ch(el, fl, gl);

	      var t1l = hl + sigma1l;
	      var t1 = h + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
	      t1l = t1l + chl;
	      t1 = t1 + ch + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
	      t1l = t1l + Kil;
	      t1 = t1 + Ki + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
	      t1l = t1l + Wil;
	      t1 = t1 + Wi + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl;
	      var t2 = sigma0h + maj + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);

	      h = g;
	      hl = gl;
	      g = f;
	      gl = fl;
	      f = e;
	      fl = el;
	      el = dl + t1l | 0;
	      e = d + t1 + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
	      d = c;
	      dl = cl;
	      c = b;
	      cl = bl;
	      b = a;
	      bl = al;
	      al = t1l + t2l | 0;
	      a = t1 + t2 + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
	    }

	    this._al = this._al + al | 0;
	    this._bl = this._bl + bl | 0;
	    this._cl = this._cl + cl | 0;
	    this._dl = this._dl + dl | 0;
	    this._el = this._el + el | 0;
	    this._fl = this._fl + fl | 0;
	    this._gl = this._gl + gl | 0;
	    this._hl = this._hl + hl | 0;

	    this._a = this._a + a + (this._al >>> 0 < al >>> 0 ? 1 : 0) | 0;
	    this._b = this._b + b + (this._bl >>> 0 < bl >>> 0 ? 1 : 0) | 0;
	    this._c = this._c + c + (this._cl >>> 0 < cl >>> 0 ? 1 : 0) | 0;
	    this._d = this._d + d + (this._dl >>> 0 < dl >>> 0 ? 1 : 0) | 0;
	    this._e = this._e + e + (this._el >>> 0 < el >>> 0 ? 1 : 0) | 0;
	    this._f = this._f + f + (this._fl >>> 0 < fl >>> 0 ? 1 : 0) | 0;
	    this._g = this._g + g + (this._gl >>> 0 < gl >>> 0 ? 1 : 0) | 0;
	    this._h = this._h + h + (this._hl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
	  };

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64);

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset);
	      H.writeInt32BE(l, offset + 4);
	    }

	    writeInt64BE(this._a, this._al, 0);
	    writeInt64BE(this._b, this._bl, 8);
	    writeInt64BE(this._c, this._cl, 16);
	    writeInt64BE(this._d, this._dl, 24);
	    writeInt64BE(this._e, this._el, 32);
	    writeInt64BE(this._f, this._fl, 40);
	    writeInt64BE(this._g, this._gl, 48);
	    writeInt64BE(this._h, this._hl, 56);

	    return H;
	  };

	  return Sha512;
	};

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(268);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << len % 32;
	  x[(len + 64 >>> 9 << 4) + 14] = len;

	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;

	  for (var i = 0; i < x.length; i += 16) {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
	    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
	    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
	    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
	    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
	    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
	    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

	    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
	    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
	    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
	    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
	    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
	    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
	    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
	    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
	    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
	    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
	    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
	    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
	    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
	    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
	    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
	    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
	    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
	    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
	    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
	    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
	    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
	    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
	    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
	    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
	    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
	    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
	    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t) {
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
	}
	function md5_ff(a, b, c, d, x, s, t) {
	  return md5_cmn(b & c | ~b & d, a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t) {
	  return md5_cmn(b & d | c & ~d, a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t) {
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t) {
	  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y) {
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xFFFF;
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	var intSize = 4;
	var zeroBuffer = new Buffer(intSize);zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if (buf.length % intSize !== 0) {
	    var len = buf.length + (intSize - buf.length % intSize);
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	module.exports = ripemd160;

	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
	var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
	var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
	var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

	var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function bytesToWords(bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << 24 - b % 32;
	  }
	  return words;
	};

	var wordsToBytes = function wordsToBytes(words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function processBlock(H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = al + M[offset + zl[i]] | 0;
	    if (i < 16) {
	      t += f1(bl, cl, dl) + hl[0];
	    } else if (i < 32) {
	      t += f2(bl, cl, dl) + hl[1];
	    } else if (i < 48) {
	      t += f3(bl, cl, dl) + hl[2];
	    } else if (i < 64) {
	      t += f4(bl, cl, dl) + hl[3];
	    } else {
	      // if (i<80) {
	      t += f5(bl, cl, dl) + hl[4];
	    }
	    t = t | 0;
	    t = rotl(t, sl[i]);
	    t = t + el | 0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = ar + M[offset + zr[i]] | 0;
	    if (i < 16) {
	      t += f5(br, cr, dr) + hr[0];
	    } else if (i < 32) {
	      t += f4(br, cr, dr) + hr[1];
	    } else if (i < 48) {
	      t += f3(br, cr, dr) + hr[2];
	    } else if (i < 64) {
	      t += f2(br, cr, dr) + hr[3];
	    } else {
	      // if (i<80) {
	      t += f1(br, cr, dr) + hr[4];
	    }
	    t = t | 0;
	    t = rotl(t, sr[i]);
	    t = t + er | 0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t = H[1] + cl + dr | 0;
	  H[1] = H[2] + dl + er | 0;
	  H[2] = H[3] + el + ar | 0;
	  H[3] = H[4] + al + br | 0;
	  H[4] = H[0] + bl + cr | 0;
	  H[0] = t;
	};

	function f1(x, y, z) {
	  return x ^ y ^ z;
	}

	function f2(x, y, z) {
	  return x & y | ~x & z;
	}

	function f3(x, y, z) {
	  return (x | ~y) ^ z;
	}

	function f4(x, y, z) {
	  return x & z | y & ~z;
	}

	function f5(x, y, z) {
	  return x ^ (y | ~z);
	}

	function rotl(x, n) {
	  return x << n | x >>> 32 - n;
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string') message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	  m[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;

	  for (var i = 0; i < m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	    // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var createHash = __webpack_require__(259);

	var zeroBuffer = new Buffer(128);
	zeroBuffer.fill(0);

	module.exports = Hmac;

	function Hmac(alg, key) {
	  if (!(this instanceof Hmac)) return new Hmac(alg, key);
	  this._opad = opad;
	  this._alg = alg;

	  var blocksize = alg === 'sha512' ? 128 : 64;

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key;

	  if (key.length > blocksize) {
	    key = createHash(alg).update(key).digest();
	  } else if (key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize);
	  }

	  var ipad = this._ipad = new Buffer(blocksize);
	  var opad = this._opad = new Buffer(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  this._hash = createHash(alg).update(ipad);
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc);
	  return this;
	};

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest();
	  return createHash(this._alg).update(this._opad).update(h).digest(enc);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var pbkdf2Export = __webpack_require__(272);

	module.exports = function (crypto, exports) {
	  exports = exports || {};

	  var exported = pbkdf2Export(crypto);

	  exports.pbkdf2 = exported.pbkdf2;
	  exports.pbkdf2Sync = exported.pbkdf2Sync;

	  return exports;
	};

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	module.exports = function (crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest;
	      digest = undefined;
	    }

	    if ('function' !== typeof callback) throw new Error('No callback provided to pbkdf2');

	    setTimeout(function () {
	      var result;

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest);
	      } catch (e) {
	        return callback(e);
	      }

	      callback(undefined, result);
	    });
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations) throw new TypeError('Iterations not a number');

	    if (iterations < 0) throw new TypeError('Bad iterations');

	    if ('number' !== typeof keylen) throw new TypeError('Key length not a number');

	    if (keylen < 0) throw new TypeError('Bad key length');

	    digest = digest || 'sha1';

	    if (!Buffer.isBuffer(password)) password = new Buffer(password);
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt);

	    var hLen,
	        l = 1,
	        r,
	        T;
	    var DK = new Buffer(keylen);
	    var block1 = new Buffer(salt.length + 4);
	    salt.copy(block1, 0, 0, salt.length);

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length);

	      var U = crypto.createHmac(digest, password).update(block1).digest();

	      if (!hLen) {
	        hLen = U.length;
	        T = new Buffer(hLen);
	        l = Math.ceil(keylen / hLen);
	        r = keylen - (l - 1) * hLen;

	        if (keylen > (Math.pow(2, 32) - 1) * hLen) throw new TypeError('keylen exceeds maximum length');
	      }

	      U.copy(T, 0, 0, hLen);

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest();

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k];
	        }
	      }

	      var destPos = (i - 1) * hLen;
	      var len = i == l ? r : hLen;
	      T.copy(DK, destPos, 0, len);
	    }

	    return DK;
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 273 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Expose `fresh()`.
	 */

	module.exports = fresh;

	/**
	 * Check freshness of `req` and `res` headers.
	 *
	 * When the cache is "fresh" __true__ is returned,
	 * otherwise __false__ is returned to indicate that
	 * the cache is now stale.
	 *
	 * @param {Object} req
	 * @param {Object} res
	 * @return {Boolean}
	 * @api public
	 */

	function fresh(req, res) {
	  // defaults
	  var etagMatches = true;
	  var notModified = true;

	  // fields
	  var modifiedSince = req['if-modified-since'];
	  var noneMatch = req['if-none-match'];
	  var lastModified = res['last-modified'];
	  var etag = res['etag'];
	  var cc = req['cache-control'];

	  // unconditional request
	  if (!modifiedSince && !noneMatch) return false;

	  // check for no-cache cache request directive
	  if (cc && cc.indexOf('no-cache') !== -1) return false;

	  // parse if-none-match
	  if (noneMatch) noneMatch = noneMatch.split(/ *, */);

	  // if-none-match
	  if (noneMatch) {
	    etagMatches = noneMatch.some(function (match) {
	      return match === '*' || match === etag || match === 'W/' + etag;
	    });
	  }

	  // if-modified-since
	  if (modifiedSince) {
	    modifiedSince = new Date(modifiedSince);
	    lastModified = new Date(lastModified);
	    notModified = lastModified <= modifiedSince;
	  }

	  return !!(etagMatches && notModified);
	}

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var path = __webpack_require__(230);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	function Mime() {
	  // Map of extension -> mime type
	  this.types = Object.create(null);

	  // Map of mime type -> extension
	  this.extensions = Object.create(null);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * @param map (Object) type definitions
	 */
	Mime.prototype.define = function (map) {
	  for (var type in map) {
	    var exts = map[type];
	    for (var i = 0; i < exts.length; i++) {
	      if (process.env.DEBUG_MIME && this.types[exts]) {
	        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts] + ' to ' + type);
	      }

	      this.types[exts[i]] = type;
	    }

	    // Default extension is the first one we encounter
	    if (!this.extensions[type]) {
	      this.extensions[type] = exts[0];
	    }
	  }
	};

	/**
	 * Load an Apache2-style ".types" file
	 *
	 * This may be called multiple times (it's expected).  Where files declare
	 * overlapping types/extensions, the last file wins.
	 *
	 * @param file (String) path of file to load.
	 */
	Mime.prototype.load = function (file) {
	  this._loading = file;
	  // Read file and split into lines
	  var map = {},
	      content = fs.readFileSync(file, 'ascii'),
	      lines = content.split(/[\r\n]+/);

	  lines.forEach(function (line) {
	    // Clean up whitespace/comments, and split into fields
	    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
	    map[fields.shift()] = fields;
	  });

	  this.define(map);

	  this._loading = null;
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.lookup = function (path, fallback) {
	  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();

	  return this.types[ext] || fallback || this.default_type;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.extension = function (mimeType) {
	  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
	  return this.extensions[type];
	};

	// Default instance
	var mime = new Mime();

	// Define built-in types
	mime.define(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./types.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	// Default type
	mime.default_type = mime.lookup('bin');

	//
	// Additional API specific to the default instance
	//

	mime.Mime = Mime;

	/**
	 * Lookup a charset based on mime type.
	 */
	mime.charsets = {
	  lookup: function lookup(mimeType, fallback) {
	    // Assume text types are utf8
	    return (/^text\//.test(mimeType) ? 'UTF-8' : fallback
	    );
	  }
	};

	module.exports = mime;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 275 */,
/* 276 */
/***/ function(module, exports) {

	/*!
	 * range-parser
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = rangeParser;

	/**
	 * Parse "Range" header `str` relative to the given file `size`.
	 *
	 * @param {Number} size
	 * @param {String} str
	 * @param {Object} [options]
	 * @return {Array}
	 * @public
	 */

	function rangeParser(size, str, options) {
	  var index = str.indexOf('=');

	  if (index === -1) {
	    return -2;
	  }

	  // split the range string
	  var arr = str.slice(index + 1).split(',');
	  var ranges = [];

	  // add ranges type
	  ranges.type = str.slice(0, index);

	  // parse all ranges
	  for (var i = 0; i < arr.length; i++) {
	    var range = arr[i].split('-');
	    var start = parseInt(range[0], 10);
	    var end = parseInt(range[1], 10);

	    // -nnn
	    if (isNaN(start)) {
	      start = size - end;
	      end = size - 1;
	      // nnn-
	    } else if (isNaN(end)) {
	      end = size - 1;
	    }

	    // limit last-byte-pos to current length
	    if (end > size - 1) {
	      end = size - 1;
	    }

	    // invalid or unsatisifiable
	    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
	      continue;
	    }

	    // add range
	    ranges.push({
	      start: start,
	      end: end
	    });
	  }

	  if (ranges.length < 1) {
	    // unsatisifiable
	    return -1;
	  }

	  return options && options.combine ? combineRanges(ranges) : ranges;
	}

	/**
	 * Combine overlapping & adjacent ranges.
	 * @private
	 */

	function combineRanges(ranges) {
	  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);

	  for (var j = 0, i = 1; i < ordered.length; i++) {
	    var range = ordered[i];
	    var current = ordered[j];

	    if (range.start > current.end + 1) {
	      // next range
	      ordered[++j] = range;
	    } else if (range.end > current.end) {
	      // extend range
	      current.end = range.end;
	      current.index = Math.min(current.index, range.index);
	    }
	  }

	  // trim ordered array
	  ordered.length = j + 1;

	  // generate combined range
	  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);

	  // copy ranges type
	  combined.type = ranges.type;

	  return combined;
	}

	/**
	 * Map function to add index value to ranges.
	 * @private
	 */

	function mapWithIndex(range, index) {
	  return {
	    start: range.start,
	    end: range.end,
	    index: index
	  };
	}

	/**
	 * Map function to remove index value from ranges.
	 * @private
	 */

	function mapWithoutIndex(range) {
	  return {
	    start: range.start,
	    end: range.end
	  };
	}

	/**
	 * Sort function to sort ranges by index.
	 * @private
	 */

	function sortByRangeIndex(a, b) {
	  return a.index - b.index;
	}

	/**
	 * Sort function to sort ranges by start position.
	 * @private
	 */

	function sortByRangeStart(a, b) {
	  return a.start - b.start;
	}

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * proxy-addr
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 */

	module.exports = proxyaddr;
	module.exports.all = alladdrs;
	module.exports.compile = compile;

	/**
	 * Module dependencies.
	 */

	var forwarded = __webpack_require__(278);
	var ipaddr = __webpack_require__(279);

	/**
	 * Variables.
	 */

	var digitre = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;

	/**
	 * Pre-defined IP ranges.
	 */

	var ipranges = {
	  linklocal: ['169.254.0.0/16', 'fe80::/10'],
	  loopback: ['127.0.0.1/8', '::1/128'],
	  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
	};

	/**
	 * Get all addresses in the request, optionally stopping
	 * at the first untrusted.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} [trust]
	 * @api public
	 */

	function alladdrs(req, trust) {
	  // get addresses
	  var addrs = forwarded(req);

	  if (!trust) {
	    // Return all addresses
	    return addrs;
	  }

	  if (typeof trust !== 'function') {
	    trust = compile(trust);
	  }

	  for (var i = 0; i < addrs.length - 1; i++) {
	    if (trust(addrs[i], i)) continue;

	    addrs.length = i + 1;
	  }

	  return addrs;
	}

	/**
	 * Compile argument into trust function.
	 *
	 * @param {Array|String} val
	 * @api private
	 */

	function compile(val) {
	  if (!val) {
	    throw new TypeError('argument is required');
	  }

	  var trust = typeof val === 'string' ? [val] : val;

	  if (!Array.isArray(trust)) {
	    throw new TypeError('unsupported trust argument');
	  }

	  for (var i = 0; i < trust.length; i++) {
	    val = trust[i];

	    if (!ipranges.hasOwnProperty(val)) {
	      continue;
	    }

	    // Splice in pre-defined range
	    val = ipranges[val];
	    trust.splice.apply(trust, [i, 1].concat(val));
	    i += val.length - 1;
	  }

	  return compileTrust(compileRangeSubnets(trust));
	}

	/**
	 * Compile `arr` elements into range subnets.
	 *
	 * @param {Array} arr
	 * @api private
	 */

	function compileRangeSubnets(arr) {
	  var rangeSubnets = new Array(arr.length);

	  for (var i = 0; i < arr.length; i++) {
	    rangeSubnets[i] = parseipNotation(arr[i]);
	  }

	  return rangeSubnets;
	}

	/**
	 * Compile range subnet array into trust function.
	 *
	 * @param {Array} rangeSubnets
	 * @api private
	 */

	function compileTrust(rangeSubnets) {
	  // Return optimized function based on length
	  var len = rangeSubnets.length;
	  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
	}

	/**
	 * Parse IP notation string into range subnet.
	 *
	 * @param {String} note
	 * @api private
	 */

	function parseipNotation(note) {
	  var pos = note.lastIndexOf('/');
	  var str = pos !== -1 ? note.substring(0, pos) : note;

	  if (!isip(str)) {
	    throw new TypeError('invalid IP address: ' + str);
	  }

	  var ip = parseip(str);

	  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
	    // Store as IPv4
	    ip = ip.toIPv4Address();
	  }

	  var max = ip.kind() === 'ipv6' ? 128 : 32;

	  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;

	  if (range === null) {
	    range = max;
	  } else if (digitre.test(range)) {
	    range = parseInt(range, 10);
	  } else if (ip.kind() === 'ipv4' && isip(range)) {
	    range = parseNetmask(range);
	  } else {
	    range = null;
	  }

	  if (range <= 0 || range > max) {
	    throw new TypeError('invalid range on address: ' + note);
	  }

	  return [ip, range];
	}

	/**
	 * Parse netmask string into CIDR range.
	 *
	 * @param {String} netmask
	 * @api private
	 */

	function parseNetmask(netmask) {
	  var ip = parseip(netmask);
	  var kind = ip.kind();

	  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;
	}

	/**
	 * Determine address of proxied request.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} trust
	 * @api public
	 */

	function proxyaddr(req, trust) {
	  if (!req) {
	    throw new TypeError('req argument is required');
	  }

	  if (!trust) {
	    throw new TypeError('trust argument is required');
	  }

	  var addrs = alladdrs(req, trust);
	  var addr = addrs[addrs.length - 1];

	  return addr;
	}

	/**
	 * Static trust function to trust nothing.
	 *
	 * @api private
	 */

	function trustNone() {
	  return false;
	}

	/**
	 * Compile trust function for multiple subnets.
	 *
	 * @param {Array} subnets
	 * @api private
	 */

	function trustMulti(subnets) {
	  return function trust(addr) {
	    if (!isip(addr)) return false;

	    var ip = parseip(addr);
	    var ipconv;
	    var kind = ip.kind();

	    for (var i = 0; i < subnets.length; i++) {
	      var subnet = subnets[i];
	      var subnetip = subnet[0];
	      var subnetkind = subnetip.kind();
	      var subnetrange = subnet[1];
	      var trusted = ip;

	      if (kind !== subnetkind) {
	        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
	          // Incompatible IP addresses
	          continue;
	        }

	        if (!ipconv) {
	          // Convert IP to match subnet IP kind
	          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
	        }

	        trusted = ipconv;
	      }

	      if (trusted.match(subnetip, subnetrange)) {
	        return true;
	      }
	    }

	    return false;
	  };
	}

	/**
	 * Compile trust function for single subnet.
	 *
	 * @param {Object} subnet
	 * @api private
	 */

	function trustSingle(subnet) {
	  var subnetip = subnet[0];
	  var subnetkind = subnetip.kind();
	  var subnetisipv4 = subnetkind === 'ipv4';
	  var subnetrange = subnet[1];

	  return function trust(addr) {
	    if (!isip(addr)) return false;

	    var ip = parseip(addr);
	    var kind = ip.kind();

	    if (kind !== subnetkind) {
	      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
	        // Incompatible IP addresses
	        return false;
	      }

	      // Convert IP to match subnet IP kind
	      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
	    }

	    return ip.match(subnetip, subnetrange);
	  };
	}

/***/ },
/* 278 */
/***/ function(module, exports) {

	'use strict';

	/*!
	 * forwarded
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 */

	module.exports = forwarded;

	/**
	 * Get all addresses in the request, using the `X-Forwarded-For` header.
	 *
	 * @param {Object} req
	 * @api public
	 */

	function forwarded(req) {
	  if (!req) {
	    throw new TypeError('argument req is required');
	  }

	  // simple header parsing
	  var proxyAddrs = (req.headers['x-forwarded-for'] || '').split(/ *, */).filter(Boolean).reverse();
	  var socketAddr = req.connection.remoteAddress;
	  var addrs = [socketAddr].concat(proxyAddrs);

	  // return all addresses
	  return addrs;
	}

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	(function () {
	  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

	  ipaddr = {};

	  root = this;

	  if (typeof module !== "undefined" && module !== null && module.exports) {
	    module.exports = ipaddr;
	  } else {
	    root['ipaddr'] = ipaddr;
	  }

	  matchCIDR = function matchCIDR(first, second, partSize, cidrBits) {
	    var part, shift;
	    if (first.length !== second.length) {
	      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
	    }
	    part = 0;
	    while (cidrBits > 0) {
	      shift = partSize - cidrBits;
	      if (shift < 0) {
	        shift = 0;
	      }
	      if (first[part] >> shift !== second[part] >> shift) {
	        return false;
	      }
	      cidrBits -= partSize;
	      part += 1;
	    }
	    return true;
	  };

	  ipaddr.subnetMatch = function (address, rangeList, defaultName) {
	    var rangeName, rangeSubnets, subnet, _i, _len;
	    if (defaultName == null) {
	      defaultName = 'unicast';
	    }
	    for (rangeName in rangeList) {
	      rangeSubnets = rangeList[rangeName];
	      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
	        rangeSubnets = [rangeSubnets];
	      }
	      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
	        subnet = rangeSubnets[_i];
	        if (address.match.apply(address, subnet)) {
	          return rangeName;
	        }
	      }
	    }
	    return defaultName;
	  };

	  ipaddr.IPv4 = function () {
	    function IPv4(octets) {
	      var octet, _i, _len;
	      if (octets.length !== 4) {
	        throw new Error("ipaddr: ipv4 octet count should be 4");
	      }
	      for (_i = 0, _len = octets.length; _i < _len; _i++) {
	        octet = octets[_i];
	        if (!(0 <= octet && octet <= 255)) {
	          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
	        }
	      }
	      this.octets = octets;
	    }

	    IPv4.prototype.kind = function () {
	      return 'ipv4';
	    };

	    IPv4.prototype.toString = function () {
	      return this.octets.join(".");
	    };

	    IPv4.prototype.toByteArray = function () {
	      return this.octets.slice(0);
	    };

	    IPv4.prototype.match = function (other, cidrRange) {
	      var _ref;
	      if (cidrRange === void 0) {
	        _ref = other, other = _ref[0], cidrRange = _ref[1];
	      }
	      if (other.kind() !== 'ipv4') {
	        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
	      }
	      return matchCIDR(this.octets, other.octets, 8, cidrRange);
	    };

	    IPv4.prototype.SpecialRanges = {
	      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
	      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
	      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
	      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
	      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
	      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
	      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
	    };

	    IPv4.prototype.range = function () {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };

	    IPv4.prototype.toIPv4MappedAddress = function () {
	      return ipaddr.IPv6.parse("::ffff:" + this.toString());
	    };

	    IPv4.prototype.prefixLengthFromSubnetMask = function () {
	      var cidr, i, octet, stop, zeros, zerotable, _i;
	      zerotable = {
	        0: 8,
	        128: 7,
	        192: 6,
	        224: 5,
	        240: 4,
	        248: 3,
	        252: 2,
	        254: 1,
	        255: 0
	      };
	      cidr = 0;
	      stop = false;
	      for (i = _i = 3; _i >= 0; i = _i += -1) {
	        octet = this.octets[i];
	        if (octet in zerotable) {
	          zeros = zerotable[octet];
	          if (stop && zeros !== 0) {
	            return null;
	          }
	          if (zeros !== 8) {
	            stop = true;
	          }
	          cidr += zeros;
	        } else {
	          return null;
	        }
	      }
	      return 32 - cidr;
	    };

	    return IPv4;
	  }();

	  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

	  ipv4Regexes = {
	    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
	    longValue: new RegExp("^" + ipv4Part + "$", 'i')
	  };

	  ipaddr.IPv4.parser = function (string) {
	    var match, parseIntAuto, part, shift, value;
	    parseIntAuto = function parseIntAuto(string) {
	      if (string[0] === "0" && string[1] !== "x") {
	        return parseInt(string, 8);
	      } else {
	        return parseInt(string);
	      }
	    };
	    if (match = string.match(ipv4Regexes.fourOctet)) {
	      return function () {
	        var _i, _len, _ref, _results;
	        _ref = match.slice(1, 6);
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(parseIntAuto(part));
	        }
	        return _results;
	      }();
	    } else if (match = string.match(ipv4Regexes.longValue)) {
	      value = parseIntAuto(match[1]);
	      if (value > 0xffffffff || value < 0) {
	        throw new Error("ipaddr: address outside defined range");
	      }
	      return function () {
	        var _i, _results;
	        _results = [];
	        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
	          _results.push(value >> shift & 0xff);
	        }
	        return _results;
	      }().reverse();
	    } else {
	      return null;
	    }
	  };

	  ipaddr.IPv6 = function () {
	    function IPv6(parts) {
	      var i, part, _i, _j, _len, _ref;
	      if (parts.length === 16) {
	        this.parts = [];
	        for (i = _i = 0; _i <= 14; i = _i += 2) {
	          this.parts.push(parts[i] << 8 | parts[i + 1]);
	        }
	      } else if (parts.length === 8) {
	        this.parts = parts;
	      } else {
	        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
	      }
	      _ref = this.parts;
	      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
	        part = _ref[_j];
	        if (!(0 <= part && part <= 0xffff)) {
	          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
	        }
	      }
	    }

	    IPv6.prototype.kind = function () {
	      return 'ipv6';
	    };

	    IPv6.prototype.toString = function () {
	      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
	      stringParts = function () {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }.call(this);
	      compactStringParts = [];
	      pushPart = function pushPart(part) {
	        return compactStringParts.push(part);
	      };
	      state = 0;
	      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
	        part = stringParts[_i];
	        switch (state) {
	          case 0:
	            if (part === '0') {
	              pushPart('');
	            } else {
	              pushPart(part);
	            }
	            state = 1;
	            break;
	          case 1:
	            if (part === '0') {
	              state = 2;
	            } else {
	              pushPart(part);
	            }
	            break;
	          case 2:
	            if (part !== '0') {
	              pushPart('');
	              pushPart(part);
	              state = 3;
	            }
	            break;
	          case 3:
	            pushPart(part);
	        }
	      }
	      if (state === 2) {
	        pushPart('');
	        pushPart('');
	      }
	      return compactStringParts.join(":");
	    };

	    IPv6.prototype.toByteArray = function () {
	      var bytes, part, _i, _len, _ref;
	      bytes = [];
	      _ref = this.parts;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        bytes.push(part >> 8);
	        bytes.push(part & 0xff);
	      }
	      return bytes;
	    };

	    IPv6.prototype.toNormalizedString = function () {
	      var part;
	      return function () {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }.call(this).join(":");
	    };

	    IPv6.prototype.match = function (other, cidrRange) {
	      var _ref;
	      if (cidrRange === void 0) {
	        _ref = other, other = _ref[0], cidrRange = _ref[1];
	      }
	      if (other.kind() !== 'ipv6') {
	        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
	      }
	      return matchCIDR(this.parts, other.parts, 16, cidrRange);
	    };

	    IPv6.prototype.SpecialRanges = {
	      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
	      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
	      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
	      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
	      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
	      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
	      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
	      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
	      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
	      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
	      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
	    };

	    IPv6.prototype.range = function () {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };

	    IPv6.prototype.isIPv4MappedAddress = function () {
	      return this.range() === 'ipv4Mapped';
	    };

	    IPv6.prototype.toIPv4Address = function () {
	      var high, low, _ref;
	      if (!this.isIPv4MappedAddress()) {
	        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
	      }
	      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
	      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
	    };

	    return IPv6;
	  }();

	  ipv6Part = "(?:[0-9a-f]+::?)+";

	  ipv6Regexes = {
	    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
	    transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
	  };

	  expandIPv6 = function expandIPv6(string, parts) {
	    var colonCount, lastColon, part, replacement, replacementCount;
	    if (string.indexOf('::') !== string.lastIndexOf('::')) {
	      return null;
	    }
	    colonCount = 0;
	    lastColon = -1;
	    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
	      colonCount++;
	    }
	    if (string.substr(0, 2) === '::') {
	      colonCount--;
	    }
	    if (string.substr(-2, 2) === '::') {
	      colonCount--;
	    }
	    if (colonCount > parts) {
	      return null;
	    }
	    replacementCount = parts - colonCount;
	    replacement = ':';
	    while (replacementCount--) {
	      replacement += '0:';
	    }
	    string = string.replace('::', replacement);
	    if (string[0] === ':') {
	      string = string.slice(1);
	    }
	    if (string[string.length - 1] === ':') {
	      string = string.slice(0, -1);
	    }
	    return function () {
	      var _i, _len, _ref, _results;
	      _ref = string.split(":");
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        _results.push(parseInt(part, 16));
	      }
	      return _results;
	    }();
	  };

	  ipaddr.IPv6.parser = function (string) {
	    var match, octet, octets, parts, _i, _len;
	    if (string.match(ipv6Regexes['native'])) {
	      return expandIPv6(string, 8);
	    } else if (match = string.match(ipv6Regexes['transitional'])) {
	      parts = expandIPv6(match[1].slice(0, -1), 6);
	      if (parts) {
	        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
	        for (_i = 0, _len = octets.length; _i < _len; _i++) {
	          octet = octets[_i];
	          if (!(0 <= octet && octet <= 255)) {
	            return null;
	          }
	        }
	        parts.push(octets[0] << 8 | octets[1]);
	        parts.push(octets[2] << 8 | octets[3]);
	        return parts;
	      }
	    }
	    return null;
	  };

	  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function (string) {
	    return this.parser(string) !== null;
	  };

	  ipaddr.IPv4.isValid = function (string) {
	    var e;
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };

	  ipaddr.IPv6.isValid = function (string) {
	    var e;
	    if (typeof string === "string" && string.indexOf(":") === -1) {
	      return false;
	    }
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };

	  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function (string) {
	    var parts;
	    parts = this.parser(string);
	    if (parts === null) {
	      throw new Error("ipaddr: string is not formatted like ip address");
	    }
	    return new this(parts);
	  };

	  ipaddr.IPv4.parseCIDR = function (string) {
	    var maskLength, match;
	    if (match = string.match(/^(.+)\/(\d+)$/)) {
	      maskLength = parseInt(match[2]);
	      if (maskLength >= 0 && maskLength <= 32) {
	        return [this.parse(match[1]), maskLength];
	      }
	    }
	    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
	  };

	  ipaddr.IPv6.parseCIDR = function (string) {
	    var maskLength, match;
	    if (match = string.match(/^(.+)\/(\d+)$/)) {
	      maskLength = parseInt(match[2]);
	      if (maskLength >= 0 && maskLength <= 128) {
	        return [this.parse(match[1]), maskLength];
	      }
	    }
	    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
	  };

	  ipaddr.isValid = function (string) {
	    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
	  };

	  ipaddr.parse = function (string) {
	    if (ipaddr.IPv6.isValid(string)) {
	      return ipaddr.IPv6.parse(string);
	    } else if (ipaddr.IPv4.isValid(string)) {
	      return ipaddr.IPv4.parse(string);
	    } else {
	      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
	    }
	  };

	  ipaddr.parseCIDR = function (string) {
	    var e;
	    try {
	      return ipaddr.IPv6.parseCIDR(string);
	    } catch (_error) {
	      e = _error;
	      try {
	        return ipaddr.IPv4.parseCIDR(string);
	      } catch (_error) {
	        e = _error;
	        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
	      }
	    }
	  };

	  ipaddr.fromByteArray = function (bytes) {
	    var length;
	    length = bytes.length;
	    if (length === 4) {
	      return new ipaddr.IPv4(bytes);
	    } else if (length === 16) {
	      return new ipaddr.IPv6(bytes);
	    } else {
	      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
	    }
	  };

	  ipaddr.process = function (string) {
	    var addr;
	    addr = this.parse(string);
	    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
	      return addr.toIPv4Address();
	    } else {
	      return addr;
	    }
	  };
	}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(218)(module)))

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./application": 190,
		"./application.js": 190,
		"./express": 187,
		"./express.js": 187,
		"./middleware/init": 223,
		"./middleware/init.js": 223,
		"./middleware/query": 224,
		"./middleware/query.js": 224,
		"./request": 281,
		"./request.js": 281,
		"./response": 297,
		"./response.js": 297,
		"./router/index": 206,
		"./router/index.js": 206,
		"./router/layer": 209,
		"./router/layer.js": 209,
		"./router/route": 207,
		"./router/route.js": 207,
		"./utils": 231,
		"./utils.js": 231,
		"./view": 229,
		"./view.js": 229
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 280;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var accepts = __webpack_require__(282);
	var deprecate = __webpack_require__(214)('express');
	var isIP = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).isIP;
	var typeis = __webpack_require__(291);
	var http = __webpack_require__(293);
	var fresh = __webpack_require__(273);
	var parseRange = __webpack_require__(276);
	var parse = __webpack_require__(215);
	var proxyaddr = __webpack_require__(277);

	/**
	 * Request prototype.
	 */

	var req = exports = module.exports = {
	  __proto__: http.IncomingMessage.prototype
	};

	/**
	 * Return request header.
	 *
	 * The `Referrer` header field is special-cased,
	 * both `Referrer` and `Referer` are interchangeable.
	 *
	 * Examples:
	 *
	 *     req.get('Content-Type');
	 *     // => "text/plain"
	 *
	 *     req.get('content-type');
	 *     // => "text/plain"
	 *
	 *     req.get('Something');
	 *     // => undefined
	 *
	 * Aliased as `req.header()`.
	 *
	 * @param {String} name
	 * @return {String}
	 * @public
	 */

	req.get = req.header = function header(name) {
	  if (!name) {
	    throw new TypeError('name argument is required to req.get');
	  }

	  if (typeof name !== 'string') {
	    throw new TypeError('name must be a string to req.get');
	  }

	  var lc = name.toLowerCase();

	  switch (lc) {
	    case 'referer':
	    case 'referrer':
	      return this.headers.referrer || this.headers.referer;
	    default:
	      return this.headers[lc];
	  }
	};

	/**
	 * To do: update docs.
	 *
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single MIME type string
	 * such as "application/json", an extension name
	 * such as "json", a comma-delimited list such as "json, html, text/plain",
	 * an argument list such as `"json", "html", "text/plain"`,
	 * or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given, the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     req.accepts('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('html');
	 *     // => "html"
	 *     req.accepts('text/html');
	 *     // => "text/html"
	 *     req.accepts('json, text');
	 *     // => "json"
	 *     req.accepts('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('image/png');
	 *     req.accepts('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     req.accepts(['html', 'json']);
	 *     req.accepts('html', 'json');
	 *     req.accepts('html, json');
	 *     // => "json"
	 *
	 * @param {String|Array} type(s)
	 * @return {String|Array|Boolean}
	 * @public
	 */

	req.accepts = function () {
	  var accept = accepts(this);
	  return accept.types.apply(accept, arguments);
	};

	/**
	 * Check if the given `encoding`s are accepted.
	 *
	 * @param {String} ...encoding
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsEncodings = function () {
	  var accept = accepts(this);
	  return accept.encodings.apply(accept, arguments);
	};

	req.acceptsEncoding = deprecate.function(req.acceptsEncodings, 'req.acceptsEncoding: Use acceptsEncodings instead');

	/**
	 * Check if the given `charset`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...charset
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsCharsets = function () {
	  var accept = accepts(this);
	  return accept.charsets.apply(accept, arguments);
	};

	req.acceptsCharset = deprecate.function(req.acceptsCharsets, 'req.acceptsCharset: Use acceptsCharsets instead');

	/**
	 * Check if the given `lang`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...lang
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsLanguages = function () {
	  var accept = accepts(this);
	  return accept.languages.apply(accept, arguments);
	};

	req.acceptsLanguage = deprecate.function(req.acceptsLanguages, 'req.acceptsLanguage: Use acceptsLanguages instead');

	/**
	 * Parse Range header field, capping to the given `size`.
	 *
	 * Unspecified ranges such as "0-" require knowledge of your resource length. In
	 * the case of a byte range this is of course the total number of bytes. If the
	 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	 * and `-2` when syntactically invalid.
	 *
	 * When ranges are returned, the array has a "type" property which is the type of
	 * range that is required (most commonly, "bytes"). Each array element is an object
	 * with a "start" and "end" property for the portion of the range.
	 *
	 * The "combine" option can be set to `true` and overlapping & adjacent ranges
	 * will be combined into a single range.
	 *
	 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	 * should respond with 4 users when available, not 3.
	 *
	 * @param {number} size
	 * @param {object} [options]
	 * @param {boolean} [options.combine=false]
	 * @return {number|array}
	 * @public
	 */

	req.range = function range(size, options) {
	  var range = this.get('Range');
	  if (!range) return;
	  return parseRange(size, range, options);
	};

	/**
	 * Return the value of param `name` when present or `defaultValue`.
	 *
	 *  - Checks route placeholders, ex: _/user/:id_
	 *  - Checks body params, ex: id=12, {"id":12}
	 *  - Checks query string params, ex: ?id=12
	 *
	 * To utilize request bodies, `req.body`
	 * should be an object. This can be done by using
	 * the `bodyParser()` middleware.
	 *
	 * @param {String} name
	 * @param {Mixed} [defaultValue]
	 * @return {String}
	 * @public
	 */

	req.param = function param(name, defaultValue) {
	  var params = this.params || {};
	  var body = this.body || {};
	  var query = this.query || {};

	  var args = arguments.length === 1 ? 'name' : 'name, default';
	  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

	  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
	  if (null != body[name]) return body[name];
	  if (null != query[name]) return query[name];

	  return defaultValue;
	};

	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains the give mime `type`.
	 *
	 * Examples:
	 *
	 *      // With Content-Type: text/html; charset=utf-8
	 *      req.is('html');
	 *      req.is('text/html');
	 *      req.is('text/*');
	 *      // => true
	 *
	 *      // When Content-Type is application/json
	 *      req.is('json');
	 *      req.is('application/json');
	 *      req.is('application/*');
	 *      // => true
	 *
	 *      req.is('html');
	 *      // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */

	req.is = function is(types) {
	  var arr = types;

	  // support flattened arguments
	  if (!Array.isArray(types)) {
	    arr = new Array(arguments.length);
	    for (var i = 0; i < arr.length; i++) {
	      arr[i] = arguments[i];
	    }
	  }

	  return typeis(this, arr);
	};

	/**
	 * Return the protocol string "http" or "https"
	 * when requested with TLS. When the "trust proxy"
	 * setting trusts the socket address, the
	 * "X-Forwarded-Proto" header field will be trusted
	 * and used if present.
	 *
	 * If you're running behind a reverse proxy that
	 * supplies https for you this may be enabled.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'protocol', function protocol() {
	  var proto = this.connection.encrypted ? 'https' : 'http';
	  var trust = this.app.get('trust proxy fn');

	  if (!trust(this.connection.remoteAddress, 0)) {
	    return proto;
	  }

	  // Note: X-Forwarded-Proto is normally only ever a
	  //       single value, but this is to be safe.
	  proto = this.get('X-Forwarded-Proto') || proto;
	  return proto.split(/\s*,\s*/)[0];
	});

	/**
	 * Short-hand for:
	 *
	 *    req.protocol === 'https'
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'secure', function secure() {
	  return this.protocol === 'https';
	});

	/**
	 * Return the remote address from the trusted proxy.
	 *
	 * The is the remote address on the socket unless
	 * "trust proxy" is set.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'ip', function ip() {
	  var trust = this.app.get('trust proxy fn');
	  return proxyaddr(this, trust);
	});

	/**
	 * When "trust proxy" is set, trusted proxy addresses + client.
	 *
	 * For example if the value were "client, proxy1, proxy2"
	 * you would receive the array `["client", "proxy1", "proxy2"]`
	 * where "proxy2" is the furthest down-stream and "proxy1" and
	 * "proxy2" were trusted.
	 *
	 * @return {Array}
	 * @public
	 */

	defineGetter(req, 'ips', function ips() {
	  var trust = this.app.get('trust proxy fn');
	  var addrs = proxyaddr.all(this, trust);
	  return addrs.slice(1).reverse();
	});

	/**
	 * Return subdomains as an array.
	 *
	 * Subdomains are the dot-separated parts of the host before the main domain of
	 * the app. By default, the domain of the app is assumed to be the last two
	 * parts of the host. This can be changed by setting "subdomain offset".
	 *
	 * For example, if the domain is "tobi.ferrets.example.com":
	 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	 *
	 * @return {Array}
	 * @public
	 */

	defineGetter(req, 'subdomains', function subdomains() {
	  var hostname = this.hostname;

	  if (!hostname) return [];

	  var offset = this.app.get('subdomain offset');
	  var subdomains = !isIP(hostname) ? hostname.split('.').reverse() : [hostname];

	  return subdomains.slice(offset);
	});

	/**
	 * Short-hand for `url.parse(req.url).pathname`.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'path', function path() {
	  return parse(this).pathname;
	});

	/**
	 * Parse the "Host" header field to a hostname.
	 *
	 * When the "trust proxy" setting trusts the socket
	 * address, the "X-Forwarded-Host" header field will
	 * be trusted.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'hostname', function hostname() {
	  var trust = this.app.get('trust proxy fn');
	  var host = this.get('X-Forwarded-Host');

	  if (!host || !trust(this.connection.remoteAddress, 0)) {
	    host = this.get('Host');
	  }

	  if (!host) return;

	  // IPv6 literal support
	  var offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
	  var index = host.indexOf(':', offset);

	  return index !== -1 ? host.substring(0, index) : host;
	});

	// TODO: change req.host to return host in next major

	defineGetter(req, 'host', deprecate.function(function host() {
	  return this.hostname;
	}, 'req.host: Use req.hostname instead'));

	/**
	 * Check if the request is fresh, aka
	 * Last-Modified and/or the ETag
	 * still match.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'fresh', function () {
	  var method = this.method;
	  var s = this.res.statusCode;

	  // GET or HEAD for weak freshness validation only
	  if ('GET' !== method && 'HEAD' !== method) return false;

	  // 2xx or 304 as per rfc2616 14.26
	  if (s >= 200 && s < 300 || 304 === s) {
	    return fresh(this.headers, this.res._headers || {});
	  }

	  return false;
	});

	/**
	 * Check if the request is stale, aka
	 * "Last-Modified" and / or the "ETag" for the
	 * resource has changed.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'stale', function stale() {
	  return !this.fresh;
	});

	/**
	 * Check if the request was an _XMLHttpRequest_.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'xhr', function xhr() {
	  var val = this.get('X-Requested-With') || '';
	  return val.toLowerCase() === 'xmlhttprequest';
	});

	/**
	 * Helper function for creating a getter on an object.
	 *
	 * @param {Object} obj
	 * @param {String} name
	 * @param {Function} getter
	 * @private
	 */
	function defineGetter(obj, name, getter) {
	  Object.defineProperty(obj, name, {
	    configurable: true,
	    enumerable: true,
	    get: getter
	  });
	};

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * accepts
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var Negotiator = __webpack_require__(283);
	var mime = __webpack_require__(288);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Accepts;

	/**
	 * Create a new Accepts object for the given req.
	 *
	 * @param {object} req
	 * @public
	 */

	function Accepts(req) {
	  if (!(this instanceof Accepts)) return new Accepts(req);

	  this.headers = req.headers;
	  this.negotiator = new Negotiator(req);
	}

	/**
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single mime type string
	 * such as "application/json", the extension name
	 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     this.types('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('html');
	 *     // => "html"
	 *     this.types('text/html');
	 *     // => "text/html"
	 *     this.types('json', 'text');
	 *     // => "json"
	 *     this.types('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('image/png');
	 *     this.types('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     this.types(['html', 'json']);
	 *     this.types('html', 'json');
	 *     // => "json"
	 *
	 * @param {String|Array} types...
	 * @return {String|Array|Boolean}
	 * @public
	 */

	Accepts.prototype.type = Accepts.prototype.types = function (types_) {
	  var types = types_;

	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length);
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i];
	    }
	  }

	  // no types, return all requested types
	  if (!types || types.length === 0) {
	    return this.negotiator.mediaTypes();
	  }

	  if (!this.headers.accept) return types[0];
	  var mimes = types.map(extToMime);
	  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
	  var first = accepts[0];
	  if (!first) return false;
	  return types[mimes.indexOf(first)];
	};

	/**
	 * Return accepted encodings or best fit based on `encodings`.
	 *
	 * Given `Accept-Encoding: gzip, deflate`
	 * an array sorted by quality is returned:
	 *
	 *     ['gzip', 'deflate']
	 *
	 * @param {String|Array} encodings...
	 * @return {String|Array}
	 * @public
	 */

	Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
	  var encodings = encodings_;

	  // support flattened arguments
	  if (encodings && !Array.isArray(encodings)) {
	    encodings = new Array(arguments.length);
	    for (var i = 0; i < encodings.length; i++) {
	      encodings[i] = arguments[i];
	    }
	  }

	  // no encodings, return all requested encodings
	  if (!encodings || encodings.length === 0) {
	    return this.negotiator.encodings();
	  }

	  return this.negotiator.encodings(encodings)[0] || false;
	};

	/**
	 * Return accepted charsets or best fit based on `charsets`.
	 *
	 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	 * an array sorted by quality is returned:
	 *
	 *     ['utf-8', 'utf-7', 'iso-8859-1']
	 *
	 * @param {String|Array} charsets...
	 * @return {String|Array}
	 * @public
	 */

	Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
	  var charsets = charsets_;

	  // support flattened arguments
	  if (charsets && !Array.isArray(charsets)) {
	    charsets = new Array(arguments.length);
	    for (var i = 0; i < charsets.length; i++) {
	      charsets[i] = arguments[i];
	    }
	  }

	  // no charsets, return all requested charsets
	  if (!charsets || charsets.length === 0) {
	    return this.negotiator.charsets();
	  }

	  return this.negotiator.charsets(charsets)[0] || false;
	};

	/**
	 * Return accepted languages or best fit based on `langs`.
	 *
	 * Given `Accept-Language: en;q=0.8, es, pt`
	 * an array sorted by quality is returned:
	 *
	 *     ['es', 'pt', 'en']
	 *
	 * @param {String|Array} langs...
	 * @return {Array|String}
	 * @public
	 */

	Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
	  var languages = languages_;

	  // support flattened arguments
	  if (languages && !Array.isArray(languages)) {
	    languages = new Array(arguments.length);
	    for (var i = 0; i < languages.length; i++) {
	      languages[i] = arguments[i];
	    }
	  }

	  // no languages, return all requested languages
	  if (!languages || languages.length === 0) {
	    return this.negotiator.languages();
	  }

	  return this.negotiator.languages(languages)[0] || false;
	};

	/**
	 * Convert extnames to mime.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */

	function extToMime(type) {
	  return type.indexOf('/') === -1 ? mime.lookup(type) : type;
	}

	/**
	 * Check if mime is valid.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */

	function validMime(type) {
	  return typeof type === 'string';
	}

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * negotiator
	 * Copyright(c) 2012 Federico Romero
	 * Copyright(c) 2012-2014 Isaac Z. Schlueter
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Cached loaded submodules.
	 * @private
	 */

	var modules = Object.create(null);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;

	/**
	 * Create a Negotiator instance from a request.
	 * @param {object} request
	 * @public
	 */

	function Negotiator(request) {
	  if (!(this instanceof Negotiator)) {
	    return new Negotiator(request);
	  }

	  this.request = request;
	}

	Negotiator.prototype.charset = function charset(available) {
	  var set = this.charsets(available);
	  return set && set[0];
	};

	Negotiator.prototype.charsets = function charsets(available) {
	  var preferredCharsets = loadModule('charset').preferredCharsets;
	  return preferredCharsets(this.request.headers['accept-charset'], available);
	};

	Negotiator.prototype.encoding = function encoding(available) {
	  var set = this.encodings(available);
	  return set && set[0];
	};

	Negotiator.prototype.encodings = function encodings(available) {
	  var preferredEncodings = loadModule('encoding').preferredEncodings;
	  return preferredEncodings(this.request.headers['accept-encoding'], available);
	};

	Negotiator.prototype.language = function language(available) {
	  var set = this.languages(available);
	  return set && set[0];
	};

	Negotiator.prototype.languages = function languages(available) {
	  var preferredLanguages = loadModule('language').preferredLanguages;
	  return preferredLanguages(this.request.headers['accept-language'], available);
	};

	Negotiator.prototype.mediaType = function mediaType(available) {
	  var set = this.mediaTypes(available);
	  return set && set[0];
	};

	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
	  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
	  return preferredMediaTypes(this.request.headers.accept, available);
	};

	// Backwards compatibility
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

	/**
	 * Load the given module.
	 * @private
	 */

	function loadModule(moduleName) {
	  var module = modules[moduleName];

	  if (module !== undefined) {
	    return module;
	  }

	  // This uses a switch for static require analysis
	  switch (moduleName) {
	    case 'charset':
	      module = __webpack_require__(284);
	      break;
	    case 'encoding':
	      module = __webpack_require__(285);
	      break;
	    case 'language':
	      module = __webpack_require__(286);
	      break;
	    case 'mediaType':
	      module = __webpack_require__(287);
	      break;
	    default:
	      throw new Error('Cannot find module \'' + moduleName + '\'');
	  }

	  // Store to prevent invoking require()
	  modules[moduleName] = module;

	  return module;
	}

/***/ },
/* 284 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Charset header.
	 * @private
	 */

	function parseAcceptCharset(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var charset = parseCharset(accepts[i].trim(), i);

	    if (charset) {
	      accepts[j++] = charset;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a charset from the Accept-Charset header.
	 * @private
	 */

	function parseCharset(str, i) {
	  var match = simpleCharsetRegExp.exec(str);
	  if (!match) return null;

	  var charset = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var i = 0; i < params.length; i++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    charset: charset,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a charset.
	 * @private
	 */

	function getCharsetPriority(charset, accepted, index) {
	  var priority = { o: -1, q: 0, s: 0 };

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(charset, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the charset.
	 * @private
	 */

	function specify(charset, spec, index) {
	  var s = 0;
	  if (spec.charset.toLowerCase() === charset.toLowerCase()) {
	    s |= 1;
	  } else if (spec.charset !== '*') {
	    return null;
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  };
	}

	/**
	 * Get the preferred charsets from an Accept-Charset header.
	 * @public
	 */

	function preferredCharsets(accept, provided) {
	  // RFC 2616 sec 14.2: no header = *
	  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all charsets
	    return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getCharsetPriority(type, accepts, index);
	  });

	  // sorted list of accepted charsets
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}

	/**
	 * Get full charset string.
	 * @private
	 */

	function getFullCharset(spec) {
	  return spec.charset;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

/***/ },
/* 285 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Encoding header.
	 * @private
	 */

	function parseAcceptEncoding(accept) {
	  var accepts = accept.split(',');
	  var hasIdentity = false;
	  var minQuality = 1;

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var encoding = parseEncoding(accepts[i].trim(), i);

	    if (encoding) {
	      accepts[j++] = encoding;
	      hasIdentity = hasIdentity || specify('identity', encoding);
	      minQuality = Math.min(minQuality, encoding.q || 1);
	    }
	  }

	  if (!hasIdentity) {
	    /*
	     * If identity doesn't explicitly appear in the accept-encoding header,
	     * it's added to the list of acceptable encoding with the lowest q
	     */
	    accepts[j++] = {
	      encoding: 'identity',
	      q: minQuality,
	      i: i
	    };
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse an encoding from the Accept-Encoding header.
	 * @private
	 */

	function parseEncoding(str, i) {
	  var match = simpleEncodingRegExp.exec(str);
	  if (!match) return null;

	  var encoding = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var i = 0; i < params.length; i++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    encoding: encoding,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of an encoding.
	 * @private
	 */

	function getEncodingPriority(encoding, accepted, index) {
	  var priority = { o: -1, q: 0, s: 0 };

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(encoding, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the encoding.
	 * @private
	 */

	function specify(encoding, spec, index) {
	  var s = 0;
	  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
	    s |= 1;
	  } else if (spec.encoding !== '*') {
	    return null;
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  };
	};

	/**
	 * Get the preferred encodings from an Accept-Encoding header.
	 * @public
	 */

	function preferredEncodings(accept, provided) {
	  var accepts = parseAcceptEncoding(accept || '');

	  if (!provided) {
	    // sorted list of all encodings
	    return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getEncodingPriority(type, accepts, index);
	  });

	  // sorted list of accepted encodings
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}

	/**
	 * Get full encoding string.
	 * @private
	 */

	function getFullEncoding(spec) {
	  return spec.encoding;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

/***/ },
/* 286 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Language header.
	 * @private
	 */

	function parseAcceptLanguage(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var langauge = parseLanguage(accepts[i].trim(), i);

	    if (langauge) {
	      accepts[j++] = langauge;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a language from the Accept-Language header.
	 * @private
	 */

	function parseLanguage(str, i) {
	  var match = simpleLanguageRegExp.exec(str);
	  if (!match) return null;

	  var prefix = match[1],
	      suffix = match[2],
	      full = prefix;

	  if (suffix) full += "-" + suffix;

	  var q = 1;
	  if (match[3]) {
	    var params = match[3].split(';');
	    for (var i = 0; i < params.length; i++) {
	      var p = params[i].split('=');
	      if (p[0] === 'q') q = parseFloat(p[1]);
	    }
	  }

	  return {
	    prefix: prefix,
	    suffix: suffix,
	    q: q,
	    i: i,
	    full: full
	  };
	}

	/**
	 * Get the priority of a language.
	 * @private
	 */

	function getLanguagePriority(language, accepted, index) {
	  var priority = { o: -1, q: 0, s: 0 };

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(language, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the language.
	 * @private
	 */

	function specify(language, spec, index) {
	  var p = parseLanguage(language);
	  if (!p) return null;
	  var s = 0;
	  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
	    s |= 4;
	  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
	    s |= 2;
	  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
	    s |= 1;
	  } else if (spec.full !== '*') {
	    return null;
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  };
	};

	/**
	 * Get the preferred languages from an Accept-Language header.
	 * @public
	 */

	function preferredLanguages(accept, provided) {
	  // RFC 2616 sec 14.4: no header = *
	  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all languages
	    return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getLanguagePriority(type, accepts, index);
	  });

	  // sorted list of accepted languages
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}

	/**
	 * Get full language string.
	 * @private
	 */

	function getFullLanguage(spec) {
	  return spec.full;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

/***/ },
/* 287 */
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept header.
	 * @private
	 */

	function parseAccept(accept) {
	  var accepts = splitMediaTypes(accept);

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var mediaType = parseMediaType(accepts[i].trim(), i);

	    if (mediaType) {
	      accepts[j++] = mediaType;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a media type from the Accept header.
	 * @private
	 */

	function parseMediaType(str, i) {
	  var match = simpleMediaTypeRegExp.exec(str);
	  if (!match) return null;

	  var params = Object.create(null);
	  var q = 1;
	  var subtype = match[2];
	  var type = match[1];

	  if (match[3]) {
	    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

	    for (var j = 0; j < kvps.length; j++) {
	      var pair = kvps[j];
	      var key = pair[0].toLowerCase();
	      var val = pair[1];

	      // get the value, unwrapping quotes
	      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;

	      if (key === 'q') {
	        q = parseFloat(value);
	        break;
	      }

	      // store parameter
	      params[key] = value;
	    }
	  }

	  return {
	    type: type,
	    subtype: subtype,
	    params: params,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a media type.
	 * @private
	 */

	function getMediaTypePriority(type, accepted, index) {
	  var priority = { o: -1, q: 0, s: 0 };

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(type, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the media type.
	 * @private
	 */

	function specify(type, spec, index) {
	  var p = parseMediaType(type);
	  var s = 0;

	  if (!p) {
	    return null;
	  }

	  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
	    s |= 4;
	  } else if (spec.type != '*') {
	    return null;
	  }

	  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
	    s |= 2;
	  } else if (spec.subtype != '*') {
	    return null;
	  }

	  var keys = Object.keys(spec.params);
	  if (keys.length > 0) {
	    if (keys.every(function (k) {
	      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
	    })) {
	      s |= 1;
	    } else {
	      return null;
	    }
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  };
	}

	/**
	 * Get the preferred media types from an Accept header.
	 * @public
	 */

	function preferredMediaTypes(accept, provided) {
	  // RFC 2616 sec 14.2: no header = */*
	  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

	  if (!provided) {
	    // sorted list of all types
	    return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getMediaTypePriority(type, accepts, index);
	  });

	  // sorted list of accepted types
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}

	/**
	 * Get full type string.
	 * @private
	 */

	function getFullType(spec) {
	  return spec.type + '/' + spec.subtype;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

	/**
	 * Count the number of quotes in a string.
	 * @private
	 */

	function quoteCount(string) {
	  var count = 0;
	  var index = 0;

	  while ((index = string.indexOf('"', index)) !== -1) {
	    count++;
	    index++;
	  }

	  return count;
	}

	/**
	 * Split a key value pair.
	 * @private
	 */

	function splitKeyValuePair(str) {
	  var index = str.indexOf('=');
	  var key;
	  var val;

	  if (index === -1) {
	    key = str;
	  } else {
	    key = str.substr(0, index);
	    val = str.substr(index + 1);
	  }

	  return [key, val];
	}

	/**
	 * Split an Accept header into media types.
	 * @private
	 */

	function splitMediaTypes(accept) {
	  var accepts = accept.split(',');

	  for (var i = 1, j = 0; i < accepts.length; i++) {
	    if (quoteCount(accepts[j]) % 2 == 0) {
	      accepts[++j] = accepts[i];
	    } else {
	      accepts[j] += ',' + accepts[i];
	    }
	  }

	  // trim accepts
	  accepts.length = j + 1;

	  return accepts;
	}

	/**
	 * Split a string of parameters.
	 * @private
	 */

	function splitParameters(str) {
	  var parameters = str.split(';');

	  for (var i = 1, j = 0; i < parameters.length; i++) {
	    if (quoteCount(parameters[j]) % 2 == 0) {
	      parameters[++j] = parameters[i];
	    } else {
	      parameters[j] += ';' + parameters[i];
	    }
	  }

	  // trim parameters
	  parameters.length = j + 1;

	  for (var i = 0; i < parameters.length; i++) {
	    parameters[i] = parameters[i].trim();
	  }

	  return parameters;
	}

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-types
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var db = __webpack_require__(289);
	var extname = __webpack_require__(230).extname;

	/**
	 * Module variables.
	 * @private
	 */

	var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/;
	var textTypeRegExp = /^text\//i;

	/**
	 * Module exports.
	 * @public
	 */

	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);

	// Populate the extensions/types maps
	populateMaps(exports.extensions, exports.types);

	/**
	 * Get the default charset for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function charset(type) {
	  if (!type || typeof type !== 'string') {
	    return false;
	  }

	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type);
	  var mime = match && db[match[1].toLowerCase()];

	  if (mime && mime.charset) {
	    return mime.charset;
	  }

	  // default text/* to utf-8
	  if (match && textTypeRegExp.test(match[1])) {
	    return 'UTF-8';
	  }

	  return false;
	}

	/**
	 * Create a full Content-Type header given a MIME type or extension.
	 *
	 * @param {string} str
	 * @return {boolean|string}
	 */

	function contentType(str) {
	  // TODO: should this even be in this module?
	  if (!str || typeof str !== 'string') {
	    return false;
	  }

	  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

	  if (!mime) {
	    return false;
	  }

	  // TODO: use content-type or other module
	  if (mime.indexOf('charset') === -1) {
	    var charset = exports.charset(mime);
	    if (charset) mime += '; charset=' + charset.toLowerCase();
	  }

	  return mime;
	}

	/**
	 * Get the default extension for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function extension(type) {
	  if (!type || typeof type !== 'string') {
	    return false;
	  }

	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type);

	  // get extensions
	  var exts = match && exports.extensions[match[1].toLowerCase()];

	  if (!exts || !exts.length) {
	    return false;
	  }

	  return exts[0];
	}

	/**
	 * Lookup the MIME type for a file path/extension.
	 *
	 * @param {string} path
	 * @return {boolean|string}
	 */

	function lookup(path) {
	  if (!path || typeof path !== 'string') {
	    return false;
	  }

	  // get the extension ("ext" or ".ext" or full path)
	  var extension = extname('x.' + path).toLowerCase().substr(1);

	  if (!extension) {
	    return false;
	  }

	  return exports.types[extension] || false;
	}

	/**
	 * Populate the extensions and types maps.
	 * @private
	 */

	function populateMaps(extensions, types) {
	  // source preference (least -> most)
	  var preference = ['nginx', 'apache', undefined, 'iana'];

	  Object.keys(db).forEach(function forEachMimeType(type) {
	    var mime = db[type];
	    var exts = mime.extensions;

	    if (!exts || !exts.length) {
	      return;
	    }

	    // mime -> extensions
	    extensions[type] = exts;

	    // extension -> mime
	    for (var i = 0; i < exts.length; i++) {
	      var extension = exts[i];

	      if (types[extension]) {
	        var from = preference.indexOf(db[types[extension]].source);
	        var to = preference.indexOf(mime.source);

	        if (types[extension] !== 'application/octet-stream' && from > to || from === to && types[extension].substr(0, 12) === 'application/') {
	          // skip the remapping
	          continue;
	        }
	      }

	      // set the extension -> mime
	      types[extension] = type;
	    }
	  });
	}

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 */

	module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./db.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

/***/ },
/* 290 */,
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * type-is
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var typer = __webpack_require__(292);
	var mime = __webpack_require__(288);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = typeofrequest;
	module.exports.is = typeis;
	module.exports.hasBody = hasbody;
	module.exports.normalize = normalize;
	module.exports.match = mimeMatch;

	/**
	 * Compare a `value` content-type with `types`.
	 * Each `type` can be an extension like `html`,
	 * a special shortcut like `multipart` or `urlencoded`,
	 * or a mime type.
	 *
	 * If no types match, `false` is returned.
	 * Otherwise, the first `type` that matches is returned.
	 *
	 * @param {String} value
	 * @param {Array} types
	 * @public
	 */

	function typeis(value, types_) {
	  var i;
	  var types = types_;

	  // remove parameters and normalize
	  var val = tryNormalizeType(value);

	  // no type or invalid
	  if (!val) {
	    return false;
	  }

	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length - 1);
	    for (i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1];
	    }
	  }

	  // no types, return the content type
	  if (!types || !types.length) {
	    return val;
	  }

	  var type;
	  for (i = 0; i < types.length; i++) {
	    if (mimeMatch(normalize(type = types[i]), val)) {
	      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
	    }
	  }

	  // no matches
	  return false;
	}

	/**
	 * Check if a request has a request body.
	 * A request with a body __must__ either have `transfer-encoding`
	 * or `content-length` headers set.
	 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	 *
	 * @param {Object} request
	 * @return {Boolean}
	 * @public
	 */

	function hasbody(req) {
	  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
	}

	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains any of the give mime `type`s.
	 * If there is no request body, `null` is returned.
	 * If there is no content type, `false` is returned.
	 * Otherwise, it returns the first `type` that matches.
	 *
	 * Examples:
	 *
	 *     // With Content-Type: text/html; charset=utf-8
	 *     this.is('html'); // => 'html'
	 *     this.is('text/html'); // => 'text/html'
	 *     this.is('text/*', 'application/json'); // => 'text/html'
	 *
	 *     // When Content-Type is application/json
	 *     this.is('json', 'urlencoded'); // => 'json'
	 *     this.is('application/json'); // => 'application/json'
	 *     this.is('html', 'application/*'); // => 'application/json'
	 *
	 *     this.is('html'); // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */

	function typeofrequest(req, types_) {
	  var types = types_;

	  // no body
	  if (!hasbody(req)) {
	    return null;
	  }

	  // support flattened arguments
	  if (arguments.length > 2) {
	    types = new Array(arguments.length - 1);
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1];
	    }
	  }

	  // request content type
	  var value = req.headers['content-type'];

	  return typeis(value, types);
	}

	/**
	 * Normalize a mime type.
	 * If it's a shorthand, expand it to a valid mime type.
	 *
	 * In general, you probably want:
	 *
	 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
	 *
	 * Then use the appropriate body parsers.
	 * These three are the most common request body types
	 * and are thus ensured to work.
	 *
	 * @param {String} type
	 * @private
	 */

	function normalize(type) {
	  if (typeof type !== 'string') {
	    // invalid type
	    return false;
	  }

	  switch (type) {
	    case 'urlencoded':
	      return 'application/x-www-form-urlencoded';
	    case 'multipart':
	      return 'multipart/*';
	  }

	  if (type[0] === '+') {
	    // "+json" -> "*/*+json" expando
	    return '*/*' + type;
	  }

	  return type.indexOf('/') === -1 ? mime.lookup(type) : type;
	}

	/**
	 * Check if `expected` mime type
	 * matches `actual` mime type with
	 * wildcard and +suffix support.
	 *
	 * @param {String} expected
	 * @param {String} actual
	 * @return {Boolean}
	 * @private
	 */

	function mimeMatch(expected, actual) {
	  // invalid type
	  if (expected === false) {
	    return false;
	  }

	  // split types
	  var actualParts = actual.split('/');
	  var expectedParts = expected.split('/');

	  // invalid format
	  if (actualParts.length !== 2 || expectedParts.length !== 2) {
	    return false;
	  }

	  // validate type
	  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
	    return false;
	  }

	  // validate suffix wildcard
	  if (expectedParts[1].substr(0, 2) === '*+') {
	    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
	  }

	  // validate subtype
	  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
	    return false;
	  }

	  return true;
	}

	/**
	 * Normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */

	function normalizeType(value) {
	  // parse the type
	  var type = typer.parse(value);

	  // remove the parameters
	  type.parameters = undefined;

	  // reformat it
	  return typer.format(type);
	}

	/**
	 * Try to normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */

	function tryNormalizeType(value) {
	  try {
	    return normalizeType(value);
	  } catch (err) {
	    return null;
	  }
	}

/***/ },
/* 292 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/*!
	 * media-typer
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

	/**
	 * Module exports.
	 */

	exports.format = format;
	exports.parse = parse;

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */

	function format(obj) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
	    throw new TypeError('argument obj is required');
	  }

	  var parameters = obj.parameters;
	  var subtype = obj.subtype;
	  var suffix = obj.suffix;
	  var type = obj.type;

	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type');
	  }

	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype');
	  }

	  // format as type/subtype
	  var string = type + '/' + subtype;

	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix');
	    }

	    string += '+' + suffix;
	  }

	  // append parameters
	  if (parameters && (typeof parameters === 'undefined' ? 'undefined' : _typeof(parameters)) === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name');
	      }

	      string += '; ' + param + '=' + qstring(parameters[param]);
	    }
	  }

	  return string;
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required');
	  }

	  // support req/res-like objects as argument
	  if ((typeof string === 'undefined' ? 'undefined' : _typeof(string)) === 'object') {
	    string = getcontenttype(string);
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string');
	  }

	  var index = string.indexOf(';');
	  var type = index !== -1 ? string.substr(0, index) : string;

	  var key;
	  var match;
	  var obj = splitType(type);
	  var params = {};
	  var value;

	  paramRegExp.lastIndex = index;

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format');
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
	    }

	    params[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format');
	  }

	  obj.parameters = params;

	  return obj;
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type');
	  }

	  if (_typeof(obj.headers) === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type'];
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val);

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str;
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value');
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"';
	}

	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */

	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase());

	  if (!match) {
	    throw new TypeError('invalid media type');
	  }

	  var type = match[1];
	  var subtype = match[2];
	  var suffix;

	  // suffix after last +
	  var index = subtype.lastIndexOf('+');
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1);
	    subtype = subtype.substr(0, index);
	  }

	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  };

	  return obj;
	}

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var http = module.exports;
	var EventEmitter = __webpack_require__(188).EventEmitter;
	var Request = __webpack_require__(294);
	var url = __webpack_require__(216);

	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params);
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }

	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }

	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;

	    var req = new Request(new xhrHttp(), params);
	    if (cb) req.on('response', cb);
	    return req;
	};

	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};

	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;

	var xhrHttp = function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    } else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    } else if (window.ActiveXObject) {
	        var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new window.ActiveXObject(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    } else {
	                        return new window.ActiveXObject(axs[i]);
	                    }
	                };
	            } catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser');
	    } else {
	        throw new Error('ajax not supported in this browser');
	    }
	}();

	http.STATUS_CODES = {
	    100: 'Continue',
	    101: 'Switching Protocols',
	    102: 'Processing', // RFC 2518, obsoleted by RFC 4918
	    200: 'OK',
	    201: 'Created',
	    202: 'Accepted',
	    203: 'Non-Authoritative Information',
	    204: 'No Content',
	    205: 'Reset Content',
	    206: 'Partial Content',
	    207: 'Multi-Status', // RFC 4918
	    300: 'Multiple Choices',
	    301: 'Moved Permanently',
	    302: 'Moved Temporarily',
	    303: 'See Other',
	    304: 'Not Modified',
	    305: 'Use Proxy',
	    307: 'Temporary Redirect',
	    400: 'Bad Request',
	    401: 'Unauthorized',
	    402: 'Payment Required',
	    403: 'Forbidden',
	    404: 'Not Found',
	    405: 'Method Not Allowed',
	    406: 'Not Acceptable',
	    407: 'Proxy Authentication Required',
	    408: 'Request Time-out',
	    409: 'Conflict',
	    410: 'Gone',
	    411: 'Length Required',
	    412: 'Precondition Failed',
	    413: 'Request Entity Too Large',
	    414: 'Request-URI Too Large',
	    415: 'Unsupported Media Type',
	    416: 'Requested Range Not Satisfiable',
	    417: 'Expectation Failed',
	    418: 'I\'m a teapot', // RFC 2324
	    422: 'Unprocessable Entity', // RFC 4918
	    423: 'Locked', // RFC 4918
	    424: 'Failed Dependency', // RFC 4918
	    425: 'Unordered Collection', // RFC 4918
	    426: 'Upgrade Required', // RFC 2817
	    428: 'Precondition Required', // RFC 6585
	    429: 'Too Many Requests', // RFC 6585
	    431: 'Request Header Fields Too Large', // RFC 6585
	    500: 'Internal Server Error',
	    501: 'Not Implemented',
	    502: 'Bad Gateway',
	    503: 'Service Unavailable',
	    504: 'Gateway Time-out',
	    505: 'HTTP Version Not Supported',
	    506: 'Variant Also Negotiates', // RFC 2295
	    507: 'Insufficient Storage', // RFC 4918
	    509: 'Bandwidth Limit Exceeded',
	    510: 'Not Extended', // RFC 2774
	    511: 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stream = __webpack_require__(239);
	var Response = __webpack_require__(295);
	var Base64 = __webpack_require__(296);
	var inherits = __webpack_require__(237);

	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];

	    self.uri = (params.protocol || 'http:') + '//' + params.host + (params.port ? ':' + params.port : '') + (params.path || '/');

	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }

	    try {
	        xhr.withCredentials = params.withCredentials;
	    } catch (e) {}

	    if (params.responseType) try {
	        xhr.responseType = params.responseType;
	    } catch (e) {}

	    xhr.open(params.method || 'GET', self.uri, true);

	    xhr.onerror = function (event) {
	        self.emit('error', new Error('Network error'));
	    };

	    self._headers = {};

	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }

	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }

	    var res = new Response();
	    res.on('close', function () {
	        self.emit('close');
	    });

	    res.on('ready', function () {
	        self.emit('response', res);
	    });

	    res.on('error', function (err) {
	        self.emit('error', err);
	    });

	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};

	inherits(Request, Stream);

	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value;
	};

	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()];
	};

	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()];
	};

	Request.prototype.write = function (s) {
	    this.body.push(s);
	};

	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};

	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);

	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        } else this.xhr.setRequestHeader(key, value);
	    }

	    if (this.body.length === 0) {
	        this.xhr.send('');
	    } else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    } else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    } else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new this.body[0].constructor(len);
	        var k = 0;

	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    } else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    } else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};

	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];

	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};

	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) {
	        keys.push(key);
	    }return keys;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

	var indexOf = function indexOf(xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};

	var isXHR2Compatible = function isXHR2Compatible(obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stream = __webpack_require__(239);
	var util = __webpack_require__(263);

	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};

	util.inherits(Response, Stream);

	var capable = {
	    streaming: true,
	    status2: true
	};

	function parseHeaders(res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;

	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(),
	                value = m[2];

	            if (headers[key] !== undefined) {

	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                } else {
	                    headers[key] = [headers[key], value];
	                }
	            } else {
	                headers[key] = value;
	            }
	        } else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}

	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	};

	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};

	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        } catch (err) {
	            capable.status2 = false;
	        }

	        if (capable.status2) {
	            this.emit('ready');
	        }
	    } else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        } catch (err) {}

	        try {
	            this._emitData(res);
	        } catch (err) {
	            capable.streaming = false;
	        }
	    } else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);

	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        } else this.emit('end');

	        this.emit('close');
	    }
	};

	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	;(function () {

	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error();
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (object.btoa = function (input) {
	    for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars, output = '';
	    // if the next input index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    input.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	      charCode = input.charCodeAt(idx += 3 / 4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });

	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	    // initialize result and counters
	    var bc = 0, bs, buffer, idx = 0, output = '';
	    // get next character
	    buffer = input.charAt(idx++);
	    // character found in table? initialize bit storage and add its ascii value;
	    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	    // and if not first of each 4 characters,
	    // convert the first 8 bits to one ascii character
	    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });
	})();

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, setImmediate) {/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var contentDisposition = __webpack_require__(232);
	var deprecate = __webpack_require__(214)('express');
	var encodeUrl = __webpack_require__(254);
	var escapeHtml = __webpack_require__(200);
	var http = __webpack_require__(293);
	var isAbsolute = __webpack_require__(231).isAbsolute;
	var onFinished = __webpack_require__(201);
	var path = __webpack_require__(230);
	var merge = __webpack_require__(213);
	var sign = __webpack_require__(298).sign;
	var normalizeType = __webpack_require__(231).normalizeType;
	var normalizeTypes = __webpack_require__(231).normalizeTypes;
	var setCharset = __webpack_require__(231).setCharset;
	var statusCodes = http.STATUS_CODES;
	var cookie = __webpack_require__(299);
	var send = __webpack_require__(234);
	var extname = path.extname;
	var mime = send.mime;
	var resolve = path.resolve;
	var vary = __webpack_require__(300);

	/**
	 * Response prototype.
	 */

	var res = module.exports = {
	  __proto__: http.ServerResponse.prototype
	};

	/**
	 * Module variables.
	 * @private
	 */

	var charsetRegExp = /;\s*charset\s*=/;

	/**
	 * Set status `code`.
	 *
	 * @param {Number} code
	 * @return {ServerResponse}
	 * @public
	 */

	res.status = function status(code) {
	  this.statusCode = code;
	  return this;
	};

	/**
	 * Set Link header field with the given `links`.
	 *
	 * Examples:
	 *
	 *    res.links({
	 *      next: 'http://api.example.com/users?page=2',
	 *      last: 'http://api.example.com/users?page=5'
	 *    });
	 *
	 * @param {Object} links
	 * @return {ServerResponse}
	 * @public
	 */

	res.links = function (links) {
	  var link = this.get('Link') || '';
	  if (link) link += ', ';
	  return this.set('Link', link + Object.keys(links).map(function (rel) {
	    return '<' + links[rel] + '>; rel="' + rel + '"';
	  }).join(', '));
	};

	/**
	 * Send a response.
	 *
	 * Examples:
	 *
	 *     res.send(new Buffer('wahoo'));
	 *     res.send({ some: 'json' });
	 *     res.send('<p>some html</p>');
	 *
	 * @param {string|number|boolean|object|Buffer} body
	 * @public
	 */

	res.send = function send(body) {
	  var chunk = body;
	  var encoding;
	  var len;
	  var req = this.req;
	  var type;

	  // settings
	  var app = this.app;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.send(body, status) backwards compat
	    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
	      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[0];
	      chunk = arguments[1];
	    }
	  }

	  // disambiguate res.send(status) and res.send(status, num)
	  if (typeof chunk === 'number' && arguments.length === 1) {
	    // res.send(status) will set status message as text string
	    if (!this.get('Content-Type')) {
	      this.type('txt');
	    }

	    deprecate('res.send(status): Use res.sendStatus(status) instead');
	    this.statusCode = chunk;
	    chunk = statusCodes[chunk];
	  }

	  switch (typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) {
	    // string defaulting to html
	    case 'string':
	      if (!this.get('Content-Type')) {
	        this.type('html');
	      }
	      break;
	    case 'boolean':
	    case 'number':
	    case 'object':
	      if (chunk === null) {
	        chunk = '';
	      } else if (Buffer.isBuffer(chunk)) {
	        if (!this.get('Content-Type')) {
	          this.type('bin');
	        }
	      } else {
	        return this.json(chunk);
	      }
	      break;
	  }

	  // write strings in utf-8
	  if (typeof chunk === 'string') {
	    encoding = 'utf8';
	    type = this.get('Content-Type');

	    // reflect this in content-type
	    if (typeof type === 'string') {
	      this.set('Content-Type', setCharset(type, 'utf-8'));
	    }
	  }

	  // populate Content-Length
	  if (chunk !== undefined) {
	    if (!Buffer.isBuffer(chunk)) {
	      // convert chunk to Buffer; saves later double conversions
	      chunk = new Buffer(chunk, encoding);
	      encoding = undefined;
	    }

	    len = chunk.length;
	    this.set('Content-Length', len);
	  }

	  // populate ETag
	  var etag;
	  var generateETag = len !== undefined && app.get('etag fn');
	  if (typeof generateETag === 'function' && !this.get('ETag')) {
	    if (etag = generateETag(chunk, encoding)) {
	      this.set('ETag', etag);
	    }
	  }

	  // freshness
	  if (req.fresh) this.statusCode = 304;

	  // strip irrelevant headers
	  if (204 === this.statusCode || 304 === this.statusCode) {
	    this.removeHeader('Content-Type');
	    this.removeHeader('Content-Length');
	    this.removeHeader('Transfer-Encoding');
	    chunk = '';
	  }

	  if (req.method === 'HEAD') {
	    // skip body for HEAD
	    this.end();
	  } else {
	    // respond
	    this.end(chunk, encoding);
	  }

	  return this;
	};

	/**
	 * Send JSON response.
	 *
	 * Examples:
	 *
	 *     res.json(null);
	 *     res.json({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */

	res.json = function json(obj) {
	  var val = obj;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }

	  // settings
	  var app = this.app;
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces);

	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('Content-Type', 'application/json');
	  }

	  return this.send(body);
	};

	/**
	 * Send JSON response with JSONP callback support.
	 *
	 * Examples:
	 *
	 *     res.jsonp(null);
	 *     res.jsonp({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */

	res.jsonp = function jsonp(obj) {
	  var val = obj;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }

	  // settings
	  var app = this.app;
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces);
	  var callback = this.req.query[app.get('jsonp callback name')];

	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'application/json');
	  }

	  // fixup callback
	  if (Array.isArray(callback)) {
	    callback = callback[0];
	  }

	  // jsonp
	  if (typeof callback === 'string' && callback.length !== 0) {
	    this.charset = 'utf-8';
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'text/javascript');

	    // restrict callback charset
	    callback = callback.replace(/[^\[\]\w$.]/g, '');

	    // replace chars not allowed in JavaScript that are in JSON
	    body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');

	    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
	    // the typeof check is just to reduce client error noise
	    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
	  }

	  return this.send(body);
	};

	/**
	 * Send given HTTP status code.
	 *
	 * Sets the response status to `statusCode` and the body of the
	 * response to the standard description from node's http.STATUS_CODES
	 * or the statusCode number if no description.
	 *
	 * Examples:
	 *
	 *     res.sendStatus(200);
	 *
	 * @param {number} statusCode
	 * @public
	 */

	res.sendStatus = function sendStatus(statusCode) {
	  var body = statusCodes[statusCode] || String(statusCode);

	  this.statusCode = statusCode;
	  this.type('txt');

	  return this.send(body);
	};

	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.sentHeader`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendFile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendFile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendFile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */

	res.sendFile = function sendFile(path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};

	  if (!path) {
	    throw new TypeError('path argument is required to res.sendFile');
	  }

	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  if (!opts.root && !isAbsolute(path)) {
	    throw new TypeError('path must be absolute or specify root to res.sendFile');
	  }

	  // create file stream
	  var pathname = encodeURI(path);
	  var file = send(req, pathname, opts);

	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();

	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};

	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.sentHeader`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendfile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendfile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendfile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */

	res.sendfile = function (path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};

	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // create file stream
	  var file = send(req, path, opts);

	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();

	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORT' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};

	res.sendfile = deprecate.function(res.sendfile, 'res.sendfile: Use res.sendFile instead');

	/**
	 * Transfer the file at the given `path` as an attachment.
	 *
	 * Optionally providing an alternate attachment `filename`,
	 * and optional callback `callback(err)`. The callback is invoked
	 * when the data transfer is complete, or when an error has
	 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
	 *
	 * This method uses `res.sendfile()`.
	 *
	 * @public
	 */

	res.download = function download(path, filename, callback) {
	  var done = callback;
	  var name = filename;

	  // support function as second arg
	  if (typeof filename === 'function') {
	    done = filename;
	    name = null;
	  }

	  // set Content-Disposition when file is sent
	  var headers = {
	    'Content-Disposition': contentDisposition(name || path)
	  };

	  // Resolve the full path for sendFile
	  var fullPath = resolve(path);

	  return this.sendFile(fullPath, { headers: headers }, done);
	};

	/**
	 * Set _Content-Type_ response header with `type` through `mime.lookup()`
	 * when it does not contain "/", or set the Content-Type to `type` otherwise.
	 *
	 * Examples:
	 *
	 *     res.type('.html');
	 *     res.type('html');
	 *     res.type('json');
	 *     res.type('application/json');
	 *     res.type('png');
	 *
	 * @param {String} type
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.contentType = res.type = function contentType(type) {
	  var ct = type.indexOf('/') === -1 ? mime.lookup(type) : type;

	  return this.set('Content-Type', ct);
	};

	/**
	 * Respond to the Acceptable formats using an `obj`
	 * of mime-type callbacks.
	 *
	 * This method uses `req.accepted`, an array of
	 * acceptable types ordered by their quality values.
	 * When "Accept" is not present the _first_ callback
	 * is invoked, otherwise the first match is used. When
	 * no match is performed the server responds with
	 * 406 "Not Acceptable".
	 *
	 * Content-Type is set for you, however if you choose
	 * you may alter this within the callback using `res.type()`
	 * or `res.set('Content-Type', ...)`.
	 *
	 *    res.format({
	 *      'text/plain': function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      'text/html': function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      'appliation/json': function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * In addition to canonicalized MIME types you may
	 * also use extnames mapped to these types:
	 *
	 *    res.format({
	 *      text: function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      html: function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      json: function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * By default Express passes an `Error`
	 * with a `.status` of 406 to `next(err)`
	 * if a match is not made. If you provide
	 * a `.default` callback it will be invoked
	 * instead.
	 *
	 * @param {Object} obj
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.format = function (obj) {
	  var req = this.req;
	  var next = req.next;

	  var fn = obj.default;
	  if (fn) delete obj.default;
	  var keys = Object.keys(obj);

	  var key = keys.length > 0 ? req.accepts(keys) : false;

	  this.vary("Accept");

	  if (key) {
	    this.set('Content-Type', normalizeType(key).value);
	    obj[key](req, this, next);
	  } else if (fn) {
	    fn();
	  } else {
	    var err = new Error('Not Acceptable');
	    err.status = err.statusCode = 406;
	    err.types = normalizeTypes(keys).map(function (o) {
	      return o.value;
	    });
	    next(err);
	  }

	  return this;
	};

	/**
	 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	 *
	 * @param {String} filename
	 * @return {ServerResponse}
	 * @public
	 */

	res.attachment = function attachment(filename) {
	  if (filename) {
	    this.type(extname(filename));
	  }

	  this.set('Content-Disposition', contentDisposition(filename));

	  return this;
	};

	/**
	 * Append additional header `field` with value `val`.
	 *
	 * Example:
	 *
	 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	 *    res.append('Warning', '199 Miscellaneous warning');
	 *
	 * @param {String} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.append = function append(field, val) {
	  var prev = this.get(field);
	  var value = val;

	  if (prev) {
	    // concat the new and prev vals
	    value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
	  }

	  return this.set(field, value);
	};

	/**
	 * Set header `field` to `val`, or pass
	 * an object of header fields.
	 *
	 * Examples:
	 *
	 *    res.set('Foo', ['bar', 'baz']);
	 *    res.set('Accept', 'application/json');
	 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	 *
	 * Aliased as `res.header()`.
	 *
	 * @param {String|Object} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.set = res.header = function header(field, val) {
	  if (arguments.length === 2) {
	    var value = Array.isArray(val) ? val.map(String) : String(val);

	    // add charset to content-type
	    if (field.toLowerCase() === 'content-type' && !charsetRegExp.test(value)) {
	      var charset = mime.charsets.lookup(value.split(';')[0]);
	      if (charset) value += '; charset=' + charset.toLowerCase();
	    }

	    this.setHeader(field, value);
	  } else {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	  }
	  return this;
	};

	/**
	 * Get value for header `field`.
	 *
	 * @param {String} field
	 * @return {String}
	 * @public
	 */

	res.get = function (field) {
	  return this.getHeader(field);
	};

	/**
	 * Clear cookie `name`.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.clearCookie = function clearCookie(name, options) {
	  var opts = merge({ expires: new Date(1), path: '/' }, options);

	  return this.cookie(name, '', opts);
	};

	/**
	 * Set cookie `name` to `value`, with the given `options`.
	 *
	 * Options:
	 *
	 *    - `maxAge`   max-age in milliseconds, converted to `expires`
	 *    - `signed`   sign the cookie
	 *    - `path`     defaults to "/"
	 *
	 * Examples:
	 *
	 *    // "Remember Me" for 15 minutes
	 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	 *
	 *    // save as above
	 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	 *
	 * @param {String} name
	 * @param {String|Object} value
	 * @param {Options} options
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.cookie = function (name, value, options) {
	  var opts = merge({}, options);
	  var secret = this.req.secret;
	  var signed = opts.signed;

	  if (signed && !secret) {
	    throw new Error('cookieParser("secret") required for signed cookies');
	  }

	  var val = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? 'j:' + JSON.stringify(value) : String(value);

	  if (signed) {
	    val = 's:' + sign(val, secret);
	  }

	  if ('maxAge' in opts) {
	    opts.expires = new Date(Date.now() + opts.maxAge);
	    opts.maxAge /= 1000;
	  }

	  if (opts.path == null) {
	    opts.path = '/';
	  }

	  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

	  return this;
	};

	/**
	 * Set the location header to `url`.
	 *
	 * The given `url` can also be "back", which redirects
	 * to the _Referrer_ or _Referer_ headers or "/".
	 *
	 * Examples:
	 *
	 *    res.location('/foo/bar').;
	 *    res.location('http://example.com');
	 *    res.location('../login');
	 *
	 * @param {String} url
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.location = function location(url) {
	  var loc = url;

	  // "back" is an alias for the referrer
	  if (url === 'back') {
	    loc = this.req.get('Referrer') || '/';
	  }

	  // set location
	  return this.set('Location', encodeUrl(loc));
	};

	/**
	 * Redirect to the given `url` with optional response `status`
	 * defaulting to 302.
	 *
	 * The resulting `url` is determined by `res.location()`, so
	 * it will play nicely with mounted apps, relative paths,
	 * `"back"` etc.
	 *
	 * Examples:
	 *
	 *    res.redirect('/foo/bar');
	 *    res.redirect('http://example.com');
	 *    res.redirect(301, 'http://example.com');
	 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
	 *
	 * @public
	 */

	res.redirect = function redirect(url) {
	  var address = url;
	  var body;
	  var status = 302;

	  // allow status / url
	  if (arguments.length === 2) {
	    if (typeof arguments[0] === 'number') {
	      status = arguments[0];
	      address = arguments[1];
	    } else {
	      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
	      status = arguments[1];
	    }
	  }

	  // Set location header
	  address = this.location(address).get('Location');

	  // Support text/{plain,html} by default
	  this.format({
	    text: function text() {
	      body = statusCodes[status] + '. Redirecting to ' + address;
	    },

	    html: function html() {
	      var u = escapeHtml(address);
	      body = '<p>' + statusCodes[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
	    },

	    default: function _default() {
	      body = '';
	    }
	  });

	  // Respond
	  this.statusCode = status;
	  this.set('Content-Length', Buffer.byteLength(body));

	  if (this.req.method === 'HEAD') {
	    this.end();
	  } else {
	    this.end(body);
	  }
	};

	/**
	 * Add `field` to Vary. If already present in the Vary set, then
	 * this call is simply ignored.
	 *
	 * @param {Array|String} field
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.vary = function (field) {
	  // checks for back-compat
	  if (!field || Array.isArray(field) && !field.length) {
	    deprecate('res.vary(): Provide a field name');
	    return this;
	  }

	  vary(this, field);

	  return this;
	};

	/**
	 * Render `view` with the given `options` and optional callback `fn`.
	 * When a callback function is given a response will _not_ be made
	 * automatically, otherwise a response of _200_ and _text/html_ is given.
	 *
	 * Options:
	 *
	 *  - `cache`     boolean hinting to the engine it should cache
	 *  - `filename`  filename of the view being rendered
	 *
	 * @public
	 */

	res.render = function render(view, options, callback) {
	  var app = this.req.app;
	  var done = callback;
	  var opts = options || {};
	  var req = this.req;
	  var self = this;

	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // merge res.locals
	  opts._locals = self.locals;

	  // default callback to respond
	  done = done || function (err, str) {
	    if (err) return req.next(err);
	    self.send(str);
	  };

	  // render
	  app.render(view, opts, done);
	};

	// pipe the send file stream
	function sendfile(res, file, options, callback) {
	  var done = false;
	  var streaming;

	  // request aborted
	  function onaborted() {
	    if (done) return;
	    done = true;

	    var err = new Error('Request aborted');
	    err.code = 'ECONNABORTED';
	    callback(err);
	  }

	  // directory
	  function ondirectory() {
	    if (done) return;
	    done = true;

	    var err = new Error('EISDIR, read');
	    err.code = 'EISDIR';
	    callback(err);
	  }

	  // errors
	  function onerror(err) {
	    if (done) return;
	    done = true;
	    callback(err);
	  }

	  // ended
	  function onend() {
	    if (done) return;
	    done = true;
	    callback();
	  }

	  // file
	  function onfile() {
	    streaming = false;
	  }

	  // finished
	  function onfinish(err) {
	    if (err && err.code === 'ECONNRESET') return onaborted();
	    if (err) return onerror(err);
	    if (done) return;

	    setImmediate(function () {
	      if (streaming !== false && !done) {
	        onaborted();
	        return;
	      }

	      if (done) return;
	      done = true;
	      callback();
	    });
	  }

	  // streaming
	  function onstream() {
	    streaming = true;
	  }

	  file.on('directory', ondirectory);
	  file.on('end', onend);
	  file.on('error', onerror);
	  file.on('file', onfile);
	  file.on('stream', onstream);
	  onFinished(res, onfinish);

	  if (options.headers) {
	    // set headers on successful transfer
	    file.on('headers', function headers(res) {
	      var obj = options.headers;
	      var keys = Object.keys(obj);

	      for (var i = 0; i < keys.length; i++) {
	        var k = keys[i];
	        res.setHeader(k, obj[k]);
	      }
	    });
	  }

	  // pipe
	  file.pipe(res);
	}

	/**
	 * Stringify JSON, like JSON.stringify, but v8 optimized.
	 * @private
	 */

	function stringify(value, replacer, spaces) {
	  // v8 checks arguments.length for optimizing simple call
	  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
	  return replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer, __webpack_require__(192).setImmediate))

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */

	var crypto = __webpack_require__(256);

	/**
	 * Sign the given `val` with `secret`.
	 *
	 * @param {String} val
	 * @param {String} secret
	 * @return {String}
	 * @api private
	 */

	exports.sign = function (val, secret) {
	  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
	  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
	  return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
	};

	/**
	 * Unsign and decode the given `val` with `secret`,
	 * returning `false` if the signature is invalid.
	 *
	 * @param {String} val
	 * @param {String} secret
	 * @return {String|Boolean}
	 * @api private
	 */

	exports.unsign = function (val, secret) {
	  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
	  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
	  var str = val.slice(0, val.lastIndexOf('.')),
	      mac = exports.sign(str, secret);

	  return sha1(mac) == sha1(val) ? str : false;
	};

	/**
	 * Private
	 */

	function sha1(str) {
	  return crypto.createHash('sha1').update(str).digest('hex');
	}

/***/ },
/* 299 */
/***/ function(module, exports) {

	/*!
	 * cookie
	 * Copyright(c) 2012-2014 Roman Shtylman
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	exports.parse = parse;
	exports.serialize = serialize;

	/**
	 * Module variables.
	 * @private
	 */

	var decode = decodeURIComponent;
	var encode = encodeURIComponent;
	var pairSplitRegExp = /; */;

	/**
	 * RegExp to match field-content in RFC 7230 sec 3.2
	 *
	 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 * field-vchar   = VCHAR / obs-text
	 * obs-text      = %x80-FF
	 */

	var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 *
	 * @param {string} str
	 * @param {object} [options]
	 * @return {object}
	 * @public
	 */

	function parse(str, options) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string');
	  }

	  var obj = {};
	  var opt = options || {};
	  var pairs = str.split(pairSplitRegExp);
	  var dec = opt.decode || decode;

	  for (var i = 0; i < pairs.length; i++) {
	    var pair = pairs[i];
	    var eq_idx = pair.indexOf('=');

	    // skip things that don't look like key=value
	    if (eq_idx < 0) {
	      continue;
	    }

	    var key = pair.substr(0, eq_idx).trim();
	    var val = pair.substr(++eq_idx, pair.length).trim();

	    // quoted values
	    if ('"' == val[0]) {
	      val = val.slice(1, -1);
	    }

	    // only assign once
	    if (undefined == obj[key]) {
	      obj[key] = tryDecode(val, dec);
	    }
	  }

	  return obj;
	}

	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize the a name value pair into a cookie string suitable for
	 * http headers. An optional options object specified cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 *
	 * @param {string} name
	 * @param {string} val
	 * @param {object} [options]
	 * @return {string}
	 * @public
	 */

	function serialize(name, val, options) {
	  var opt = options || {};
	  var enc = opt.encode || encode;

	  if (typeof enc !== 'function') {
	    throw new TypeError('option encode is invalid');
	  }

	  if (!fieldContentRegExp.test(name)) {
	    throw new TypeError('argument name is invalid');
	  }

	  var value = enc(val);

	  if (value && !fieldContentRegExp.test(value)) {
	    throw new TypeError('argument val is invalid');
	  }

	  var str = name + '=' + value;

	  if (null != opt.maxAge) {
	    var maxAge = opt.maxAge - 0;
	    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
	    str += '; Max-Age=' + Math.floor(maxAge);
	  }

	  if (opt.domain) {
	    if (!fieldContentRegExp.test(opt.domain)) {
	      throw new TypeError('option domain is invalid');
	    }

	    str += '; Domain=' + opt.domain;
	  }

	  if (opt.path) {
	    if (!fieldContentRegExp.test(opt.path)) {
	      throw new TypeError('option path is invalid');
	    }

	    str += '; Path=' + opt.path;
	  }

	  if (opt.expires) {
	    if (typeof opt.expires.toUTCString !== 'function') {
	      throw new TypeError('option expires is invalid');
	    }

	    str += '; Expires=' + opt.expires.toUTCString();
	  }

	  if (opt.httpOnly) {
	    str += '; HttpOnly';
	  }

	  if (opt.secure) {
	    str += '; Secure';
	  }

	  if (opt.sameSite) {
	    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

	    switch (sameSite) {
	      case true:
	        str += '; SameSite=Strict';
	        break;
	      case 'lax':
	        str += '; SameSite=Lax';
	        break;
	      case 'strict':
	        str += '; SameSite=Strict';
	        break;
	      default:
	        throw new TypeError('option sameSite is invalid');
	    }
	  }

	  return str;
	}

	/**
	 * Try decoding a string using a decoding function.
	 *
	 * @param {string} str
	 * @param {function} decode
	 * @private
	 */

	function tryDecode(str, decode) {
	  try {
	    return decode(str);
	  } catch (e) {
	    return str;
	  }
	}

/***/ },
/* 300 */
/***/ function(module, exports) {

	/*!
	 * vary
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 */

	module.exports = vary;
	module.exports.append = append;

	/**
	 * RegExp to match field-name in RFC 7230 sec 3.2
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 */

	var fieldNameRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/;

	/**
	 * Append a field to a vary header.
	 *
	 * @param {String} header
	 * @param {String|Array} field
	 * @return {String}
	 * @api public
	 */

	function append(header, field) {
	  if (typeof header !== 'string') {
	    throw new TypeError('header argument is required');
	  }

	  if (!field) {
	    throw new TypeError('field argument is required');
	  }

	  // get fields array
	  var fields = !Array.isArray(field) ? parse(String(field)) : field;

	  // assert on invalid field names
	  for (var i = 0; i < fields.length; i++) {
	    if (!fieldNameRegExp.test(fields[i])) {
	      throw new TypeError('field argument contains an invalid header name');
	    }
	  }

	  // existing, unspecified vary
	  if (header === '*') {
	    return header;
	  }

	  // enumerate current values
	  var val = header;
	  var vals = parse(header.toLowerCase());

	  // unspecified vary
	  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
	    return '*';
	  }

	  for (var i = 0; i < fields.length; i++) {
	    var fld = fields[i].toLowerCase();

	    // append value (case-preserving)
	    if (vals.indexOf(fld) === -1) {
	      vals.push(fld);
	      val = val ? val + ', ' + fields[i] : fields[i];
	    }
	  }

	  return val;
	}

	/**
	 * Parse a vary header into an array.
	 *
	 * @param {String} header
	 * @return {Array}
	 * @api private
	 */

	function parse(header) {
	  return header.trim().split(/ *, */);
	}

	/**
	 * Mark that a request is varied on a header field.
	 *
	 * @param {Object} res
	 * @param {String|Array} field
	 * @api public
	 */

	function vary(res, field) {
	  if (!res || !res.getHeader || !res.setHeader) {
	    // quack quack
	    throw new TypeError('res argument is required');
	  }

	  // get existing header
	  var val = res.getHeader('Vary') || '';
	  var header = Array.isArray(val) ? val.join(', ') : String(val);

	  // set new header
	  if (val = append(header, field)) {
	    res.setHeader('Vary', val);
	  }
	}

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * serve-static
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var encodeUrl = __webpack_require__(254);
	var escapeHtml = __webpack_require__(200);
	var parseUrl = __webpack_require__(215);
	var resolve = __webpack_require__(230).resolve;
	var send = __webpack_require__(234);
	var url = __webpack_require__(216);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = serveStatic;
	module.exports.mime = send.mime;

	/**
	 * @param {string} root
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function serveStatic(root, options) {
	  if (!root) {
	    throw new TypeError('root path required');
	  }

	  if (typeof root !== 'string') {
	    throw new TypeError('root path must be a string');
	  }

	  // copy options object
	  var opts = Object.create(options || null);

	  // fall-though
	  var fallthrough = opts.fallthrough !== false;

	  // default redirect
	  var redirect = opts.redirect !== false;

	  // headers listener
	  var setHeaders = opts.setHeaders;

	  if (setHeaders && typeof setHeaders !== 'function') {
	    throw new TypeError('option setHeaders must be function');
	  }

	  // setup options for send
	  opts.maxage = opts.maxage || opts.maxAge || 0;
	  opts.root = resolve(root);

	  // construct directory listener
	  var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();

	  return function serveStatic(req, res, next) {
	    if (req.method !== 'GET' && req.method !== 'HEAD') {
	      if (fallthrough) {
	        return next();
	      }

	      // method not allowed
	      res.statusCode = 405;
	      res.setHeader('Allow', 'GET, HEAD');
	      res.setHeader('Content-Length', '0');
	      res.end();
	      return;
	    }

	    var forwardError = !fallthrough;
	    var originalUrl = parseUrl.original(req);
	    var path = parseUrl(req).pathname;

	    // make sure redirect occurs at mount
	    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
	      path = '';
	    }

	    // create send stream
	    var stream = send(req, path, opts);

	    // add directory handler
	    stream.on('directory', onDirectory);

	    // add headers listener
	    if (setHeaders) {
	      stream.on('headers', setHeaders);
	    }

	    // add file listener for fallthrough
	    if (fallthrough) {
	      stream.on('file', function onFile() {
	        // once file is determined, always forward error
	        forwardError = true;
	      });
	    }

	    // forward errors
	    stream.on('error', function error(err) {
	      if (forwardError || !(err.statusCode < 500)) {
	        next(err);
	        return;
	      }

	      next();
	    });

	    // pipe
	    stream.pipe(res);
	  };
	}

	/**
	 * Collapse all leading slashes into a single slash
	 * @private
	 */
	function collapseLeadingSlashes(str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break;
	    }
	  }

	  return i > 1 ? '/' + str.substr(i) : str;
	}

	/**
	 * Create a directory listener that just 404s.
	 * @private
	 */

	function createNotFoundDirectoryListener() {
	  return function notFound() {
	    this.error(404);
	  };
	}

	/**
	 * Create a directory listener that performs a redirect.
	 * @private
	 */

	function createRedirectDirectoryListener() {
	  return function redirect() {
	    if (this.hasTrailingSlash()) {
	      this.error(404);
	      return;
	    }

	    // get original URL
	    var originalUrl = parseUrl.original(this.req);

	    // append trailing slash
	    originalUrl.path = null;
	    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');

	    // reformat the URL
	    var loc = encodeUrl(url.format(originalUrl));
	    var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n';
	    var res = this.res;

	    // send redirect response
	    res.statusCode = 301;
	    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
	    res.setHeader('Content-Length', Buffer.byteLength(msg));
	    res.setHeader('X-Content-Type-Options', 'nosniff');
	    res.setHeader('Location', loc);
	    res.end(msg);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (app, User) {
	  app.engine('hbs', (0, _expressHandlebars2.default)({
	    extname: 'hbs',
	    defaultLayout: 'splash',
	    layoutsDir: _path2.default.join(__dirname, 'views/templates/'),
	    partialsDir: _path2.default.join(__dirname, 'views/partials/')
	  }));
	  app.set('views', _path2.default.join(__dirname, 'views'));
	  app.set('view engine', 'hbs');

	  _passport2.default.serializeUser(function (user, done) {
	    var userId = void 0;
	    if (Array.isArray(user)) {
	      userId = user[0].id;
	    } else {
	      userId = user.id;
	    }
	    return done(null, userId);
	  });

	  _passport2.default.deserializeUser(function (id, done) {
	    console.log('deserialize');
	    return User.find({ id: id }).then(function (user) {
	      return done(null, user[0]);
	    }).catch(function (err) {
	      return done(err, null);
	    });
	  });

	  app.use(_bodyParser2.default.urlencoded({
	    extended: true
	  }));
	  app.use(_bodyParser2.default.json());

	  // STATIC DIRECTORIES
	  app.use(_express2.default.static(_path2.default.join(__dirname, '/../build')));
	  app.use(_express2.default.static(_path2.default.join(__dirname, '/../compiled')));
	  app.use(_express2.default.static(_path2.default.join(__dirname, '/../../index.html')));
	  app.use(_express2.default.static(_path2.default.join(__dirname, '/../node_modules')));
	  app.use(_express2.default.static(_path2.default.join(__dirname, '/../Client/')));
	  app.use(_express2.default.static(_path2.default.join(__dirname, './views')));
	  app.use(_express2.default.static(_path2.default.join(__dirname, './server-test')));

	  app.use((0, _expressSession2.default)({
	    secret: 'keyboard cat',
	    saveUninitialized: true,
	    resave: true
	  }));
	  app.use(_passport2.default.initialize());
	  app.use(_passport2.default.session());
	};

	var _bodyParser = __webpack_require__(303);

	var _bodyParser2 = _interopRequireDefault(_bodyParser);

	var _path = __webpack_require__(230);

	var _path2 = _interopRequireDefault(_path);

	var _expressSession = __webpack_require__(346);

	var _expressSession2 = _interopRequireDefault(_expressSession);

	var _expressHandlebars = __webpack_require__(367);

	var _expressHandlebars2 = _interopRequireDefault(_expressHandlebars);

	var _passport = __webpack_require__(437);

	var _passport2 = _interopRequireDefault(_passport);

	var _express = __webpack_require__(186);

	var _express2 = _interopRequireDefault(_express);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var deprecate = __webpack_require__(214)('body-parser');

	/**
	 * Cache of loaded parsers.
	 * @private
	 */

	var parsers = Object.create(null);

	/**
	 * @typedef Parsers
	 * @type {function}
	 * @property {function} json
	 * @property {function} raw
	 * @property {function} text
	 * @property {function} urlencoded
	 */

	/**
	 * Module exports.
	 * @type {Parsers}
	 */

	exports = module.exports = deprecate.function(bodyParser, 'bodyParser: use individual json/urlencoded middlewares');

	/**
	 * JSON parser.
	 * @public
	 */

	Object.defineProperty(exports, 'json', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('json')
	});

	/**
	 * Raw parser.
	 * @public
	 */

	Object.defineProperty(exports, 'raw', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('raw')
	});

	/**
	 * Text parser.
	 * @public
	 */

	Object.defineProperty(exports, 'text', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('text')
	});

	/**
	 * URL-encoded parser.
	 * @public
	 */

	Object.defineProperty(exports, 'urlencoded', {
	  configurable: true,
	  enumerable: true,
	  get: createParserGetter('urlencoded')
	});

	/**
	 * Create a middleware to parse json and urlencoded bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @deprecated
	 * @public
	 */

	function bodyParser(options) {
	  var opts = {};

	  // exclude type option
	  if (options) {
	    for (var prop in options) {
	      if (prop !== 'type') {
	        opts[prop] = options[prop];
	      }
	    }
	  }

	  var _urlencoded = exports.urlencoded(opts);
	  var _json = exports.json(opts);

	  return function bodyParser(req, res, next) {
	    _json(req, res, function (err) {
	      if (err) return next(err);
	      _urlencoded(req, res, next);
	    });
	  };
	}

	/**
	 * Create a getter for loading a parser.
	 * @private
	 */

	function createParserGetter(name) {
	  return function get() {
	    return loadParser(name);
	  };
	}

	/**
	 * Load a parser module.
	 * @private
	 */

	function loadParser(parserName) {
	  var parser = parsers[parserName];

	  if (parser !== undefined) {
	    return parser;
	  }

	  // this uses a switch for static require analysis
	  switch (parserName) {
	    case 'json':
	      parser = __webpack_require__(304);
	      break;
	    case 'raw':
	      parser = __webpack_require__(343);
	      break;
	    case 'text':
	      parser = __webpack_require__(344);
	      break;
	    case 'urlencoded':
	      parser = __webpack_require__(345);
	      break;
	  }

	  // store to prevent invoking require()
	  return parsers[parserName] = parser;
	}

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var bytes = __webpack_require__(305);
	var contentType = __webpack_require__(233);
	var createError = __webpack_require__(235);
	var debug = __webpack_require__(197)('body-parser:json');
	var read = __webpack_require__(306);
	var typeis = __webpack_require__(291);

	/**
	 * Module exports.
	 */

	module.exports = json;

	/**
	 * RegExp to match the first non-space in a string.
	 *
	 * Allowed whitespace is defined in RFC 7159:
	 *
	 *    ws = *(
	 *            %x20 /              ; Space
	 *            %x09 /              ; Horizontal tab
	 *            %x0A /              ; Line feed or New line
	 *            %x0D )              ; Carriage return
	 */

	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/; // eslint-disable-line no-control-regex

	/**
	 * Create a middleware to parse JSON bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function json(options) {
	  var opts = options || {};

	  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
	  var inflate = opts.inflate !== false;
	  var reviver = opts.reviver;
	  var strict = opts.strict !== false;
	  var type = opts.type || 'application/json';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function');
	  }

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;

	  function parse(body) {
	    if (body.length === 0) {
	      // special-case empty json body, as it's a common client-side mistake
	      // TODO: maybe make this configurable or part of "strict" option
	      return {};
	    }

	    if (strict) {
	      var first = firstchar(body);

	      if (first !== '{' && first !== '[') {
	        debug('strict violation');
	        throw new SyntaxError('Unexpected token ' + first);
	      }
	    }

	    debug('parse json');
	    return JSON.parse(body, reviver);
	  }

	  return function jsonParser(req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return;
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return;
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return;
	    }

	    // assert charset per RFC 7159 sec 8.1
	    var charset = getCharset(req) || 'utf-8';
	    if (charset.substr(0, 4) !== 'utf-') {
	      debug('invalid charset');
	      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
	        charset: charset
	      }));
	      return;
	    }

	    // read
	    read(req, res, next, parse, debug, {
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  };
	}

	/**
	 * Get the first non-whitespace character in a string.
	 *
	 * @param {string} str
	 * @return {function}
	 * @api public
	 */

	function firstchar(str) {
	  var match = FIRST_CHAR_REGEXP.exec(str);
	  return match ? match[1] : '';
	}

	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */

	function getCharset(req) {
	  try {
	    return contentType.parse(req).parameters.charset.toLowerCase();
	  } catch (e) {
	    return undefined;
	  }
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker(type) {
	  return function checkType(req) {
	    return Boolean(typeis(req, type));
	  };
	}

/***/ },
/* 305 */
/***/ function(module, exports) {

	/*!
	 * bytes
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015 Jed Watson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = bytes;
	module.exports.format = format;
	module.exports.parse = parse;

	/**
	 * Module variables.
	 * @private
	 */

	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

	var map = {
	  b: 1,
	  kb: 1 << 10,
	  mb: 1 << 20,
	  gb: 1 << 30,
	  tb: (1 << 30) * 1024
	};

	// TODO: use is-finite module?
	var numberIsFinite = Number.isFinite || function (v) {
	  return typeof v === 'number' && isFinite(v);
	};

	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

	/**
	 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
	 *
	 * @param {string|number} value
	 * @param {{
	 *  case: [string],
	 *  decimalPlaces: [number]
	 *  fixedDecimals: [boolean]
	 *  thousandsSeparator: [string]
	 *  unitSeparator: [string]
	 *  }} [options] bytes options.
	 *
	 * @returns {string|number|null}
	 */

	function bytes(value, options) {
	  if (typeof value === 'string') {
	    return parse(value);
	  }

	  if (typeof value === 'number') {
	    return format(value, options);
	  }

	  return null;
	}

	/**
	 * Format the given value in bytes into a string.
	 *
	 * If the value is negative, it is kept as such. If it is a float,
	 * it is rounded.
	 *
	 * @param {number} value
	 * @param {object} [options]
	 * @param {number} [options.decimalPlaces=2]
	 * @param {number} [options.fixedDecimals=false]
	 * @param {string} [options.thousandsSeparator=]
	 * @param {string} [options.unitSeparator=]
	 *
	 * @returns {string|null}
	 * @public
	 */

	function format(value, options) {
	  if (!numberIsFinite(value)) {
	    return null;
	  }

	  var mag = Math.abs(value);
	  var thousandsSeparator = options && options.thousandsSeparator || '';
	  var unitSeparator = options && options.unitSeparator || '';
	  var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
	  var fixedDecimals = Boolean(options && options.fixedDecimals);
	  var unit = 'B';

	  if (mag >= map.tb) {
	    unit = 'TB';
	  } else if (mag >= map.gb) {
	    unit = 'GB';
	  } else if (mag >= map.mb) {
	    unit = 'MB';
	  } else if (mag >= map.kb) {
	    unit = 'kB';
	  }

	  var val = value / map[unit.toLowerCase()];
	  var str = val.toFixed(decimalPlaces);

	  if (!fixedDecimals) {
	    str = str.replace(formatDecimalsRegExp, '$1');
	  }

	  if (thousandsSeparator) {
	    str = str.replace(formatThousandsRegExp, thousandsSeparator);
	  }

	  return str + unitSeparator + unit;
	}

	/**
	 * Parse the string value into an integer in bytes.
	 *
	 * If no unit is given, it is assumed the value is in bytes.
	 *
	 * @param {number|string} val
	 *
	 * @returns {number|null}
	 * @public
	 */

	function parse(val) {
	  if (typeof val === 'number' && !isNaN(val)) {
	    return val;
	  }

	  if (typeof val !== 'string') {
	    return null;
	  }

	  // Test if the string passed is valid
	  var results = parseRegExp.exec(val);
	  var floatValue;
	  var unit = 'b';

	  if (!results) {
	    // Nothing could be extracted from the given string
	    floatValue = parseInt(val, 10);
	    unit = 'b';
	  } else {
	    // Retrieve the value and the unit
	    floatValue = parseFloat(results[1]);
	    unit = results[4].toLowerCase();
	  }

	  return Math.floor(map[unit] * floatValue);
	}

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var createError = __webpack_require__(235);
	var getBody = __webpack_require__(307);
	var iconv = __webpack_require__(308);
	var onFinished = __webpack_require__(201);
	var zlib = __webpack_require__(329);

	/**
	 * Module exports.
	 */

	module.exports = read;

	/**
	 * Read a request into a buffer and parse.
	 *
	 * @param {object} req
	 * @param {object} res
	 * @param {function} next
	 * @param {function} parse
	 * @param {function} debug
	 * @param {object} [options]
	 * @api private
	 */

	function read(req, res, next, parse, debug, options) {
	  var length;
	  var opts = options || {};
	  var stream;

	  // flag as parsed
	  req._body = true;

	  // read options
	  var encoding = opts.encoding !== null ? opts.encoding || 'utf-8' : null;
	  var verify = opts.verify;

	  try {
	    // get the content stream
	    stream = contentstream(req, debug, opts.inflate);
	    length = stream.length;
	    stream.length = undefined;
	  } catch (err) {
	    return next(err);
	  }

	  // set raw-body options
	  opts.length = length;
	  opts.encoding = verify ? null : encoding;

	  // assert charset is supported
	  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
	    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
	      charset: encoding.toLowerCase()
	    }));
	  }

	  // read body
	  debug('read body');
	  getBody(stream, opts, function (err, body) {
	    if (err) {
	      // default to 400
	      setErrorStatus(err, 400);

	      // echo back charset
	      if (err.type === 'encoding.unsupported') {
	        err = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
	          charset: encoding.toLowerCase()
	        });
	      }

	      // read off entire request
	      stream.resume();
	      onFinished(req, function onfinished() {
	        next(err);
	      });
	      return;
	    }

	    // verify
	    if (verify) {
	      try {
	        debug('verify body');
	        verify(req, res, body, encoding);
	      } catch (err) {
	        // default to 403
	        setErrorStatus(err, 403);
	        next(err);
	        return;
	      }
	    }

	    // parse
	    var str;
	    try {
	      debug('parse body');
	      str = typeof body !== 'string' && encoding !== null ? iconv.decode(body, encoding) : body;
	      req.body = parse(str);
	    } catch (err) {
	      err.body = str === undefined ? body : str;

	      // default to 400
	      setErrorStatus(err, 400);

	      next(err);
	      return;
	    }

	    next();
	  });
	}

	/**
	 * Get the content stream of the request.
	 *
	 * @param {object} req
	 * @param {function} debug
	 * @param {boolean} [inflate=true]
	 * @return {object}
	 * @api private
	 */

	function contentstream(req, debug, inflate) {
	  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
	  var length = req.headers['content-length'];
	  var stream;

	  debug('content-encoding "%s"', encoding);

	  if (inflate === false && encoding !== 'identity') {
	    throw createError(415, 'content encoding unsupported');
	  }

	  switch (encoding) {
	    case 'deflate':
	      stream = zlib.createInflate();
	      debug('inflate body');
	      req.pipe(stream);
	      break;
	    case 'gzip':
	      stream = zlib.createGunzip();
	      debug('gunzip body');
	      req.pipe(stream);
	      break;
	    case 'identity':
	      stream = req;
	      stream.length = length;
	      break;
	    default:
	      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
	        encoding: encoding
	      });
	  }

	  return stream;
	}

	/**
	 * Set a status on an error object, if ones does not exist
	 * @private
	 */

	function setErrorStatus(error, status) {
	  if (!error.status && !error.statusCode) {
	    error.status = status;
	    error.statusCode = status;
	  }
	}

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {/*!
	 * raw-body
	 * Copyright(c) 2013-2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var bytes = __webpack_require__(305);
	var iconv = __webpack_require__(308);
	var unpipe = __webpack_require__(205);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = getRawBody;

	/**
	 * Module variables.
	 * @private
	 */

	var iconvEncodingMessageRegExp = /^Encoding not recognized: /;

	/**
	 * Get the decoder for a given encoding.
	 *
	 * @param {string} encoding
	 * @private
	 */

	function getDecoder(encoding) {
	  if (!encoding) return null;

	  try {
	    return iconv.getDecoder(encoding);
	  } catch (e) {
	    // error getting decoder
	    if (!iconvEncodingMessageRegExp.test(e.message)) throw e;

	    // the encoding was not found
	    throw createError(415, 'specified encoding unsupported', 'encoding.unsupported', {
	      encoding: encoding
	    });
	  }
	}

	/**
	 * Get the raw body of a stream (typically HTTP).
	 *
	 * @param {object} stream
	 * @param {object|string|function} [options]
	 * @param {function} [callback]
	 * @public
	 */

	function getRawBody(stream, options, callback) {
	  var done = callback;
	  var opts = options || {};

	  if (options === true || typeof options === 'string') {
	    // short cut for encoding
	    opts = {
	      encoding: options
	    };
	  }

	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // validate callback is a function, if provided
	  if (done !== undefined && typeof done !== 'function') {
	    throw new TypeError('argument callback must be a function');
	  }

	  // require the callback without promises
	  if (!done && !global.Promise) {
	    throw new TypeError('argument callback is required');
	  }

	  // get encoding
	  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';

	  // convert the limit to an integer
	  var limit = bytes.parse(opts.limit);

	  // convert the expected length to an integer
	  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;

	  if (done) {
	    // classic callback style
	    return readStream(stream, encoding, length, limit, done);
	  }

	  return new Promise(function executor(resolve, reject) {
	    readStream(stream, encoding, length, limit, function onRead(err, buf) {
	      if (err) return reject(err);
	      resolve(buf);
	    });
	  });
	}

	/**
	 * Halt a stream.
	 *
	 * @param {Object} stream
	 * @private
	 */

	function halt(stream) {
	  // unpipe everything from the stream
	  unpipe(stream);

	  // pause stream
	  if (typeof stream.pause === 'function') {
	    stream.pause();
	  }
	}

	/**
	 * Make a serializable error object.
	 *
	 * To create serializable errors you must re-set message so
	 * that it is enumerable and you must re configure the type
	 * property so that is writable and enumerable.
	 *
	 * @param {number} status
	 * @param {string} message
	 * @param {string} type
	 * @param {object} props
	 * @private
	 */

	function createError(status, message, type, props) {
	  var error = new Error();

	  // capture stack trace
	  Error.captureStackTrace(error, createError);

	  // set free-form properties
	  for (var prop in props) {
	    error[prop] = props[prop];
	  }

	  // set message
	  error.message = message;

	  // set status
	  error.status = status;
	  error.statusCode = status;

	  // set type
	  Object.defineProperty(error, 'type', {
	    value: type,
	    enumerable: true,
	    writable: true,
	    configurable: true
	  });

	  return error;
	}

	/**
	 * Read the data from the stream.
	 *
	 * @param {object} stream
	 * @param {string} encoding
	 * @param {number} length
	 * @param {number} limit
	 * @param {function} callback
	 * @public
	 */

	function readStream(stream, encoding, length, limit, callback) {
	  var complete = false;
	  var sync = true;

	  // check the length and limit options.
	  // note: we intentionally leave the stream paused,
	  // so users should handle the stream themselves.
	  if (limit !== null && length !== null && length > limit) {
	    return done(createError(413, 'request entity too large', 'entity.too.large', {
	      expected: length,
	      length: length,
	      limit: limit
	    }));
	  }

	  // streams1: assert request encoding is buffer.
	  // streams2+: assert the stream encoding is buffer.
	  //   stream._decoder: streams1
	  //   state.encoding: streams2
	  //   state.decoder: streams2, specifically < 0.10.6
	  var state = stream._readableState;
	  if (stream._decoder || state && (state.encoding || state.decoder)) {
	    // developer error
	    return done(createError(500, 'stream encoding should not be set', 'stream.encoding.set'));
	  }

	  var received = 0;
	  var decoder;

	  try {
	    decoder = getDecoder(encoding);
	  } catch (err) {
	    return done(err);
	  }

	  var buffer = decoder ? '' : [];

	  // attach listeners
	  stream.on('aborted', onAborted);
	  stream.on('close', cleanup);
	  stream.on('data', onData);
	  stream.on('end', onEnd);
	  stream.on('error', onEnd);

	  // mark sync section complete
	  sync = false;

	  function done() {
	    var args = new Array(arguments.length);

	    // copy arguments
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    // mark complete
	    complete = true;

	    if (sync) {
	      process.nextTick(invokeCallback);
	    } else {
	      invokeCallback();
	    }

	    function invokeCallback() {
	      cleanup();

	      if (args[0]) {
	        // halt the stream on error
	        halt(stream);
	      }

	      callback.apply(null, args);
	    }
	  }

	  function onAborted() {
	    if (complete) return;

	    done(createError(400, 'request aborted', 'request.aborted', {
	      code: 'ECONNABORTED',
	      expected: length,
	      length: length,
	      received: received
	    }));
	  }

	  function onData(chunk) {
	    if (complete) return;

	    received += chunk.length;
	    decoder ? buffer += decoder.write(chunk) : buffer.push(chunk);

	    if (limit !== null && received > limit) {
	      done(createError(413, 'request entity too large', 'entity.too.large', {
	        limit: limit,
	        received: received
	      }));
	    }
	  }

	  function onEnd(err) {
	    if (complete) return;
	    if (err) return done(err);

	    if (length !== null && received !== length) {
	      done(createError(400, 'request size did not match content length', 'request.size.invalid', {
	        expected: length,
	        length: length,
	        received: received
	      }));
	    } else {
	      var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
	      done(null, string);
	    }
	  }

	  function cleanup() {
	    buffer = null;

	    stream.removeListener('aborted', onAborted);
	    stream.removeListener('data', onData);
	    stream.removeListener('end', onEnd);
	    stream.removeListener('error', onEnd);
	    stream.removeListener('close', cleanup);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4), __webpack_require__(193).Buffer))

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var bomHandling = __webpack_require__(309),
	    iconv = module.exports;

	// All codecs and aliases are kept here, keyed by encoding name/alias.
	// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
	iconv.encodings = null;

	// Characters emitted in case of error.
	iconv.defaultCharUnicode = '';
	iconv.defaultCharSingleByte = '?';

	// Public API.
	iconv.encode = function encode(str, encoding, options) {
	    str = "" + (str || ""); // Ensure string.

	    var encoder = iconv.getEncoder(encoding, options);

	    var res = encoder.write(str);
	    var trail = encoder.end();

	    return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
	};

	iconv.decode = function decode(buf, encoding, options) {
	    if (typeof buf === 'string') {
	        if (!iconv.skipDecodeWarning) {
	            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
	            iconv.skipDecodeWarning = true;
	        }

	        buf = new Buffer("" + (buf || ""), "binary"); // Ensure buffer.
	    }

	    var decoder = iconv.getDecoder(encoding, options);

	    var res = decoder.write(buf);
	    var trail = decoder.end();

	    return trail ? res + trail : res;
	};

	iconv.encodingExists = function encodingExists(enc) {
	    try {
	        iconv.getCodec(enc);
	        return true;
	    } catch (e) {
	        return false;
	    }
	};

	// Legacy aliases to convert functions
	iconv.toEncoding = iconv.encode;
	iconv.fromEncoding = iconv.decode;

	// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
	iconv._codecDataCache = {};
	iconv.getCodec = function getCodec(encoding) {
	    if (!iconv.encodings) iconv.encodings = __webpack_require__(310); // Lazy load all encoding definitions.

	    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
	    var enc = ('' + encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");

	    // Traverse iconv.encodings to find actual codec.
	    var codecOptions = {};
	    while (true) {
	        var codec = iconv._codecDataCache[enc];
	        if (codec) return codec;

	        var codecDef = iconv.encodings[enc];

	        switch (typeof codecDef === 'undefined' ? 'undefined' : _typeof(codecDef)) {
	            case "string":
	                // Direct alias to other encoding.
	                enc = codecDef;
	                break;

	            case "object":
	                // Alias with options. Can be layered.
	                for (var key in codecDef) {
	                    codecOptions[key] = codecDef[key];
	                }if (!codecOptions.encodingName) codecOptions.encodingName = enc;

	                enc = codecDef.type;
	                break;

	            case "function":
	                // Codec itself.
	                if (!codecOptions.encodingName) codecOptions.encodingName = enc;

	                // The codec function must load all tables and return object with .encoder and .decoder methods.
	                // It'll be called only once (for each different options object).
	                codec = new codecDef(codecOptions, iconv);

	                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
	                return codec;

	            default:
	                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
	        }
	    }
	};

	iconv.getEncoder = function getEncoder(encoding, options) {
	    var codec = iconv.getCodec(encoding),
	        encoder = new codec.encoder(options, codec);

	    if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);

	    return encoder;
	};

	iconv.getDecoder = function getDecoder(encoding, options) {
	    var codec = iconv.getCodec(encoding),
	        decoder = new codec.decoder(options, codec);

	    if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);

	    return decoder;
	};

	// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
	var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
	if (nodeVer) {

	    // Load streaming support in Node v0.10+
	    var nodeVerArr = nodeVer.split(".").map(Number);
	    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
	        __webpack_require__(327)(iconv);
	    }

	    // Load Node primitive extensions.
	    __webpack_require__(328)(iconv);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer, __webpack_require__(4)))

/***/ },
/* 309 */
/***/ function(module, exports) {

	"use strict";

	var BOMChar = '';

	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
	    this.encoder = encoder;
	    this.addBOM = true;
	}

	PrependBOMWrapper.prototype.write = function (str) {
	    if (this.addBOM) {
	        str = BOMChar + str;
	        this.addBOM = false;
	    }

	    return this.encoder.write(str);
	};

	PrependBOMWrapper.prototype.end = function () {
	    return this.encoder.end();
	};

	//------------------------------------------------------------------------------

	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
	    this.decoder = decoder;
	    this.pass = false;
	    this.options = options || {};
	}

	StripBOMWrapper.prototype.write = function (buf) {
	    var res = this.decoder.write(buf);
	    if (this.pass || !res) return res;

	    if (res[0] === BOMChar) {
	        res = res.slice(1);
	        if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
	    }

	    this.pass = true;
	    return res;
	};

	StripBOMWrapper.prototype.end = function () {
	    return this.decoder.end();
	};

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Update this array if you add/rename/remove files in this directory.
	// We support Browserify by skipping automatic module discovery and requiring modules directly.

	var modules = [__webpack_require__(311), __webpack_require__(312), __webpack_require__(313), __webpack_require__(314), __webpack_require__(315), __webpack_require__(316), __webpack_require__(317), __webpack_require__(318)];

	// Put all encoding/alias/codec definitions to single object and export it. 
	for (var i = 0; i < modules.length; i++) {
	    var _module = modules[i];
	    for (var enc in _module) {
	        if (Object.prototype.hasOwnProperty.call(_module, enc)) exports[enc] = _module[enc];
	    }
	}

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	// Export Node.js internal encodings.

	module.exports = {
	    // Encodings
	    utf8: { type: "_internal", bomAware: true },
	    cesu8: { type: "_internal", bomAware: true },
	    unicode11utf8: "utf8",

	    ucs2: { type: "_internal", bomAware: true },
	    utf16le: "ucs2",

	    binary: { type: "_internal" },
	    base64: { type: "_internal" },
	    hex: { type: "_internal" },

	    // Codec.
	    _internal: InternalCodec
	};

	//------------------------------------------------------------------------------

	function InternalCodec(codecOptions, iconv) {
	    this.enc = codecOptions.encodingName;
	    this.bomAware = codecOptions.bomAware;

	    if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
	        this.enc = "utf8"; // Use utf8 for decoding.
	        this.encoder = InternalEncoderCesu8;

	        // Add decoder for versions of Node not supporting CESU-8
	        if (new Buffer("eda080", 'hex').toString().length == 3) {
	            this.decoder = InternalDecoderCesu8;
	            this.defaultCharUnicode = iconv.defaultCharUnicode;
	        }
	    }
	}

	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;

	//------------------------------------------------------------------------------

	// We use node.js internal decoder. Its signature is the same as ours.
	var StringDecoder = __webpack_require__(247).StringDecoder;

	if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
	    StringDecoder.prototype.end = function () {};

	function InternalDecoder(options, codec) {
	    StringDecoder.call(this, codec.enc);
	}

	InternalDecoder.prototype = StringDecoder.prototype;

	//------------------------------------------------------------------------------
	// Encoder is mostly trivial

	function InternalEncoder(options, codec) {
	    this.enc = codec.enc;
	}

	InternalEncoder.prototype.write = function (str) {
	    return new Buffer(str, this.enc);
	};

	InternalEncoder.prototype.end = function () {};

	//------------------------------------------------------------------------------
	// Except base64 encoder, which must keep its state.

	function InternalEncoderBase64(options, codec) {
	    this.prevStr = '';
	}

	InternalEncoderBase64.prototype.write = function (str) {
	    str = this.prevStr + str;
	    var completeQuads = str.length - str.length % 4;
	    this.prevStr = str.slice(completeQuads);
	    str = str.slice(0, completeQuads);

	    return new Buffer(str, "base64");
	};

	InternalEncoderBase64.prototype.end = function () {
	    return new Buffer(this.prevStr, "base64");
	};

	//------------------------------------------------------------------------------
	// CESU-8 encoder is also special.

	function InternalEncoderCesu8(options, codec) {}

	InternalEncoderCesu8.prototype.write = function (str) {
	    var buf = new Buffer(str.length * 3),
	        bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	        var charCode = str.charCodeAt(i);
	        // Naive implementation, but it works because CESU-8 is especially easy
	        // to convert from UTF-16 (which all JS strings are encoded in).
	        if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
	            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        } else {
	            // charCode will always be < 0x10000 in javascript.
	            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	            buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	    }
	    return buf.slice(0, bufIdx);
	};

	InternalEncoderCesu8.prototype.end = function () {};

	//------------------------------------------------------------------------------
	// CESU-8 decoder is not implemented in Node v4.0+

	function InternalDecoderCesu8(options, codec) {
	    this.acc = 0;
	    this.contBytes = 0;
	    this.accBytes = 0;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	}

	InternalDecoderCesu8.prototype.write = function (buf) {
	    var acc = this.acc,
	        contBytes = this.contBytes,
	        accBytes = this.accBytes,
	        res = '';
	    for (var i = 0; i < buf.length; i++) {
	        var curByte = buf[i];
	        if ((curByte & 0xC0) !== 0x80) {
	            // Leading byte
	            if (contBytes > 0) {
	                // Previous code is invalid
	                res += this.defaultCharUnicode;
	                contBytes = 0;
	            }

	            if (curByte < 0x80) {
	                // Single-byte code
	                res += String.fromCharCode(curByte);
	            } else if (curByte < 0xE0) {
	                // Two-byte code
	                acc = curByte & 0x1F;
	                contBytes = 1;accBytes = 1;
	            } else if (curByte < 0xF0) {
	                // Three-byte code
	                acc = curByte & 0x0F;
	                contBytes = 2;accBytes = 1;
	            } else {
	                // Four or more are not supported for CESU-8.
	                res += this.defaultCharUnicode;
	            }
	        } else {
	            // Continuation byte
	            if (contBytes > 0) {
	                // We're waiting for it.
	                acc = acc << 6 | curByte & 0x3f;
	                contBytes--;accBytes++;
	                if (contBytes === 0) {
	                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	                    if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
	                        // Actually add character.
	                        res += String.fromCharCode(acc);
	                }
	            } else {
	                // Unexpected continuation byte
	                res += this.defaultCharUnicode;
	            }
	        }
	    }
	    this.acc = acc;this.contBytes = contBytes;this.accBytes = accBytes;
	    return res;
	};

	InternalDecoderCesu8.prototype.end = function () {
	    var res = 0;
	    if (this.contBytes > 0) res += this.defaultCharUnicode;
	    return res;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	// == UTF16-BE codec. ==========================================================

	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}

	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;

	// -- Encoding

	function Utf16BEEncoder() {}

	Utf16BEEncoder.prototype.write = function (str) {
	    var buf = new Buffer(str, 'ucs2');
	    for (var i = 0; i < buf.length; i += 2) {
	        var tmp = buf[i];buf[i] = buf[i + 1];buf[i + 1] = tmp;
	    }
	    return buf;
	};

	Utf16BEEncoder.prototype.end = function () {};

	// -- Decoding

	function Utf16BEDecoder() {
	    this.overflowByte = -1;
	}

	Utf16BEDecoder.prototype.write = function (buf) {
	    if (buf.length == 0) return '';

	    var buf2 = new Buffer(buf.length + 1),
	        i = 0,
	        j = 0;

	    if (this.overflowByte !== -1) {
	        buf2[0] = buf[0];
	        buf2[1] = this.overflowByte;
	        i = 1;j = 2;
	    }

	    for (; i < buf.length - 1; i += 2, j += 2) {
	        buf2[j] = buf[i + 1];
	        buf2[j + 1] = buf[i];
	    }

	    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;

	    return buf2.slice(0, j).toString('ucs2');
	};

	Utf16BEDecoder.prototype.end = function () {};

	// == UTF-16 codec =============================================================
	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	// Defaults to UTF-16LE, as it's prevalent and default in Node.
	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}

	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;

	// -- Encoding (pass-through)

	function Utf16Encoder(options, codec) {
	    options = options || {};
	    if (options.addBOM === undefined) options.addBOM = true;
	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
	}

	Utf16Encoder.prototype.write = function (str) {
	    return this.encoder.write(str);
	};

	Utf16Encoder.prototype.end = function () {
	    return this.encoder.end();
	};

	// -- Decoding

	function Utf16Decoder(options, codec) {
	    this.decoder = null;
	    this.initialBytes = [];
	    this.initialBytesLen = 0;

	    this.options = options || {};
	    this.iconv = codec.iconv;
	}

	Utf16Decoder.prototype.write = function (buf) {
	    if (!this.decoder) {
	        // Codec is not chosen yet. Accumulate initial bytes.
	        this.initialBytes.push(buf);
	        this.initialBytesLen += buf.length;

	        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
	            return '';

	        // We have enough bytes -> detect endianness.
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);
	        this.initialBytes.length = this.initialBytesLen = 0;
	    }

	    return this.decoder.write(buf);
	};

	Utf16Decoder.prototype.end = function () {
	    if (!this.decoder) {
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var res = this.decoder.write(buf),
	            trail = this.decoder.end();

	        return trail ? res + trail : res;
	    }
	    return this.decoder.end();
	};

	function detectEncoding(buf, defaultEncoding) {
	    var enc = defaultEncoding || 'utf-16le';

	    if (buf.length >= 2) {
	        // Check BOM.
	        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
	            enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
	            enc = 'utf-16le';else {
	            // No BOM found. Try to deduce encoding from initial content.
	            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	            // So, we count ASCII as if it was LE or BE, and decide from that.
	            var asciiCharsLE = 0,
	                asciiCharsBE = 0,
	                // Counts of chars in both positions
	            _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.

	            for (var i = 0; i < _len; i += 2) {
	                if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
	                if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
	            }

	            if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
	        }
	    }

	    return enc;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
	function Utf7Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	};

	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;

	// -- Encoding

	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

	function Utf7Encoder(options, codec) {
	    this.iconv = codec.iconv;
	}

	Utf7Encoder.prototype.write = function (str) {
	    // Naive implementation.
	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	    return new Buffer(str.replace(nonDirectChars, function (chunk) {
	        return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
	    }.bind(this)));
	};

	Utf7Encoder.prototype.end = function () {};

	// -- Decoding

	function Utf7Decoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++) {
	    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	}var plusChar = '+'.charCodeAt(0),
	    minusChar = '-'.charCodeAt(0),
	    andChar = '&'.charCodeAt(0);

	Utf7Decoder.prototype.write = function (buf) {
	    var res = "",
	        lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) {
	            // We're in direct mode.
	            // Write direct chars until '+'
	            if (buf[i] == plusChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i + 1;
	                inBase64 = true;
	            }
	        } else {
	            // We decode base64.
	            if (!base64Chars[buf[i]]) {
	                // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) {
	                    // "+-" -> "+"
	                    res += "+";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString();
	                    res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus is absorbed after base64.
	                    i--;

	                lastI = i + 1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString();

	        var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7Decoder.prototype.end = function () {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};

	// UTF-7-IMAP codec.
	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	// Differences:
	//  * Base64 part is started by "&" instead of "+"
	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
	//  * In Base64, "," is used instead of "/"
	//  * Base64 must not be used to represent direct characters.
	//  * No implicit shift back from Base64 (should always end with '-')
	//  * String must end in non-shifted position.
	//  * "-&" while in base64 is not allowed.


	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
	    this.iconv = iconv;
	};

	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;

	// -- Encoding

	function Utf7IMAPEncoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = new Buffer(6);
	    this.base64AccumIdx = 0;
	}

	Utf7IMAPEncoder.prototype.write = function (str) {
	    var inBase64 = this.inBase64,
	        base64Accum = this.base64Accum,
	        base64AccumIdx = this.base64AccumIdx,
	        buf = new Buffer(str.length * 5 + 10),
	        bufIdx = 0;

	    for (var i = 0; i < str.length; i++) {
	        var uChar = str.charCodeAt(i);
	        if (0x20 <= uChar && uChar <= 0x7E) {
	            // Direct character or '&'.
	            if (inBase64) {
	                if (base64AccumIdx > 0) {
	                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	                    base64AccumIdx = 0;
	                }

	                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	                inBase64 = false;
	            }

	            if (!inBase64) {
	                buf[bufIdx++] = uChar; // Write direct character

	                if (uChar === andChar) // Ampersand -> '&-'
	                    buf[bufIdx++] = minusChar;
	            }
	        } else {
	            // Non-direct character
	            if (!inBase64) {
	                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	                inBase64 = true;
	            }
	            if (inBase64) {
	                base64Accum[base64AccumIdx++] = uChar >> 8;
	                base64Accum[base64AccumIdx++] = uChar & 0xFF;

	                if (base64AccumIdx == base64Accum.length) {
	                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
	                    base64AccumIdx = 0;
	                }
	            }
	        }
	    }

	    this.inBase64 = inBase64;
	    this.base64AccumIdx = base64AccumIdx;

	    return buf.slice(0, bufIdx);
	};

	Utf7IMAPEncoder.prototype.end = function () {
	    var buf = new Buffer(10),
	        bufIdx = 0;
	    if (this.inBase64) {
	        if (this.base64AccumIdx > 0) {
	            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	            this.base64AccumIdx = 0;
	        }

	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	        this.inBase64 = false;
	    }

	    return buf.slice(0, bufIdx);
	};

	// -- Decoding

	function Utf7IMAPDecoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[','.charCodeAt(0)] = true;

	Utf7IMAPDecoder.prototype.write = function (buf) {
	    var res = "",
	        lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.
	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) {
	            // We're in direct mode.
	            // Write direct chars until '&'
	            if (buf[i] == andChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i + 1;
	                inBase64 = true;
	            }
	        } else {
	            // We decode base64.
	            if (!base64IMAPChars[buf[i]]) {
	                // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) {
	                    // "&-" -> "&"
	                    res += "&";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
	                    res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus may be absorbed after base64.
	                    i--;

	                lastI = i + 1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

	        var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7IMAPDecoder.prototype.end = function () {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	// correspond to encoded bytes (if 128 - then lower half is ASCII). 

	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
	    if (!codecOptions) throw new Error("SBCS codec is called without the data.");

	    // Prepare char buffer for decoding.
	    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");

	    if (codecOptions.chars.length === 128) {
	        var asciiString = "";
	        for (var i = 0; i < 128; i++) {
	            asciiString += String.fromCharCode(i);
	        }codecOptions.chars = asciiString + codecOptions.chars;
	    }

	    this.decodeBuf = new Buffer(codecOptions.chars, 'ucs2');

	    // Encoding buffer.
	    var encodeBuf = new Buffer(65536);
	    encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));

	    for (var i = 0; i < codecOptions.chars.length; i++) {
	        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
	    }this.encodeBuf = encodeBuf;
	}

	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;

	function SBCSEncoder(options, codec) {
	    this.encodeBuf = codec.encodeBuf;
	}

	SBCSEncoder.prototype.write = function (str) {
	    var buf = new Buffer(str.length);
	    for (var i = 0; i < str.length; i++) {
	        buf[i] = this.encodeBuf[str.charCodeAt(i)];
	    }return buf;
	};

	SBCSEncoder.prototype.end = function () {};

	function SBCSDecoder(options, codec) {
	    this.decodeBuf = codec.decodeBuf;
	}

	SBCSDecoder.prototype.write = function (buf) {
	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	    var decodeBuf = this.decodeBuf;
	    var newBuf = new Buffer(buf.length * 2);
	    var idx1 = 0,
	        idx2 = 0;
	    for (var i = 0; i < buf.length; i++) {
	        idx1 = buf[i] * 2;idx2 = i * 2;
	        newBuf[idx2] = decodeBuf[idx1];
	        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
	    }
	    return newBuf.toString('ucs2');
	};

	SBCSDecoder.prototype.end = function () {};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 315 */
/***/ function(module, exports) {

	"use strict";

	// Manually added data to be used by sbcs codec in addition to generated one.

	module.exports = {
	    // Not supported by iconv, not sure why.
	    "10029": "maccenteuro",
	    "maccenteuro": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "808": "cp808",
	    "ibm808": "cp808",
	    "cp808": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    // Aliases of generated encodings.
	    "ascii8bit": "ascii",
	    "usascii": "ascii",
	    "ansix34": "ascii",
	    "ansix341968": "ascii",
	    "ansix341986": "ascii",
	    "csascii": "ascii",
	    "cp367": "ascii",
	    "ibm367": "ascii",
	    "isoir6": "ascii",
	    "iso646us": "ascii",
	    "iso646irv": "ascii",
	    "us": "ascii",

	    "latin1": "iso88591",
	    "latin2": "iso88592",
	    "latin3": "iso88593",
	    "latin4": "iso88594",
	    "latin5": "iso88599",
	    "latin6": "iso885910",
	    "latin7": "iso885913",
	    "latin8": "iso885914",
	    "latin9": "iso885915",
	    "latin10": "iso885916",

	    "csisolatin1": "iso88591",
	    "csisolatin2": "iso88592",
	    "csisolatin3": "iso88593",
	    "csisolatin4": "iso88594",
	    "csisolatincyrillic": "iso88595",
	    "csisolatinarabic": "iso88596",
	    "csisolatingreek": "iso88597",
	    "csisolatinhebrew": "iso88598",
	    "csisolatin5": "iso88599",
	    "csisolatin6": "iso885910",

	    "l1": "iso88591",
	    "l2": "iso88592",
	    "l3": "iso88593",
	    "l4": "iso88594",
	    "l5": "iso88599",
	    "l6": "iso885910",
	    "l7": "iso885913",
	    "l8": "iso885914",
	    "l9": "iso885915",
	    "l10": "iso885916",

	    "isoir14": "iso646jp",
	    "isoir57": "iso646cn",
	    "isoir100": "iso88591",
	    "isoir101": "iso88592",
	    "isoir109": "iso88593",
	    "isoir110": "iso88594",
	    "isoir144": "iso88595",
	    "isoir127": "iso88596",
	    "isoir126": "iso88597",
	    "isoir138": "iso88598",
	    "isoir148": "iso88599",
	    "isoir157": "iso885910",
	    "isoir166": "tis620",
	    "isoir179": "iso885913",
	    "isoir199": "iso885914",
	    "isoir203": "iso885915",
	    "isoir226": "iso885916",

	    "cp819": "iso88591",
	    "ibm819": "iso88591",

	    "cyrillic": "iso88595",

	    "arabic": "iso88596",
	    "arabic8": "iso88596",
	    "ecma114": "iso88596",
	    "asmo708": "iso88596",

	    "greek": "iso88597",
	    "greek8": "iso88597",
	    "ecma118": "iso88597",
	    "elot928": "iso88597",

	    "hebrew": "iso88598",
	    "hebrew8": "iso88598",

	    "turkish": "iso88599",
	    "turkish8": "iso88599",

	    "thai": "iso885911",
	    "thai8": "iso885911",

	    "celtic": "iso885914",
	    "celtic8": "iso885914",
	    "isoceltic": "iso885914",

	    "tis6200": "tis620",
	    "tis62025291": "tis620",
	    "tis62025330": "tis620",

	    "10000": "macroman",
	    "10006": "macgreek",
	    "10007": "maccyrillic",
	    "10079": "maciceland",
	    "10081": "macturkish",

	    "cspc8codepage437": "cp437",
	    "cspc775baltic": "cp775",
	    "cspc850multilingual": "cp850",
	    "cspcp852": "cp852",
	    "cspc862latinhebrew": "cp862",
	    "cpgr": "cp869",

	    "msee": "cp1250",
	    "mscyrl": "cp1251",
	    "msansi": "cp1252",
	    "msgreek": "cp1253",
	    "msturk": "cp1254",
	    "mshebr": "cp1255",
	    "msarab": "cp1256",
	    "winbaltrim": "cp1257",

	    "cp20866": "koi8r",
	    "20866": "koi8r",
	    "ibm878": "koi8r",
	    "cskoi8r": "koi8r",

	    "cp21866": "koi8u",
	    "21866": "koi8u",
	    "ibm1168": "koi8u",

	    "strk10482002": "rk1048",

	    "tcvn5712": "tcvn",
	    "tcvn57121": "tcvn",

	    "gb198880": "iso646cn",
	    "cn": "iso646cn",

	    "csiso14jisc6220ro": "iso646jp",
	    "jisc62201969ro": "iso646jp",
	    "jp": "iso646jp",

	    "cshproman8": "hproman8",
	    "r8": "hproman8",
	    "roman8": "hproman8",
	    "xroman8": "hproman8",
	    "ibm1051": "hproman8",

	    "mac": "macintosh",
	    "csmacintosh": "macintosh"
	};

/***/ },
/* 316 */
/***/ function(module, exports) {

	"use strict";

	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.

	module.exports = {
	  "437": "cp437",
	  "737": "cp737",
	  "775": "cp775",
	  "850": "cp850",
	  "852": "cp852",
	  "855": "cp855",
	  "856": "cp856",
	  "857": "cp857",
	  "858": "cp858",
	  "860": "cp860",
	  "861": "cp861",
	  "862": "cp862",
	  "863": "cp863",
	  "864": "cp864",
	  "865": "cp865",
	  "866": "cp866",
	  "869": "cp869",
	  "874": "windows874",
	  "922": "cp922",
	  "1046": "cp1046",
	  "1124": "cp1124",
	  "1125": "cp1125",
	  "1129": "cp1129",
	  "1133": "cp1133",
	  "1161": "cp1161",
	  "1162": "cp1162",
	  "1163": "cp1163",
	  "1250": "windows1250",
	  "1251": "windows1251",
	  "1252": "windows1252",
	  "1253": "windows1253",
	  "1254": "windows1254",
	  "1255": "windows1255",
	  "1256": "windows1256",
	  "1257": "windows1257",
	  "1258": "windows1258",
	  "28591": "iso88591",
	  "28592": "iso88592",
	  "28593": "iso88593",
	  "28594": "iso88594",
	  "28595": "iso88595",
	  "28596": "iso88596",
	  "28597": "iso88597",
	  "28598": "iso88598",
	  "28599": "iso88599",
	  "28600": "iso885910",
	  "28601": "iso885911",
	  "28603": "iso885913",
	  "28604": "iso885914",
	  "28605": "iso885915",
	  "28606": "iso885916",
	  "windows874": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win874": "windows874",
	  "cp874": "windows874",
	  "windows1250": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1250": "windows1250",
	  "cp1250": "windows1250",
	  "windows1251": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1251": "windows1251",
	  "cp1251": "windows1251",
	  "windows1252": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1252": "windows1252",
	  "cp1252": "windows1252",
	  "windows1253": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1253": "windows1253",
	  "cp1253": "windows1253",
	  "windows1254": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1254": "windows1254",
	  "cp1254": "windows1254",
	  "windows1255": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1255": "windows1255",
	  "cp1255": "windows1255",
	  "windows1256": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1256": "windows1256",
	  "cp1256": "windows1256",
	  "windows1257": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1257": "windows1257",
	  "cp1257": "windows1257",
	  "windows1258": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1258": "windows1258",
	  "cp1258": "windows1258",
	  "iso88591": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28591": "iso88591",
	  "iso88592": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28592": "iso88592",
	  "iso88593": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28593": "iso88593",
	  "iso88594": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28594": "iso88594",
	  "iso88595": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28595": "iso88595",
	  "iso88596": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28596": "iso88596",
	  "iso88597": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28597": "iso88597",
	  "iso88598": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28598": "iso88598",
	  "iso88599": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28599": "iso88599",
	  "iso885910": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28600": "iso885910",
	  "iso885911": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28601": "iso885911",
	  "iso885913": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28603": "iso885913",
	  "iso885914": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28604": "iso885914",
	  "iso885915": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28605": "iso885915",
	  "iso885916": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28606": "iso885916",
	  "cp437": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm437": "cp437",
	  "csibm437": "cp437",
	  "cp737": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm737": "cp737",
	  "csibm737": "cp737",
	  "cp775": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm775": "cp775",
	  "csibm775": "cp775",
	  "cp850": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm850": "cp850",
	  "csibm850": "cp850",
	  "cp852": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm852": "cp852",
	  "csibm852": "cp852",
	  "cp855": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm855": "cp855",
	  "csibm855": "cp855",
	  "cp856": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm856": "cp856",
	  "csibm856": "cp856",
	  "cp857": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm857": "cp857",
	  "csibm857": "cp857",
	  "cp858": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm858": "cp858",
	  "csibm858": "cp858",
	  "cp860": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm860": "cp860",
	  "csibm860": "cp860",
	  "cp861": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm861": "cp861",
	  "csibm861": "cp861",
	  "cp862": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm862": "cp862",
	  "csibm862": "cp862",
	  "cp863": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm863": "cp863",
	  "csibm863": "cp863",
	  "cp864": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "ibm864": "cp864",
	  "csibm864": "cp864",
	  "cp865": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm865": "cp865",
	  "csibm865": "cp865",
	  "cp866": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm866": "cp866",
	  "csibm866": "cp866",
	  "cp869": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm869": "cp869",
	  "csibm869": "cp869",
	  "cp922": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm922": "cp922",
	  "csibm922": "cp922",
	  "cp1046": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1046": "cp1046",
	  "csibm1046": "cp1046",
	  "cp1124": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1124": "cp1124",
	  "csibm1124": "cp1124",
	  "cp1125": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1125": "cp1125",
	  "csibm1125": "cp1125",
	  "cp1129": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1129": "cp1129",
	  "csibm1129": "cp1129",
	  "cp1133": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1133": "cp1133",
	  "csibm1133": "cp1133",
	  "cp1161": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1161": "cp1161",
	  "csibm1161": "cp1161",
	  "cp1162": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1162": "cp1162",
	  "csibm1162": "cp1162",
	  "cp1163": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1163": "cp1163",
	  "csibm1163": "cp1163",
	  "maccroatian": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maccyrillic": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macgreek": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maciceland": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macroman": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macromania": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macthai": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macturkish": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macukraine": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8r": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8u": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8ru": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8t": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "armscii8": {
	    "type": "_sbcs",
	    "chars": ")(.,-"
	  },
	  "rk1048": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tcvn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "georgianacademy": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "georgianps": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "pt154": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "viscii": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "iso646cn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "iso646jp": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "hproman8": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macintosh": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ascii": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tis620": {
	    "type": "_sbcs",
	    "chars": ""
	  }
	};

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	// To save memory and loading time, we read table files only when requested.

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports._dbcs = DBCSCodec;

	var UNASSIGNED = -1,
	    GB18030_CODE = -2,
	    SEQ_START = -10,
	    NODE_START = -1000,
	    UNASSIGNED_NODE = new Array(0x100),
	    DEF_CHAR = -1;

	for (var i = 0; i < 0x100; i++) {
	    UNASSIGNED_NODE[i] = UNASSIGNED;
	} // Class DBCSCodec reads and initializes mapping tables.
	function DBCSCodec(codecOptions, iconv) {
	    this.encodingName = codecOptions.encodingName;
	    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
	    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

	    // Load tables.
	    var mappingTable = codecOptions.table();

	    // Decode tables: MBCS -> Unicode.

	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	    // Trie root is decodeTables[0].
	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
	    //         == UNASSIGNED -> unknown/unassigned sequence.
	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	    //         <= NODE_START -> index of the next node in our trie to process next byte.
	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	    this.decodeTables = [];
	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
	    this.decodeTableSeq = [];

	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	    for (var i = 0; i < mappingTable.length; i++) {
	        this._addDecodeChunk(mappingTable[i]);
	    }this.defaultCharUnicode = iconv.defaultCharUnicode;

	    // Encode tables: Unicode -> DBCS.

	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	    //         == UNASSIGNED -> no conversion found. Output a default char.
	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	    this.encodeTable = [];

	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	    // means end of sequence (needed when one sequence is a strict subsequence of another).
	    // Objects are kept separately from encodeTable to increase performance.
	    this.encodeTableSeq = [];

	    // Some chars can be decoded, but need not be encoded.
	    var skipEncodeChars = {};
	    if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	        var val = codecOptions.encodeSkipVals[i];
	        if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) {
	            skipEncodeChars[j] = true;
	        }
	    }

	    // Use decode trie to recursively fill out encode tables.
	    this._fillEncodeTable(0, 0, skipEncodeChars);

	    // Add more encoding pairs when needed.
	    if (codecOptions.encodeAdd) {
	        for (var uChar in codecOptions.encodeAdd) {
	            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
	        }
	    }

	    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

	    // Load & create GB18030 tables when needed.
	    if (typeof codecOptions.gb18030 === 'function') {
	        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

	        // Add GB18030 decode tables.
	        var thirdByteNodeIdx = this.decodeTables.length;
	        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

	        var fourthByteNodeIdx = this.decodeTables.length;
	        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

	        for (var i = 0x81; i <= 0xFE; i++) {
	            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
	            var secondByteNode = this.decodeTables[secondByteNodeIdx];
	            for (var j = 0x30; j <= 0x39; j++) {
	                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
	            }
	        }
	        for (var i = 0x81; i <= 0xFE; i++) {
	            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
	        }for (var i = 0x30; i <= 0x39; i++) {
	            fourthByteNode[i] = GB18030_CODE;
	        }
	    }
	}

	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;

	// Decoder helpers
	DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
	    var bytes = [];
	    for (; addr > 0; addr >>= 8) {
	        bytes.push(addr & 0xFF);
	    }if (bytes.length == 0) bytes.push(0);

	    var node = this.decodeTables[0];
	    for (var i = bytes.length - 1; i > 0; i--) {
	        // Traverse nodes deeper into the trie.
	        var val = node[bytes[i]];

	        if (val == UNASSIGNED) {
	            // Create new node.
	            node[bytes[i]] = NODE_START - this.decodeTables.length;
	            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	        } else if (val <= NODE_START) {
	            // Existing node.
	            node = this.decodeTables[NODE_START - val];
	        } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
	    }
	    return node;
	};

	DBCSCodec.prototype._addDecodeChunk = function (chunk) {
	    // First element of chunk is the hex mbcs code where we start.
	    var curAddr = parseInt(chunk[0], 16);

	    // Choose the decoding node where we'll write our chars.
	    var writeTable = this._getDecodeTrieNode(curAddr);
	    curAddr = curAddr & 0xFF;

	    // Write all other elements of the chunk to the table.
	    for (var k = 1; k < chunk.length; k++) {
	        var part = chunk[k];
	        if (typeof part === "string") {
	            // String, write as-is.
	            for (var l = 0; l < part.length;) {
	                var code = part.charCodeAt(l++);
	                if (0xD800 <= code && code < 0xDC00) {
	                    // Decode surrogate
	                    var codeTrail = part.charCodeAt(l++);
	                    if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
	                } else if (0x0FF0 < code && code <= 0x0FFF) {
	                    // Character sequence (our own encoding used)
	                    var len = 0xFFF - code + 2;
	                    var seq = [];
	                    for (var m = 0; m < len; m++) {
	                        seq.push(part.charCodeAt(l++));
	                    } // Simple variation: don't support surrogates or subsequences in seq.

	                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	                    this.decodeTableSeq.push(seq);
	                } else writeTable[curAddr++] = code; // Basic char
	            }
	        } else if (typeof part === "number") {
	            // Integer, meaning increasing sequence starting with prev character.
	            var charCode = writeTable[curAddr - 1] + 1;
	            for (var l = 0; l < part; l++) {
	                writeTable[curAddr++] = charCode++;
	            }
	        } else throw new Error("Incorrect type '" + (typeof part === "undefined" ? "undefined" : _typeof(part)) + "' given in " + this.encodingName + " at chunk " + chunk[0]);
	    }
	    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};

	// Encoder helpers
	DBCSCodec.prototype._getEncodeBucket = function (uCode) {
	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	    if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
	    return this.encodeTable[high];
	};

	DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
	    else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};

	DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {

	    // Get the root of character tree according to first character of the sequence.
	    var uCode = seq[0];
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;

	    var node;
	    if (bucket[low] <= SEQ_START) {
	        // There's already a sequence with  - use it.
	        node = this.encodeTableSeq[SEQ_START - bucket[low]];
	    } else {
	        // There was no sequence object - allocate a new one.
	        node = {};
	        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	        bucket[low] = SEQ_START - this.encodeTableSeq.length;
	        this.encodeTableSeq.push(node);
	    }

	    // Traverse the character tree, allocating new nodes as needed.
	    for (var j = 1; j < seq.length - 1; j++) {
	        var oldVal = node[uCode];
	        if ((typeof oldVal === "undefined" ? "undefined" : _typeof(oldVal)) === 'object') node = oldVal;else {
	            node = node[uCode] = {};
	            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
	        }
	    }

	    // Set the leaf to given dbcsCode.
	    uCode = seq[seq.length - 1];
	    node[uCode] = dbcsCode;
	};

	DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
	    var node = this.decodeTables[nodeIdx];
	    for (var i = 0; i < 0x100; i++) {
	        var uCode = node[i];
	        var mbCode = prefix + i;
	        if (skipEncodeChars[mbCode]) continue;

	        if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	    }
	};

	// == Encoder ==================================================================

	function DBCSEncoder(options, codec) {
	    // Encoder state
	    this.leadSurrogate = -1;
	    this.seqObj = undefined;

	    // Static data
	    this.encodeTable = codec.encodeTable;
	    this.encodeTableSeq = codec.encodeTableSeq;
	    this.defaultCharSingleByte = codec.defCharSB;
	    this.gb18030 = codec.gb18030;
	}

	DBCSEncoder.prototype.write = function (str) {
	    var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)),
	        leadSurrogate = this.leadSurrogate,
	        seqObj = this.seqObj,
	        nextChar = -1,
	        i = 0,
	        j = 0;

	    while (true) {
	        // 0. Get next character.
	        if (nextChar === -1) {
	            if (i == str.length) break;
	            var uCode = str.charCodeAt(i++);
	        } else {
	            var uCode = nextChar;
	            nextChar = -1;
	        }

	        // 1. Handle surrogates.
	        if (0xD800 <= uCode && uCode < 0xE000) {
	            // Char is one of surrogates.
	            if (uCode < 0xDC00) {
	                // We've got lead surrogate.
	                if (leadSurrogate === -1) {
	                    leadSurrogate = uCode;
	                    continue;
	                } else {
	                    leadSurrogate = uCode;
	                    // Double lead surrogate found.
	                    uCode = UNASSIGNED;
	                }
	            } else {
	                // We've got trail surrogate.
	                if (leadSurrogate !== -1) {
	                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	                    leadSurrogate = -1;
	                } else {
	                    // Incomplete surrogate pair - only trail surrogate found.
	                    uCode = UNASSIGNED;
	                }
	            }
	        } else if (leadSurrogate !== -1) {
	            // Incomplete surrogate pair - only lead surrogate found.
	            nextChar = uCode;uCode = UNASSIGNED; // Write an error, then current char.
	            leadSurrogate = -1;
	        }

	        // 2. Convert uCode character.
	        var dbcsCode = UNASSIGNED;
	        if (seqObj !== undefined && uCode != UNASSIGNED) {
	            // We are in the middle of the sequence
	            var resCode = seqObj[uCode];
	            if ((typeof resCode === "undefined" ? "undefined" : _typeof(resCode)) === 'object') {
	                // Sequence continues.
	                seqObj = resCode;
	                continue;
	            } else if (typeof resCode == 'number') {
	                // Sequence finished. Write it.
	                dbcsCode = resCode;
	            } else if (resCode == undefined) {
	                // Current character is not part of the sequence.

	                // Try default character for this sequence
	                resCode = seqObj[DEF_CHAR];
	                if (resCode !== undefined) {
	                    dbcsCode = resCode; // Found. Write it.
	                    nextChar = uCode; // Current character will be written too in the next iteration.
	                } else {
	                        // TODO: What if we have no default? (resCode == undefined)
	                        // Then, we should write first char of the sequence as-is and try the rest recursively.
	                        // Didn't do it for now because no encoding has this situation yet.
	                        // Currently, just skip the sequence and write current char.
	                    }
	            }
	            seqObj = undefined;
	        } else if (uCode >= 0) {
	            // Regular character
	            var subtable = this.encodeTable[uCode >> 8];
	            if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];

	            if (dbcsCode <= SEQ_START) {
	                // Sequence start
	                seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
	                continue;
	            }

	            if (dbcsCode == UNASSIGNED && this.gb18030) {
	                // Use GB18030 algorithm to find character(s) to write.
	                var idx = findIdx(this.gb18030.uChars, uCode);
	                if (idx != -1) {
	                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);dbcsCode = dbcsCode % 12600;
	                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);dbcsCode = dbcsCode % 1260;
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);dbcsCode = dbcsCode % 10;
	                    newBuf[j++] = 0x30 + dbcsCode;
	                    continue;
	                }
	            }
	        }

	        // 3. Write dbcsCode character.
	        if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;

	        if (dbcsCode < 0x100) {
	            newBuf[j++] = dbcsCode;
	        } else if (dbcsCode < 0x10000) {
	            newBuf[j++] = dbcsCode >> 8; // high byte
	            newBuf[j++] = dbcsCode & 0xFF; // low byte
	        } else {
	            newBuf[j++] = dbcsCode >> 16;
	            newBuf[j++] = dbcsCode >> 8 & 0xFF;
	            newBuf[j++] = dbcsCode & 0xFF;
	        }
	    }

	    this.seqObj = seqObj;
	    this.leadSurrogate = leadSurrogate;
	    return newBuf.slice(0, j);
	};

	DBCSEncoder.prototype.end = function () {
	    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

	    var newBuf = new Buffer(10),
	        j = 0;

	    if (this.seqObj) {
	        // We're in the sequence.
	        var dbcsCode = this.seqObj[DEF_CHAR];
	        if (dbcsCode !== undefined) {
	            // Write beginning of the sequence.
	            if (dbcsCode < 0x100) {
	                newBuf[j++] = dbcsCode;
	            } else {
	                newBuf[j++] = dbcsCode >> 8; // high byte
	                newBuf[j++] = dbcsCode & 0xFF; // low byte
	            }
	        } else {
	                // See todo above.
	            }
	        this.seqObj = undefined;
	    }

	    if (this.leadSurrogate !== -1) {
	        // Incomplete surrogate pair - only lead surrogate found.
	        newBuf[j++] = this.defaultCharSingleByte;
	        this.leadSurrogate = -1;
	    }

	    return newBuf.slice(0, j);
	};

	// Export for testing
	DBCSEncoder.prototype.findIdx = findIdx;

	// == Decoder ==================================================================

	function DBCSDecoder(options, codec) {
	    // Decoder state
	    this.nodeIdx = 0;
	    this.prevBuf = new Buffer(0);

	    // Static data
	    this.decodeTables = codec.decodeTables;
	    this.decodeTableSeq = codec.decodeTableSeq;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	    this.gb18030 = codec.gb18030;
	}

	DBCSDecoder.prototype.write = function (buf) {
	    var newBuf = new Buffer(buf.length * 2),
	        nodeIdx = this.nodeIdx,
	        prevBuf = this.prevBuf,
	        prevBufOffset = this.prevBuf.length,
	        seqStart = -this.prevBuf.length,
	        // idx of the start of current parsed sequence.
	    uCode;

	    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
	        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);

	    for (var i = 0, j = 0; i < buf.length; i++) {
	        var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

	        // Lookup in current trie node.
	        var uCode = this.decodeTables[nodeIdx][curByte];

	        if (uCode >= 0) {
	            // Normal character, just use it.
	        } else if (uCode === UNASSIGNED) {
	            // Unknown char.
	            // TODO: Callback with seq.
	            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
	            uCode = this.defaultCharUnicode.charCodeAt(0);
	        } else if (uCode === GB18030_CODE) {
	            var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
	            var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
	            var idx = findIdx(this.gb18030.gbChars, ptr);
	            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	        } else if (uCode <= NODE_START) {
	            // Go to next trie node.
	            nodeIdx = NODE_START - uCode;
	            continue;
	        } else if (uCode <= SEQ_START) {
	            // Output a sequence of chars.
	            var seq = this.decodeTableSeq[SEQ_START - uCode];
	            for (var k = 0; k < seq.length - 1; k++) {
	                uCode = seq[k];
	                newBuf[j++] = uCode & 0xFF;
	                newBuf[j++] = uCode >> 8;
	            }
	            uCode = seq[seq.length - 1];
	        } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

	        // Write the character to buffer, handling higher planes using surrogate pair.
	        if (uCode > 0xFFFF) {
	            uCode -= 0x10000;
	            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
	            newBuf[j++] = uCodeLead & 0xFF;
	            newBuf[j++] = uCodeLead >> 8;

	            uCode = 0xDC00 + uCode % 0x400;
	        }
	        newBuf[j++] = uCode & 0xFF;
	        newBuf[j++] = uCode >> 8;

	        // Reset trie node.
	        nodeIdx = 0;seqStart = i + 1;
	    }

	    this.nodeIdx = nodeIdx;
	    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
	    return newBuf.slice(0, j).toString('ucs2');
	};

	DBCSDecoder.prototype.end = function () {
	    var ret = '';

	    // Try to parse all remaining chars.
	    while (this.prevBuf.length > 0) {
	        // Skip 1 character in the buffer.
	        ret += this.defaultCharUnicode;
	        var buf = this.prevBuf.slice(1);

	        // Parse remaining as usual.
	        this.prevBuf = new Buffer(0);
	        this.nodeIdx = 0;
	        if (buf.length > 0) ret += this.write(buf);
	    }

	    this.nodeIdx = 0;
	    return ret;
	};

	// Binary search for GB18030. Returns largest i such that table[i] <= val.
	function findIdx(table, val) {
	    if (table[0] > val) return -1;

	    var l = 0,
	        r = table.length;
	    while (l < r - 1) {
	        // always table[l] <= val < table[r]
	        var mid = l + Math.floor((r - l + 1) / 2);
	        if (table[mid] <= val) l = mid;else r = mid;
	    }
	    return l;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Description of supported double byte encodings and aliases.
	// Tables are not require()-d until they are needed to speed up library load.
	// require()-s are direct to support Browserify.

	module.exports = {

	    // == Japanese/ShiftJIS ====================================================
	    // All japanese encodings are based on JIS X set of standards:
	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
	    //              Has several variations in 1978, 1983, 1990 and 1997.
	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	    //              2 planes, first is superset of 0208, second - revised 0212.
	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

	    // Byte encodings are:
	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	    //               0x00-0x7F       - lower part of 0201
	    //               0x8E, 0xA1-0xDF - upper part of 0201
	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	    //               Used as-is in ISO2022 family.
	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
	    //                0201-1976 Roman, 0208-1978, 0208-1983.
	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	    //
	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	    //
	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html


	    'shiftjis': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(319);
	        },
	        encodeAdd: { '': 0x5C, '': 0x7E },
	        encodeSkipVals: [{ from: 0xED40, to: 0xF940 }]
	    },
	    'csshiftjis': 'shiftjis',
	    'mskanji': 'shiftjis',
	    'sjis': 'shiftjis',
	    'windows31j': 'shiftjis',
	    'xsjis': 'shiftjis',
	    'windows932': 'shiftjis',
	    '932': 'shiftjis',
	    'cp932': 'shiftjis',

	    'eucjp': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(320);
	        },
	        encodeAdd: { '': 0x5C, '': 0x7E }
	    },

	    // TODO: KDDI extension to Shift_JIS
	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

	    // == Chinese/GBK ==========================================================
	    // http://en.wikipedia.org/wiki/GBK

	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	    'gb2312': 'cp936',
	    'gb231280': 'cp936',
	    'gb23121980': 'cp936',
	    'csgb2312': 'cp936',
	    'csiso58gb231280': 'cp936',
	    'euccn': 'cp936',
	    'isoir58': 'gbk',

	    // Microsoft's CP936 is a subset and approximation of GBK.
	    // TODO: Euro = 0x80 in cp936, but not in GBK (where it's valid but undefined)
	    'windows936': 'cp936',
	    '936': 'cp936',
	    'cp936': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(321);
	        }
	    },

	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	    'gbk': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(321).concat(__webpack_require__(322));
	        }
	    },
	    'xgbk': 'gbk',

	    // GB18030 is an algorithmic extension of GBK.
	    'gb18030': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(321).concat(__webpack_require__(322));
	        },
	        gb18030: function gb18030() {
	            return __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./tables/gb18030-ranges.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	        }
	    },

	    'chinese': 'gb18030',

	    // TODO: Support GB18030 (~27000 chars + whole unicode mapping, cp54936)
	    // http://icu-project.org/docs/papers/gb18030.html
	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0

	    // == Korean ===============================================================
	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	    'windows949': 'cp949',
	    '949': 'cp949',
	    'cp949': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(324);
	        }
	    },

	    'cseuckr': 'cp949',
	    'csksc56011987': 'cp949',
	    'euckr': 'cp949',
	    'isoir149': 'cp949',
	    'korean': 'cp949',
	    'ksc56011987': 'cp949',
	    'ksc56011989': 'cp949',
	    'ksc5601': 'cp949',

	    // == Big5/Taiwan/Hong Kong ================================================
	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	    // Variations, in roughly number of defined chars:
	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	    //    Plus, it has 4 combining sequences.
	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	    // 
	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

	    'windows950': 'cp950',
	    '950': 'cp950',
	    'cp950': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(325);
	        }
	    },

	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	    'big5': 'big5hkscs',
	    'big5hkscs': {
	        type: '_dbcs',
	        table: function table() {
	            return __webpack_require__(325).concat(__webpack_require__(326));
	        },
	        encodeSkipVals: [0xa2cc]
	    },

	    'cnbig5': 'big5hkscs',
	    'csbig5': 'big5hkscs',
	    'xxbig5': 'big5hkscs'

	};

/***/ },
/* 319 */
/***/ function(module, exports) {

	[
	["0","\u0000",128],
	["a1","",62],
	["8140","",9,""],
	["8180",""],
	["81b8",""],
	["81c8",""],
	["81da",""],
	["81f0",""],
	["81fc",""],
	["824f","",9],
	["8260","",25],
	["8281","",25],
	["829f","",82],
	["8340","",62],
	["8380","",22],
	["839f","",16,"",6],
	["83bf","",16,"",6],
	["8440","",5,"",25],
	["8470","",5,"",7],
	["8480","",17],
	["849f",""],
	["8740","",19,"",9],
	["875f",""],
	["877e",""],
	["8780","",4,""],
	["889f",""],
	["8940",""],
	["8980",""],
	["8a40",""],
	["8a80",""],
	["8b40",""],
	["8b80",""],
	["8c40",""],
	["8c80",""],
	["8d40",""],
	["8d80",""],
	["8e40",""],
	["8e80",""],
	["8f40",""],
	["8f80",""],
	["9040",""],
	["9080",""],
	["9140",""],
	["9180",""],
	["9240",""],
	["9280",""],
	["9340",""],
	["9380",""],
	["9440",""],
	["9480",""],
	["9540",""],
	["9580",""],
	["9640",""],
	["9680",""],
	["9740",""],
	["9780",""],
	["9840",""],
	["989f",""],
	["9940",""],
	["9980",""],
	["9a40",""],
	["9a80",""],
	["9b40",""],
	["9b80",""],
	["9c40",""],
	["9c80",""],
	["9d40",""],
	["9d80",""],
	["9e40",""],
	["9e80",""],
	["9f40",""],
	["9f80",""],
	["e040",""],
	["e080",""],
	["e140",""],
	["e180",""],
	["e240",""],
	["e280",""],
	["e340",""],
	["e380",""],
	["e440",""],
	["e480",""],
	["e540",""],
	["e580",""],
	["e640",""],
	["e680",""],
	["e740",""],
	["e780",""],
	["e840",""],
	["e880",""],
	["e940",""],
	["e980",""],
	["ea40",""],
	["ea80",""],
	["ed40",""],
	["ed80",""],
	["ee40",""],
	["ee80",""],
	["eeef","",9,""],
	["f040","",62],
	["f080","",124],
	["f140","",62],
	["f180","",124],
	["f240","",62],
	["f280","",124],
	["f340","",62],
	["f380","",124],
	["f440","",62],
	["f480","",124],
	["f540","",62],
	["f580","",124],
	["f640","",62],
	["f680","",124],
	["f740","",62],
	["f780","",124],
	["f840","",62],
	["f880","",124],
	["f940",""],
	["fa40","",9,"",9,""],
	["fa80",""],
	["fb40",""],
	["fb80",""],
	["fc40",""]
	]


/***/ },
/* 320 */
/***/ function(module, exports) {

	[
	["0","\u0000",127],
	["8ea1","",62],
	["a1a1","",9,""],
	["a2a1",""],
	["a2ba",""],
	["a2ca",""],
	["a2dc",""],
	["a2f2",""],
	["a2fe",""],
	["a3b0","",9],
	["a3c1","",25],
	["a3e1","",25],
	["a4a1","",82],
	["a5a1","",85],
	["a6a1","",16,"",6],
	["a6c1","",16,"",6],
	["a7a1","",5,"",25],
	["a7d1","",5,"",25],
	["a8a1",""],
	["ada1","",19,"",9],
	["adc0",""],
	["addf","",4,""],
	["b0a1",""],
	["b1a1",""],
	["b2a1",""],
	["b3a1",""],
	["b4a1",""],
	["b5a1",""],
	["b6a1",""],
	["b7a1",""],
	["b8a1",""],
	["b9a1",""],
	["baa1",""],
	["bba1",""],
	["bca1",""],
	["bda1",""],
	["bea1",""],
	["bfa1",""],
	["c0a1",""],
	["c1a1",""],
	["c2a1",""],
	["c3a1",""],
	["c4a1",""],
	["c5a1",""],
	["c6a1",""],
	["c7a1",""],
	["c8a1",""],
	["c9a1",""],
	["caa1",""],
	["cba1",""],
	["cca1",""],
	["cda1",""],
	["cea1",""],
	["cfa1",""],
	["d0a1",""],
	["d1a1",""],
	["d2a1",""],
	["d3a1",""],
	["d4a1",""],
	["d5a1",""],
	["d6a1",""],
	["d7a1",""],
	["d8a1",""],
	["d9a1",""],
	["daa1",""],
	["dba1",""],
	["dca1",""],
	["dda1",""],
	["dea1",""],
	["dfa1",""],
	["e0a1",""],
	["e1a1",""],
	["e2a1",""],
	["e3a1",""],
	["e4a1",""],
	["e5a1",""],
	["e6a1",""],
	["e7a1",""],
	["e8a1",""],
	["e9a1",""],
	["eaa1",""],
	["eba1",""],
	["eca1",""],
	["eda1",""],
	["eea1",""],
	["efa1",""],
	["f0a1",""],
	["f1a1",""],
	["f2a1",""],
	["f3a1",""],
	["f4a1",""],
	["f9a1",""],
	["faa1",""],
	["fba1",""],
	["fca1",""],
	["fcf1","",9,""],
	["8fa2af",""],
	["8fa2c2",""],
	["8fa2eb",""],
	["8fa6e1",""],
	["8fa6e7",""],
	["8fa6e9",""],
	["8fa6ec",""],
	["8fa6f1",""],
	["8fa7c2","",10,""],
	["8fa7f2","",10,""],
	["8fa9a1",""],
	["8fa9a4",""],
	["8fa9a6",""],
	["8fa9a8",""],
	["8fa9ab",""],
	["8fa9af",""],
	["8fa9c1",""],
	["8faaa1",""],
	["8faaba",""],
	["8faba1",""],
	["8fabbd",""],
	["8fabc5",""],
	["8fb0a1",""],
	["8fb1a1",""],
	["8fb2a1","",4,""],
	["8fb3a1",""],
	["8fb4a1",""],
	["8fb5a1",""],
	["8fb6a1","",5,"",4,""],
	["8fb7a1","",4,""],
	["8fb8a1",""],
	["8fb9a1",""],
	["8fbaa1","",4,""],
	["8fbba1",""],
	["8fbca1","",4,""],
	["8fbda1","",4,""],
	["8fbea1","",4,""],
	["8fbfa1",""],
	["8fc0a1",""],
	["8fc1a1",""],
	["8fc2a1",""],
	["8fc3a1","",4,""],
	["8fc4a1",""],
	["8fc5a1",""],
	["8fc6a1",""],
	["8fc7a1",""],
	["8fc8a1",""],
	["8fc9a1","",4,"",4,""],
	["8fcaa1",""],
	["8fcba1",""],
	["8fcca1","",9,""],
	["8fcda1","",5,""],
	["8fcea1","",6,""],
	["8fcfa1",""],
	["8fd0a1",""],
	["8fd1a1",""],
	["8fd2a1","",5],
	["8fd3a1",""],
	["8fd4a1","",4,""],
	["8fd5a1",""],
	["8fd6a1",""],
	["8fd7a1",""],
	["8fd8a1",""],
	["8fd9a1","",4,"",6,""],
	["8fdaa1","",4,""],
	["8fdba1","",6,""],
	["8fdca1","",4,""],
	["8fdda1","",4,""],
	["8fdea1","",4,""],
	["8fdfa1",""],
	["8fe0a1",""],
	["8fe1a1","",4,""],
	["8fe2a1",""],
	["8fe3a1","",5,"",4,""],
	["8fe4a1","",4,""],
	["8fe5a1","",4,""],
	["8fe6a1",""],
	["8fe7a1",""],
	["8fe8a1","",4,""],
	["8fe9a1","",4],
	["8feaa1","",4,""],
	["8feba1","",4,""],
	["8feca1",""],
	["8feda1","",4,"",4,""]
	]


/***/ },
/* 321 */
/***/ function(module, exports) {

	[
	["0","\u0000",127,""],
	["8140","",5,"",9,"",6,""],
	["8180","",6,"",4,"",4,"",5,""],
	["8240","",4,"",8,"",4,"",11],
	["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],
	["8340","",17,"",5,"",10,"",4,"",9,""],
	["8380","",5,"",13,"",28,"",4,"",4,"",5],
	["8440","",5,"",5,""],
	["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],
	["8540","",9,""],
	["8580","",4,"",6,"",4,"",4,"",7,""],
	["8640","",4,"",5,"",4,"",5,""],
	["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],
	["8740","",7,"",11,"",4,"",4],
	["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],
	["8840","",9,"",4,"",4,""],
	["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],
	["8940","",5,"",6,"",4,"",5,"",4,"",16,""],
	["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],
	["8a40","",4,"",12,""],
	["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],
	["8b40","",8,"",17,"",6,"",13,""],
	["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],
	["8c40","",7,""],
	["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],
	["8d40","",5,"",5,"",5,"",6,"",9,"",4],
	["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],
	["8e40","",21,"",12,"",6,"",12,""],
	["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],
	["8f40","",5,"",11,"",8,""],
	["8f80","",6,"",14,"",5,"",5,"",4,""],
	["9040","",4,"",4,"",6,""],
	["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],
	["9140","",6,"",6,"",18,"",4,""],
	["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],
	["9240","",6,"",5,""],
	["9280","",5,"",7,"",6,""],
	["9340","",6,"",4,"",4,"",5,""],
	["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],
	["9440","",24,"",7,"",7,"",4,"",8],
	["9480","",4,"",4,"",14,"",7,"",7,""],
	["9540","",4,"",4,"",6,""],
	["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],
	["9640","",5,"",4,""],
	["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],
	["9740","",7,"",8,"",7,"",9,""],
	["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],
	["9840","",4,"",5,"",9,""],
	["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],
	["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],
	["9980","",114,"",6],
	["9a40","",11,"",7,"",13,""],
	["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],
	["9b40","",4,""],
	["9b80","",5,"",4,"",4,"",5,""],
	["9c40","",7,""],
	["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],
	["9d40","",7,"",4,"",9,"",6,""],
	["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],
	["9e40","",7,"",32,"",7,"",6,"",6],
	["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],
	["9f40","",6,"",10,"",4,"",10,"",7,""],
	["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],
	["a040","",9,"",5,"",9,"",11,"",19],
	["a080","",9,"",6,"",4,"",11,"",11,"",6,""],
	["a1a1","",7,""],
	["a2a1","",9],
	["a2b1","",19,"",19,"",9],
	["a2e5","",9],
	["a2f1","",11],
	["a3a1","",88,""],
	["a4a1","",82],
	["a5a1","",85],
	["a6a1","",16,"",6],
	["a6c1","",16,"",6],
	["a6e0",""],
	["a6ee",""],
	["a6f4",""],
	["a7a1","",5,"",25],
	["a7d1","",5,"",25],
	["a840","",35,"",6],
	["a880","",7,""],
	["a8a1",""],
	["a8bd",""],
	["a8c0",""],
	["a8c5","",36],
	["a940","",8,""],
	["a959",""],
	["a95c",""],
	["a960","",9,"",8],
	["a980","",4,""],
	["a996",""],
	["a9a4","",75],
	["aa40","",5,"",5,"",8],
	["aa80","",7,"",10,""],
	["ab40","",11,"",4,"",5,"",4],
	["ab80","",6,"",4],
	["ac40","",10,"",8,"",5,"",4,"",11],
	["ac80","",6,"",12,"",4,""],
	["ad40","",10,"",7,"",15,"",12],
	["ad80","",9,"",8,"",6,""],
	["ae40","",6,"",7,"",4,""],
	["ae80","",7,"",6,"",4,""],
	["af40","",4,""],
	["af80",""],
	["b040","",6,"",5,"",4,"",6,"",7,""],
	["b080","",7,"",8,"",9,""],
	["b140","",4,"",7,"",10,""],
	["b180","",4,"",7,"",7,""],
	["b240","",11,"",5,"",11,"",4],
	["b280","",12,"",8,"",4,""],
	["b340","",5,""],
	["b380","",11,"",7,"",6,""],
	["b440","",7,"",9],
	["b480","",4,"",5,"",6,""],
	["b540","",5,"",9,"",4,"",14,"",4,"",8,""],
	["b580","",6,"",4,""],
	["b640","",6,"",11,"",10,"",4,"",5,""],
	["b680","",6,"",4,""],
	["b740","",14,"",5,"",9,"",4,"",16],
	["b780","",6,""],
	["b840","",4,"",10,"",10,"",9,"",5,""],
	["b880","",4,""],
	["b940","",5,"",10,"",6,""],
	["b980","",7,""],
	["ba40","",4,"",4,"",7,"",5,""],
	["ba80","",4,"",5,"",12,"",5,""],
	["bb40","",9,"",36,"",5,"",9],
	["bb80","",6,"",4,""],
	["bc40","",6,"",6,"",5,"",7,"",13,"",5],
	["bc80","",14,"",6,""],
	["bd40","",54,"",7],
	["bd80","",32,""],
	["be40","",12,"",6,"",42],
	["be80","",32,""],
	["bf40","",62],
	["bf80","",4,"",4,"",21,""],
	["c040","",35,"",23,""],
	["c080","",6,"",9,""],
	["c140","",4,"",7,"",4,"",4,"",6,""],
	["c180","",4,"",4,"",5,""],
	["c240","",6,"",5,""],
	["c280","",13,"",5,"",11,""],
	["c340","",5,"",4,"",6,""],
	["c380","",12,"",4,""],
	["c440","",5,"",4,"",4,"",5,"",4,""],
	["c480","",7,"",5,"",6,""],
	["c540","",14,"",4,"",5,"",4,"",5,""],
	["c580","",7,"",7,""],
	["c640",""],
	["c680","",4,"",9,""],
	["c740","",4,"",4,"",6,"",6,"",6,""],
	["c780",""],
	["c840","",4,"",5,"",5,"",7,"",5,"",7,""],
	["c880","",6,"",4,"",4,""],
	["c940","",4,"",7,"",12,""],
	["c980","",4,"",4,"",10,""],
	["ca40","",8,"",8,"",9,"",4,"",10],
	["ca80","",4,"",8,""],
	["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],
	["cb80","",5,"",6,"",14,""],
	["cc40","",4,"",10,"",15,"",13,""],
	["cc80","",11,"",4,"",7,""],
	["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],
	["cd80",""],
	["ce40","",6,"",5,"",7,""],
	["ce80","",4,"",6,"",4,""],
	["cf40","",4,"",4,"",6,"",9],
	["cf80","",5,"",7,"",4,""],
	["d040","",13,"",5,"",5,"",5,"",6,""],
	["d080","",4,"",4,"",5,""],
	["d140","",4,"",4,"",6,"",5],
	["d180","",4,"",4,"",4,""],
	["d240","",8,"",24,"",5,"",19,""],
	["d280","",26,""],
	["d340","",30,"",6],
	["d380","",4,"",5,"",21,""],
	["d440","",31,"",8,"",21],
	["d480","",25,"",6,""],
	["d540","",7,"",7,"",46],
	["d580","",32,""],
	["d640","",34,"",27],
	["d680","",30,""],
	["d740","",31,"",4,"",25],
	["d780","",24,""],
	["d840","",8,"",7,"",5,"",6,"",6,"",6,""],
	["d880","",6,"",20,""],
	["d940","",62],
	["d980","",32,""],
	["da40","",14,"",8,"",4,"",9,""],
	["da80","",12,""],
	["db40","",6,"",7,"",4,""],
	["db80","",4,"",5,"",11,""],
	["dc40","",4,"",6,"",6,"",11,"",6,"",7],
	["dc80","",10,"",21,""],
	["dd40","",62],
	["dd80","",32,""],
	["de40","",32,""],
	["de80","",4,""],
	["df40","",5,"",4,"",4,"",5,"",4,"",6,""],
	["df80","",4,""],
	["e040","",19,""],
	["e080","",10,"",6,"",8,""],
	["e140","",4,"",6,"",5,"",5,""],
	["e180","",10,"",9,"",8,""],
	["e240","",62],
	["e280","",32,"",5,""],
	["e340","",45,"",16],
	["e380","",7,"",24,""],
	["e440","",5,"",24,"",31],
	["e480","",32,""],
	["e540","",51,"",10],
	["e580","",31,""],
	["e640","",34,"",27],
	["e680","",29,""],
	["e740","",7,"",54],
	["e780","",32,"",6,"",4,""],
	["e840","",14,"",43,""],
	["e880","",20,""],
	["e940","",7,"",42],
	["e980","",32,""],
	["ea40","",27,"",6,""],
	["ea80","",4,"",12,""],
	["eb40","",9,"",7,"",9,"",6,""],
	["eb80","",4,""],
	["ec40","",8,"",4,"",18,"",7],
	["ec80","",4,"",7,"",4,"",4,""],
	["ed40","",6,"",46],
	["ed80","",4,"",23,""],
	["ee40","",62],
	["ee80","",32,"",4,"",6,""],
	["ef40","",5,"",37,"",4],
	["ef80","",30,"",4,"",8,""],
	["f040","",4,"",28,"",26],
	["f080","",9,"",12,"",4,"",6,""],
	["f140","",10,"",47],
	["f180","",32,""],
	["f240","",62],
	["f280","",32,""],
	["f340","",17,"",6,"",4,""],
	["f380","",8,"",6,""],
	["f440","",5,"",10,"",10,"",7,"",5],
	["f480","",32,""],
	["f540","",62],
	["f580","",32,""],
	["f640","",62],
	["f680","",32,"",5,"",5,"",4,"",7,""],
	["f740","",62],
	["f780","",4,"",4,""],
	["f840","",62],
	["f880","",32],
	["f940","",62],
	["f980","",32],
	["fa40","",62],
	["fa80","",32],
	["fb40","",27,"",9,""],
	["fb80","",5,"",8,"",5,""],
	["fc40","",8,"",4,"",8,"",6],
	["fc80","",4,"",5,"",8,""],
	["fd40","",4,"",4,"",10,"",38],
	["fd80","",5,"",11,"",4,""],
	["fe40",""]
	]


/***/ },
/* 322 */
/***/ function(module, exports) {

	[
	["a140","",62],
	["a180","",32],
	["a240","",62],
	["a280","",32],
	["a2ab","",5],
	["a2e3",""],
	["a2ef",""],
	["a2fd",""],
	["a340","",62],
	["a380","",31,""],
	["a440","",62],
	["a480","",32],
	["a4f4","",10],
	["a540","",62],
	["a580","",32],
	["a5f7","",7],
	["a640","",62],
	["a680","",32],
	["a6b9","",7],
	["a6d9","",6],
	["a6ec",""],
	["a6f3",""],
	["a6f6","",8],
	["a740","",62],
	["a780","",32],
	["a7c2","",14],
	["a7f2","",12],
	["a896","",10],
	["a8bc",""],
	["a8bf",""],
	["a8c1",""],
	["a8ea","",20],
	["a958",""],
	["a95b",""],
	["a95d",""],
	["a989","",11],
	["a997","",12],
	["a9f0","",14],
	["aaa1","",93],
	["aba1","",93],
	["aca1","",93],
	["ada1","",93],
	["aea1","",93],
	["afa1","",93],
	["d7fa","",4],
	["f8a1","",93],
	["f9a1","",93],
	["faa1","",93],
	["fba1","",93],
	["fca1","",93],
	["fda1","",93],
	["fe50",""],
	["fe80","",6,"",93]
	]


/***/ },
/* 323 */,
/* 324 */
/***/ function(module, exports) {

	[
	["0","\u0000",127],
	["8141","",4,"",6,""],
	["8161","",9,"",5,""],
	["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],
	["8241","",7,"",5],
	["8261","",6,"",5,""],
	["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],
	["8341","",5,"",5,"",7],
	["8361","",18,""],
	["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],
	["8441","",5,"",8],
	["8461","",18],
	["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],
	["8541","",5,"",4,"",6,"",4],
	["8561","",5,"",5,"",6,""],
	["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],
	["8641","",6,"",5,""],
	["8661","",6,"",10],
	["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],
	["8741","",9,"",15],
	["8761","",18,""],
	["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],
	["8841","",4,"",5,"",6,"",4],
	["8861","",4,""],
	["8881","",15,"",4,"",6,"",5,"",54,""],
	["8941","",6,"",5,""],
	["8961","",10,"",5,""],
	["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],
	["8a41","",10,"",6,""],
	["8a61","",4,"",18,""],
	["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],
	["8b41","",5,"",4,"",6,""],
	["8b61","",6,"",8],
	["8b81","",52,"",4,"",6,"",5,"",18,"",18],
	["8c41","",15,"",4],
	["8c61","",6,"",5,"",6,"",5],
	["8c81","",12,"",26,"",50,"",5,"",16],
	["8d41","",16,"",8],
	["8d61","",17,""],
	["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],
	["8e41","",6,"",5,"",8],
	["8e61","",4,"",19],
	["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],
	["8f41","",7,"",17],
	["8f61","",7,"",6,"",4],
	["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],
	["9041","",6,"",5,""],
	["9061","",5,"",15],
	["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],
	["9141","",6,"",5],
	["9161","",9,"",5],
	["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],
	["9241","",7,"",4,""],
	["9261","",7,"",7,"",4],
	["9281","",21,"",18,"",6,"",7,"",6,"",35,""],
	["9341","",4,""],
	["9361","",6,"",8],
	["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],
	["9441","",5,"",5,"",8],
	["9461","",5,"",6,"",12],
	["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],
	["9541","",11,"",5,""],
	["9561","",6,"",5,""],
	["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],
	["9641","",23,""],
	["9661","",6,"",5,"",8],
	["9681","",10,"",5,"",13,"",33,"",6,"",44],
	["9741","",16,"",8],
	["9761","",17,"",7],
	["9781","",11,"",5,"",6,"",89,""],
	["9841","",16,"",5,""],
	["9861","",6,"",15],
	["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],
	["9941","",6,"",5,""],
	["9961","",6,"",5,""],
	["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],
	["9a41","",16],
	["9a61","",6,"",6,""],
	["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],
	["9b41","",6,"",8],
	["9b61","",17,"",7],
	["9b81","",25,"",4,"",5,"",50,"",22,""],
	["9c41","",4,"",5,"",5],
	["9c61","",8,"",6,"",9],
	["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],
	["9d41","",13,"",8],
	["9d61","",25],
	["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],
	["9e41","",7,"",9,""],
	["9e61","",4,"",6,""],
	["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],
	["9f41","",5,"",4,"",5,""],
	["9f61","",6,"",5,""],
	["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],
	["a041","",5,"",6,""],
	["a061","",5,"",13],
	["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],
	["a141","",18,""],
	["a161","",6,"",5,""],
	["a181","",14,"",5,"",4,"",9,""],
	["a241","",5,"",18],
	["a261","",6,"",18],
	["a281","",7,"",6,"",7,""],
	["a341","",6,"",10,""],
	["a361","",6,"",16],
	["a381","",16,"",4,"",58,"",32,""],
	["a441","",5,""],
	["a461","",5,"",12],
	["a481","",28,"",93],
	["a541","",4,"",6,"",5,""],
	["a561","",17,"",5,""],
	["a581","",16,"",14,"",9],
	["a5b0","",9],
	["a5c1","",16,"",6],
	["a5e1","",16,"",6],
	["a641","",19,""],
	["a661","",5,"",5,"",6],
	["a681","",6,"",18,"",7],
	["a741","",4,"",6,"",7],
	["a761","",22,""],
	["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],
	["a841","",10,"",14],
	["a861","",18,"",6],
	["a881","",19,"",11,""],
	["a8a6",""],
	["a8a8",""],
	["a8b1","",27,"",25,"",14,""],
	["a941","",14,"",10],
	["a961","",18],
	["a981","",14,"",6,"",27,"",25,"",14,""],
	["aa41","",6,"",4,""],
	["aa61","",4,"",5,"",6,""],
	["aa81","",29,"",82],
	["ab41","",6,"",5,""],
	["ab61","",6,"",5,"",5],
	["ab81","",8,"",6,"",12,"",85],
	["ac41","",5,"",6,""],
	["ac61","",11,"",4],
	["ac81","",28,"",5,"",25],
	["acd1","",5,"",25],
	["ad41","",6,"",5,"",7],
	["ad61","",6,"",10,""],
	["ad81","",5,"",18,""],
	["ae41","",5,"",16],
	["ae61","",5,"",6,"",4],
	["ae81","",6,"",5,""],
	["af41","",19],
	["af61","",13,"",5,""],
	["af81","",5,"",6,"",5,""],
	["b041","",5,"",5,"",12],
	["b061","",5,"",19],
	["b081","",13,"",6,"",5,"",7,"",4,""],
	["b141","",6,"",5,""],
	["b161","",6,"",5,"",11],
	["b181","",14,"",6,""],
	["b241","",6,"",5,""],
	["b261","",18,"",5,""],
	["b281","",5,"",18,"",6,""],
	["b341","",19,""],
	["b361","",5,"",5,"",5],
	["b381","",5,"",5,"",19,"",4,""],
	["b441","",5,"",6,"",5],
	["b461","",6,"",10,""],
	["b481","",6,"",18,"",4,"",4,""],
	["b541","",14,"",5],
	["b561","",5,"",5,"",4],
	["b581","",6,"",5,"",11,""],
	["b641","",7,"",17],
	["b661","",15,""],
	["b681","",5,"",6,"",5,""],
	["b741","",13,"",6,""],
	["b761","",20,""],
	["b781","",6,"",14,""],
	["b841","",7,"",17],
	["b861","",8,"",13],
	["b881","",5,"",24,"",4,""],
	["b941","",6,"",5,""],
	["b961","",14,"",6,""],
	["b981","",22,"",4,"",4,""],
	["ba41","",5,"",6,""],
	["ba61","",5,"",4,"",5],
	["ba81","",6,"",9,""],
	["bb41","",4,"",5,"",4,""],
	["bb61","",6,"",5,""],
	["bb81","",31,""],
	["bc41","",17,""],
	["bc61","",5,"",6,""],
	["bc81","",4,"",6,"",5,"",5,"",4,""],
	["bd41","",7,"",7,""],
	["bd61","",5,"",13],
	["bd81","",5,"",25,""],
	["be41","",7,"",14],
	["be61","",7,"",7,""],
	["be81","",4,"",4,"",5,"",8,"",6,""],
	["bf41","",10,"",14],
	["bf61","",18,""],
	["bf81","",5,"",7,"",6,"",5,""],
	["c041","",5,"",6,"",5],
	["c061","",25],
	["c081","",6,"",5,"",7,""],
	["c141","",5,"",6,""],
	["c161","",19,""],
	["c181","",31,""],
	["c241","",4,"",5,""],
	["c261","",4,"",5,"",6,""],
	["c281","",5,"",7,"",9,""],
	["c341","",4],
	["c361","",4,"",5,"",11],
	["c381","",5,"",7,"",5,""],
	["c441","",7,"",7,""],
	["c461","",5,"",4],
	["c481","",5,"",11,""],
	["c541","",6,"",5,""],
	["c561","",6,"",5,"",4],
	["c581","",6,"",5,""],
	["c641","",6,"",5],
	["c6a1",""],
	["c7a1",""],
	["c8a1",""],
	["caa1",""],
	["cba1",""],
	["cca1",""],
	["cda1",""],
	["cea1",""],
	["cfa1",""],
	["d0a1",""],
	["d1a1","",5,"",4,""],
	["d2a1","",4,"",5,"",10,"",7,"",5,""],
	["d3a1",""],
	["d4a1",""],
	["d5a1",""],
	["d6a1",""],
	["d7a1",""],
	["d8a1",""],
	["d9a1",""],
	["daa1",""],
	["dba1",""],
	["dca1",""],
	["dda1",""],
	["dea1",""],
	["dfa1",""],
	["e0a1",""],
	["e1a1",""],
	["e2a1",""],
	["e3a1",""],
	["e4a1",""],
	["e5a1",""],
	["e6a1",""],
	["e7a1",""],
	["e8a1",""],
	["e9a1",""],
	["eaa1",""],
	["eba1",""],
	["eca1",""],
	["eda1",""],
	["eea1",""],
	["efa1",""],
	["f0a1",""],
	["f1a1",""],
	["f2a1",""],
	["f3a1",""],
	["f4a1",""],
	["f5a1",""],
	["f6a1",""],
	["f7a1",""],
	["f8a1",""],
	["f9a1",""],
	["faa1",""],
	["fba1",""],
	["fca1",""],
	["fda1",""]
	]


/***/ },
/* 325 */
/***/ function(module, exports) {

	[
	["0","\u0000",127],
	["a140",""],
	["a1a1","",4,""],
	["a240","",7,""],
	["a2a1","",9,"",9,"",8,"",25,"",21],
	["a340","",16,"",6,"",16,"",6,"",10],
	["a3a1","",25,""],
	["a3e1",""],
	["a440",""],
	["a4a1",""],
	["a540",""],
	["a5a1",""],
	["a640",""],
	["a6a1",""],
	["a740",""],
	["a7a1",""],
	["a840",""],
	["a8a1",""],
	["a940",""],
	["a9a1",""],
	["aa40",""],
	["aaa1",""],
	["ab40",""],
	["aba1",""],
	["ac40",""],
	["aca1",""],
	["ad40",""],
	["ada1",""],
	["ae40",""],
	["aea1",""],
	["af40",""],
	["afa1",""],
	["b040",""],
	["b0a1",""],
	["b140",""],
	["b1a1",""],
	["b240",""],
	["b2a1",""],
	["b340",""],
	["b3a1",""],
	["b440",""],
	["b4a1",""],
	["b540",""],
	["b5a1",""],
	["b640",""],
	["b6a1",""],
	["b740",""],
	["b7a1",""],
	["b840",""],
	["b8a1",""],
	["b940",""],
	["b9a1",""],
	["ba40",""],
	["baa1",""],
	["bb40",""],
	["bba1",""],
	["bc40",""],
	["bca1",""],
	["bd40",""],
	["bda1",""],
	["be40",""],
	["bea1",""],
	["bf40",""],
	["bfa1",""],
	["c040",""],
	["c0a1",""],
	["c140",""],
	["c1a1",""],
	["c240",""],
	["c2a1",""],
	["c340",""],
	["c3a1",""],
	["c440",""],
	["c4a1",""],
	["c540",""],
	["c5a1",""],
	["c640",""],
	["c940",""],
	["c9a1",""],
	["ca40",""],
	["caa1",""],
	["cb40",""],
	["cba1",""],
	["cc40",""],
	["cca1",""],
	["cd40",""],
	["cda1",""],
	["ce40",""],
	["cea1",""],
	["cf40",""],
	["cfa1",""],
	["d040",""],
	["d0a1",""],
	["d140",""],
	["d1a1",""],
	["d240",""],
	["d2a1",""],
	["d340",""],
	["d3a1",""],
	["d440",""],
	["d4a1",""],
	["d540",""],
	["d5a1",""],
	["d640",""],
	["d6a1",""],
	["d740",""],
	["d7a1",""],
	["d840",""],
	["d8a1",""],
	["d940",""],
	["d9a1",""],
	["da40",""],
	["daa1",""],
	["db40",""],
	["dba1",""],
	["dc40",""],
	["dca1",""],
	["dd40",""],
	["dda1",""],
	["de40",""],
	["dea1",""],
	["df40",""],
	["dfa1",""],
	["e040",""],
	["e0a1",""],
	["e140",""],
	["e1a1",""],
	["e240",""],
	["e2a1",""],
	["e340",""],
	["e3a1",""],
	["e440",""],
	["e4a1",""],
	["e540",""],
	["e5a1",""],
	["e640",""],
	["e6a1",""],
	["e740",""],
	["e7a1",""],
	["e840",""],
	["e8a1",""],
	["e940",""],
	["e9a1",""],
	["ea40",""],
	["eaa1",""],
	["eb40",""],
	["eba1",""],
	["ec40",""],
	["eca1",""],
	["ed40",""],
	["eda1",""],
	["ee40",""],
	["eea1",""],
	["ef40",""],
	["efa1",""],
	["f040",""],
	["f0a1",""],
	["f140",""],
	["f1a1",""],
	["f240",""],
	["f2a1",""],
	["f340",""],
	["f3a1",""],
	["f440",""],
	["f4a1",""],
	["f540",""],
	["f5a1",""],
	["f640",""],
	["f6a1",""],
	["f740",""],
	["f7a1",""],
	["f840",""],
	["f8a1",""],
	["f940",""],
	["f9a1",""]
	]


/***/ },
/* 326 */
/***/ function(module, exports) {

	[
	["8740",""],
	["8767",""],
	["87a1",""],
	["8840","",4,""],
	["88a1",""],
	["8940",""],
	["8943",""],
	["8946",""],
	["894c",""],
	["89a1",""],
	["89ab",""],
	["89b0",""],
	["89b5",""],
	["89c1",""],
	["89c5",""],
	["8a40",""],
	["8a43",""],
	["8a64",""],
	["8a76",""],
	["8aa1",""],
	["8aac",""],
	["8ab2",""],
	["8abb",""],
	["8ac9",""],
	["8ace",""],
	["8adf",""],
	["8af6",""],
	["8b40",""],
	["8b55",""],
	["8ba1",""],
	["8bde",""],
	["8c40",""],
	["8ca1",""],
	["8ca7",""],
	["8cc9",""],
	["8cce",""],
	["8ce6",""],
	["8d40",""],
	["8d42",""],
	["8da1",""],
	["8e40",""],
	["8ea1",""],
	["8f40",""],
	["8fa1",""],
	["9040",""],
	["90a1",""],
	["9140",""],
	["91a1",""],
	["9240",""],
	["92a1",""],
	["9340",""],
	["93a1",""],
	["9440",""],
	["94a1",""],
	["9540",""],
	["95a1",""],
	["9640",""],
	["96a1",""],
	["9740",""],
	["97a1",""],
	["9840",""],
	["98a1",""],
	["9940",""],
	["99a1",""],
	["9a40",""],
	["9aa1",""],
	["9b40",""],
	["9b62",""],
	["9ba1",""],
	["9c40",""],
	["9ca1",""],
	["9d40",""],
	["9da1",""],
	["9e40",""],
	["9ea1",""],
	["9ead",""],
	["9ec5",""],
	["9ef5",""],
	["9f40",""],
	["9f4f",""],
	["9fa1",""],
	["9fae",""],
	["9fb2",""],
	["9fc1",""],
	["9fc9",""],
	["9fdb",""],
	["9fe7",""],
	["9feb",""],
	["9ff0",""],
	["a040",""],
	["a055",""],
	["a058",""],
	["a05b",""],
	["a063",""],
	["a073",""],
	["a0a1",""],
	["a0a6",""],
	["a0ae",""],
	["a0b0",""],
	["a0d4",""],
	["a0e2",""],
	["a3c0","",31,""],
	["c6a1","",9,"",9,"",9,"",23],
	["c740","",58,""],
	["c7a1","",81,"",5,"",4],
	["c840","",26,"",25,""],
	["c8a1",""],
	["c8cd",""],
	["c8f5",""],
	["f9fe",""],
	["fa40",""],
	["faa1",""],
	["fb40",""],
	["fba1",""],
	["fc40",""],
	["fca1",""],
	["fd40",""],
	["fda1",""],
	["fe40",""],
	["fea1",""]
	]


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	var Transform = __webpack_require__(239).Transform;

	// == Exports ==================================================================
	module.exports = function (iconv) {

	    // Additional Public API.
	    iconv.encodeStream = function encodeStream(encoding, options) {
	        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
	    };

	    iconv.decodeStream = function decodeStream(encoding, options) {
	        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
	    };

	    iconv.supportsStreams = true;

	    // Not published yet.
	    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
	    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
	    iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};

	// == Encoder stream =======================================================
	function IconvLiteEncoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	    Transform.call(this, options);
	}

	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteEncoderStream }
	});

	IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
	    if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res);
	        done();
	    } catch (e) {
	        done(e);
	    }
	};

	IconvLiteEncoderStream.prototype._flush = function (done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res);
	        done();
	    } catch (e) {
	        done(e);
	    }
	};

	IconvLiteEncoderStream.prototype.collect = function (cb) {
	    var chunks = [];
	    this.on('error', cb);
	    this.on('data', function (chunk) {
	        chunks.push(chunk);
	    });
	    this.on('end', function () {
	        cb(null, Buffer.concat(chunks));
	    });
	    return this;
	};

	// == Decoder stream =======================================================
	function IconvLiteDecoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.encoding = this.encoding = 'utf8'; // We output strings.
	    Transform.call(this, options);
	}

	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteDecoderStream }
	});

	IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
	    if (!Buffer.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res, this.encoding);
	        done();
	    } catch (e) {
	        done(e);
	    }
	};

	IconvLiteDecoderStream.prototype._flush = function (done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res, this.encoding);
	        done();
	    } catch (e) {
	        done(e);
	    }
	};

	IconvLiteDecoderStream.prototype.collect = function (cb) {
	    var res = '';
	    this.on('error', cb);
	    this.on('data', function (chunk) {
	        res += chunk;
	    });
	    this.on('end', function () {
	        cb(null, res);
	    });
	    return this;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	// == Extend Node primitives to use iconv-lite =================================

	module.exports = function (iconv) {
	    var original = undefined; // Place to keep original methods.

	    // Node authors rewrote Buffer internals to make it compatible with
	    // Uint8Array and we cannot patch key functions since then.
	    iconv.supportsNodeEncodingsExtension = !(new Buffer(0) instanceof Uint8Array);

	    iconv.extendNodeEncodings = function extendNodeEncodings() {
	        if (original) return;
	        original = {};

	        if (!iconv.supportsNodeEncodingsExtension) {
	            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
	            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
	            return;
	        }

	        var nodeNativeEncodings = {
	            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true,
	            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true
	        };

	        Buffer.isNativeEncoding = function (enc) {
	            return enc && nodeNativeEncodings[enc.toLowerCase()];
	        };

	        // -- SlowBuffer -----------------------------------------------------------
	        var SlowBuffer = __webpack_require__(193).SlowBuffer;

	        original.SlowBufferToString = SlowBuffer.prototype.toString;
	        SlowBuffer.prototype.toString = function (encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);

	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        };

	        original.SlowBufferWrite = SlowBuffer.prototype.write;
	        SlowBuffer.prototype.write = function (string, offset, length, encoding) {
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {
	                // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }

	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);

	            if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;
	        };

	        // -- Buffer ---------------------------------------------------------------

	        original.BufferIsEncoding = Buffer.isEncoding;
	        Buffer.isEncoding = function (encoding) {
	            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
	        };

	        original.BufferByteLength = Buffer.byteLength;
	        Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);

	            // Slow, I know, but we don't have a better way yet.
	            return iconv.encode(str, encoding).length;
	        };

	        original.BufferToString = Buffer.prototype.toString;
	        Buffer.prototype.toString = function (encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);

	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        };

	        original.BufferWrite = Buffer.prototype.write;
	        Buffer.prototype.write = function (string, offset, length, encoding) {
	            var _offset = offset,
	                _length = length,
	                _encoding = encoding;
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {
	                // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }

	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);

	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }

	            if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;

	            // TODO: Set _charsWritten.
	        };

	        // -- Readable -------------------------------------------------------------
	        if (iconv.supportsStreams) {
	            var Readable = __webpack_require__(239).Readable;

	            original.ReadableSetEncoding = Readable.prototype.setEncoding;
	            Readable.prototype.setEncoding = function setEncoding(enc, options) {
	                // Use our own decoder, it has the same interface.
	                // We cannot use original function as it doesn't handle BOM-s.
	                this._readableState.decoder = iconv.getDecoder(enc, options);
	                this._readableState.encoding = enc;
	            };

	            Readable.prototype.collect = iconv._collect;
	        }
	    };

	    // Remove iconv-lite Node primitive extensions.
	    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
	        if (!iconv.supportsNodeEncodingsExtension) return;
	        if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");

	        delete Buffer.isNativeEncoding;

	        var SlowBuffer = __webpack_require__(193).SlowBuffer;

	        SlowBuffer.prototype.toString = original.SlowBufferToString;
	        SlowBuffer.prototype.write = original.SlowBufferWrite;

	        Buffer.isEncoding = original.BufferIsEncoding;
	        Buffer.byteLength = original.BufferByteLength;
	        Buffer.prototype.toString = original.BufferToString;
	        Buffer.prototype.write = original.BufferWrite;

	        if (iconv.supportsStreams) {
	            var Readable = __webpack_require__(239).Readable;

	            Readable.prototype.setEncoding = original.ReadableSetEncoding;
	            delete Readable.prototype.collect;
	        }

	        original = undefined;
	    };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {'use strict';

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Transform = __webpack_require__(252);

	var binding = __webpack_require__(330);
	var util = __webpack_require__(263);
	var assert = __webpack_require__(342).ok;

	// zlib doesn't provide these, so kludge them in following the same
	// const naming scheme zlib uses.
	binding.Z_MIN_WINDOWBITS = 8;
	binding.Z_MAX_WINDOWBITS = 15;
	binding.Z_DEFAULT_WINDOWBITS = 15;

	// fewer than 64 bytes per chunk is stupid.
	// technically it could work with as few as 8, but even 64 bytes
	// is absurdly low.  Usually a MB or more is best.
	binding.Z_MIN_CHUNK = 64;
	binding.Z_MAX_CHUNK = Infinity;
	binding.Z_DEFAULT_CHUNK = 16 * 1024;

	binding.Z_MIN_MEMLEVEL = 1;
	binding.Z_MAX_MEMLEVEL = 9;
	binding.Z_DEFAULT_MEMLEVEL = 8;

	binding.Z_MIN_LEVEL = -1;
	binding.Z_MAX_LEVEL = 9;
	binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

	// expose all the zlib constants
	Object.keys(binding).forEach(function (k) {
	  if (k.match(/^Z/)) exports[k] = binding[k];
	});

	// translation table for return codes.
	exports.codes = {
	  Z_OK: binding.Z_OK,
	  Z_STREAM_END: binding.Z_STREAM_END,
	  Z_NEED_DICT: binding.Z_NEED_DICT,
	  Z_ERRNO: binding.Z_ERRNO,
	  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
	  Z_DATA_ERROR: binding.Z_DATA_ERROR,
	  Z_MEM_ERROR: binding.Z_MEM_ERROR,
	  Z_BUF_ERROR: binding.Z_BUF_ERROR,
	  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
	};

	Object.keys(exports.codes).forEach(function (k) {
	  exports.codes[exports.codes[k]] = k;
	});

	exports.Deflate = Deflate;
	exports.Inflate = Inflate;
	exports.Gzip = Gzip;
	exports.Gunzip = Gunzip;
	exports.DeflateRaw = DeflateRaw;
	exports.InflateRaw = InflateRaw;
	exports.Unzip = Unzip;

	exports.createDeflate = function (o) {
	  return new Deflate(o);
	};

	exports.createInflate = function (o) {
	  return new Inflate(o);
	};

	exports.createDeflateRaw = function (o) {
	  return new DeflateRaw(o);
	};

	exports.createInflateRaw = function (o) {
	  return new InflateRaw(o);
	};

	exports.createGzip = function (o) {
	  return new Gzip(o);
	};

	exports.createGunzip = function (o) {
	  return new Gunzip(o);
	};

	exports.createUnzip = function (o) {
	  return new Unzip(o);
	};

	// Convenience methods.
	// compress/decompress a string or buffer in one step.
	exports.deflate = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Deflate(opts), buffer, callback);
	};

	exports.deflateSync = function (buffer, opts) {
	  return zlibBufferSync(new Deflate(opts), buffer);
	};

	exports.gzip = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gzip(opts), buffer, callback);
	};

	exports.gzipSync = function (buffer, opts) {
	  return zlibBufferSync(new Gzip(opts), buffer);
	};

	exports.deflateRaw = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
	};

	exports.deflateRawSync = function (buffer, opts) {
	  return zlibBufferSync(new DeflateRaw(opts), buffer);
	};

	exports.unzip = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Unzip(opts), buffer, callback);
	};

	exports.unzipSync = function (buffer, opts) {
	  return zlibBufferSync(new Unzip(opts), buffer);
	};

	exports.inflate = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Inflate(opts), buffer, callback);
	};

	exports.inflateSync = function (buffer, opts) {
	  return zlibBufferSync(new Inflate(opts), buffer);
	};

	exports.gunzip = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gunzip(opts), buffer, callback);
	};

	exports.gunzipSync = function (buffer, opts) {
	  return zlibBufferSync(new Gunzip(opts), buffer);
	};

	exports.inflateRaw = function (buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new InflateRaw(opts), buffer, callback);
	};

	exports.inflateRawSync = function (buffer, opts) {
	  return zlibBufferSync(new InflateRaw(opts), buffer);
	};

	function zlibBuffer(engine, buffer, callback) {
	  var buffers = [];
	  var nread = 0;

	  engine.on('error', onError);
	  engine.on('end', onEnd);

	  engine.end(buffer);
	  flow();

	  function flow() {
	    var chunk;
	    while (null !== (chunk = engine.read())) {
	      buffers.push(chunk);
	      nread += chunk.length;
	    }
	    engine.once('readable', flow);
	  }

	  function onError(err) {
	    engine.removeListener('end', onEnd);
	    engine.removeListener('readable', flow);
	    callback(err);
	  }

	  function onEnd() {
	    var buf = Buffer.concat(buffers, nread);
	    buffers = [];
	    callback(null, buf);
	    engine.close();
	  }
	}

	function zlibBufferSync(engine, buffer) {
	  if (typeof buffer === 'string') buffer = new Buffer(buffer);
	  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');

	  var flushFlag = binding.Z_FINISH;

	  return engine._processChunk(buffer, flushFlag);
	}

	// generic zlib
	// minimal 2-byte header
	function Deflate(opts) {
	  if (!(this instanceof Deflate)) return new Deflate(opts);
	  Zlib.call(this, opts, binding.DEFLATE);
	}

	function Inflate(opts) {
	  if (!(this instanceof Inflate)) return new Inflate(opts);
	  Zlib.call(this, opts, binding.INFLATE);
	}

	// gzip - bigger header, same deflate compression
	function Gzip(opts) {
	  if (!(this instanceof Gzip)) return new Gzip(opts);
	  Zlib.call(this, opts, binding.GZIP);
	}

	function Gunzip(opts) {
	  if (!(this instanceof Gunzip)) return new Gunzip(opts);
	  Zlib.call(this, opts, binding.GUNZIP);
	}

	// raw - no header
	function DeflateRaw(opts) {
	  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
	  Zlib.call(this, opts, binding.DEFLATERAW);
	}

	function InflateRaw(opts) {
	  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
	  Zlib.call(this, opts, binding.INFLATERAW);
	}

	// auto-detect header.
	function Unzip(opts) {
	  if (!(this instanceof Unzip)) return new Unzip(opts);
	  Zlib.call(this, opts, binding.UNZIP);
	}

	// the Zlib class they all inherit from
	// This thing manages the queue of requests, and returns
	// true or false if there is anything in the queue when
	// you call the .write() method.

	function Zlib(opts, mode) {
	  this._opts = opts = opts || {};
	  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

	  Transform.call(this, opts);

	  if (opts.flush) {
	    if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {
	      throw new Error('Invalid flush flag: ' + opts.flush);
	    }
	  }
	  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

	  if (opts.chunkSize) {
	    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
	      throw new Error('Invalid chunk size: ' + opts.chunkSize);
	    }
	  }

	  if (opts.windowBits) {
	    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
	      throw new Error('Invalid windowBits: ' + opts.windowBits);
	    }
	  }

	  if (opts.level) {
	    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
	      throw new Error('Invalid compression level: ' + opts.level);
	    }
	  }

	  if (opts.memLevel) {
	    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
	      throw new Error('Invalid memLevel: ' + opts.memLevel);
	    }
	  }

	  if (opts.strategy) {
	    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
	      throw new Error('Invalid strategy: ' + opts.strategy);
	    }
	  }

	  if (opts.dictionary) {
	    if (!Buffer.isBuffer(opts.dictionary)) {
	      throw new Error('Invalid dictionary: it should be a Buffer instance');
	    }
	  }

	  this._binding = new binding.Zlib(mode);

	  var self = this;
	  this._hadError = false;
	  this._binding.onerror = function (message, errno) {
	    // there is no way to cleanly recover.
	    // continuing only obscures problems.
	    self._binding = null;
	    self._hadError = true;

	    var error = new Error(message);
	    error.errno = errno;
	    error.code = exports.codes[errno];
	    self.emit('error', error);
	  };

	  var level = exports.Z_DEFAULT_COMPRESSION;
	  if (typeof opts.level === 'number') level = opts.level;

	  var strategy = exports.Z_DEFAULT_STRATEGY;
	  if (typeof opts.strategy === 'number') strategy = opts.strategy;

	  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

	  this._buffer = new Buffer(this._chunkSize);
	  this._offset = 0;
	  this._closed = false;
	  this._level = level;
	  this._strategy = strategy;

	  this.once('end', this.close);
	}

	util.inherits(Zlib, Transform);

	Zlib.prototype.params = function (level, strategy, callback) {
	  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
	    throw new RangeError('Invalid compression level: ' + level);
	  }
	  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
	    throw new TypeError('Invalid strategy: ' + strategy);
	  }

	  if (this._level !== level || this._strategy !== strategy) {
	    var self = this;
	    this.flush(binding.Z_SYNC_FLUSH, function () {
	      self._binding.params(level, strategy);
	      if (!self._hadError) {
	        self._level = level;
	        self._strategy = strategy;
	        if (callback) callback();
	      }
	    });
	  } else {
	    process.nextTick(callback);
	  }
	};

	Zlib.prototype.reset = function () {
	  return this._binding.reset();
	};

	// This is the _flush function called by the transform class,
	// internally, when the last chunk has been written.
	Zlib.prototype._flush = function (callback) {
	  this._transform(new Buffer(0), '', callback);
	};

	Zlib.prototype.flush = function (kind, callback) {
	  var ws = this._writableState;

	  if (typeof kind === 'function' || kind === void 0 && !callback) {
	    callback = kind;
	    kind = binding.Z_FULL_FLUSH;
	  }

	  if (ws.ended) {
	    if (callback) process.nextTick(callback);
	  } else if (ws.ending) {
	    if (callback) this.once('end', callback);
	  } else if (ws.needDrain) {
	    var self = this;
	    this.once('drain', function () {
	      self.flush(callback);
	    });
	  } else {
	    this._flushFlag = kind;
	    this.write(new Buffer(0), '', callback);
	  }
	};

	Zlib.prototype.close = function (callback) {
	  if (callback) process.nextTick(callback);

	  if (this._closed) return;

	  this._closed = true;

	  this._binding.close();

	  var self = this;
	  process.nextTick(function () {
	    self.emit('close');
	  });
	};

	Zlib.prototype._transform = function (chunk, encoding, cb) {
	  var flushFlag;
	  var ws = this._writableState;
	  var ending = ws.ending || ws.ended;
	  var last = ending && (!chunk || ws.length === chunk.length);

	  if (!chunk === null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));

	  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
	  // If it's explicitly flushing at some other time, then we use
	  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
	  // goodness.
	  if (last) flushFlag = binding.Z_FINISH;else {
	    flushFlag = this._flushFlag;
	    // once we've flushed the last of the queue, stop flushing and
	    // go back to the normal behavior.
	    if (chunk.length >= ws.length) {
	      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
	    }
	  }

	  var self = this;
	  this._processChunk(chunk, flushFlag, cb);
	};

	Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
	  var availInBefore = chunk && chunk.length;
	  var availOutBefore = this._chunkSize - this._offset;
	  var inOff = 0;

	  var self = this;

	  var async = typeof cb === 'function';

	  if (!async) {
	    var buffers = [];
	    var nread = 0;

	    var error;
	    this.on('error', function (er) {
	      error = er;
	    });

	    do {
	      var res = this._binding.writeSync(flushFlag, chunk, // in
	      inOff, // in_off
	      availInBefore, // in_len
	      this._buffer, // out
	      this._offset, //out_off
	      availOutBefore); // out_len
	    } while (!this._hadError && callback(res[0], res[1]));

	    if (this._hadError) {
	      throw error;
	    }

	    var buf = Buffer.concat(buffers, nread);
	    this.close();

	    return buf;
	  }

	  var req = this._binding.write(flushFlag, chunk, // in
	  inOff, // in_off
	  availInBefore, // in_len
	  this._buffer, // out
	  this._offset, //out_off
	  availOutBefore); // out_len

	  req.buffer = chunk;
	  req.callback = callback;

	  function callback(availInAfter, availOutAfter) {
	    if (self._hadError) return;

	    var have = availOutBefore - availOutAfter;
	    assert(have >= 0, 'have should not go down');

	    if (have > 0) {
	      var out = self._buffer.slice(self._offset, self._offset + have);
	      self._offset += have;
	      // serve some output to the consumer.
	      if (async) {
	        self.push(out);
	      } else {
	        buffers.push(out);
	        nread += out.length;
	      }
	    }

	    // exhausted the output buffer, or used all the input create a new one.
	    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
	      availOutBefore = self._chunkSize;
	      self._offset = 0;
	      self._buffer = new Buffer(self._chunkSize);
	    }

	    if (availOutAfter === 0) {
	      // Not actually done.  Need to reprocess.
	      // Also, update the availInBefore to the availInAfter value,
	      // so that if we have to hit it a third (fourth, etc.) time,
	      // it'll have the correct byte counts.
	      inOff += availInBefore - availInAfter;
	      availInBefore = availInAfter;

	      if (!async) return true;

	      var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
	      newReq.callback = callback; // this same function
	      newReq.buffer = chunk;
	      return;
	    }

	    if (!async) return false;

	    // finished with the chunk.
	    cb();
	  }
	};

	util.inherits(Deflate, Zlib);
	util.inherits(Inflate, Zlib);
	util.inherits(Gzip, Zlib);
	util.inherits(Gunzip, Zlib);
	util.inherits(DeflateRaw, Zlib);
	util.inherits(InflateRaw, Zlib);
	util.inherits(Unzip, Zlib);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer, __webpack_require__(4)))

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';

	var msg = __webpack_require__(331);
	var zstream = __webpack_require__(332);
	var zlib_deflate = __webpack_require__(333);
	var zlib_inflate = __webpack_require__(338);
	var constants = __webpack_require__(341);

	for (var key in constants) {
	  exports[key] = constants[key];
	}

	// zlib modes
	exports.NONE = 0;
	exports.DEFLATE = 1;
	exports.INFLATE = 2;
	exports.GZIP = 3;
	exports.GUNZIP = 4;
	exports.DEFLATERAW = 5;
	exports.INFLATERAW = 6;
	exports.UNZIP = 7;

	/**
	 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
	 */
	function Zlib(mode) {
	  if (mode < exports.DEFLATE || mode > exports.UNZIP) throw new TypeError("Bad argument");

	  this.mode = mode;
	  this.init_done = false;
	  this.write_in_progress = false;
	  this.pending_close = false;
	  this.windowBits = 0;
	  this.level = 0;
	  this.memLevel = 0;
	  this.strategy = 0;
	  this.dictionary = null;
	}

	Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
	  this.windowBits = windowBits;
	  this.level = level;
	  this.memLevel = memLevel;
	  this.strategy = strategy;
	  // dictionary not supported.

	  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) this.windowBits += 16;

	  if (this.mode === exports.UNZIP) this.windowBits += 32;

	  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) this.windowBits = -this.windowBits;

	  this.strm = new zstream();

	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
	      break;
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	    case exports.UNZIP:
	      var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }

	  if (status !== exports.Z_OK) {
	    this._error(status);
	    return;
	  }

	  this.write_in_progress = false;
	  this.init_done = true;
	};

	Zlib.prototype.params = function () {
	  throw new Error("deflateParams Not supported");
	};

	Zlib.prototype._writeCheck = function () {
	  if (!this.init_done) throw new Error("write before init");

	  if (this.mode === exports.NONE) throw new Error("already finalized");

	  if (this.write_in_progress) throw new Error("write already in progress");

	  if (this.pending_close) throw new Error("close is pending");
	};

	Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
	  this._writeCheck();
	  this.write_in_progress = true;

	  var self = this;
	  process.nextTick(function () {
	    self.write_in_progress = false;
	    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
	    self.callback(res[0], res[1]);

	    if (self.pending_close) self.close();
	  });

	  return this;
	};

	// set method for Node buffers, used by pako
	function bufferSet(data, offset) {
	  for (var i = 0; i < data.length; i++) {
	    this[offset + i] = data[i];
	  }
	}

	Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
	  this._writeCheck();
	  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
	};

	Zlib.prototype._write = function (flush, input, in_off, in_len, out, out_off, out_len) {
	  this.write_in_progress = true;

	  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
	    throw new Error("Invalid flush value");
	  }

	  if (input == null) {
	    input = new Buffer(0);
	    in_len = 0;
	    in_off = 0;
	  }

	  if (out._set) out.set = out._set;else out.set = bufferSet;

	  var strm = this.strm;
	  strm.avail_in = in_len;
	  strm.input = input;
	  strm.next_in = in_off;
	  strm.avail_out = out_len;
	  strm.output = out;
	  strm.next_out = out_off;

	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflate(strm, flush);
	      break;
	    case exports.UNZIP:
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflate(strm, flush);
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }

	  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
	    this._error(status);
	  }

	  this.write_in_progress = false;
	  return [strm.avail_in, strm.avail_out];
	};

	Zlib.prototype.close = function () {
	  if (this.write_in_progress) {
	    this.pending_close = true;
	    return;
	  }

	  this.pending_close = false;

	  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
	    zlib_deflate.deflateEnd(this.strm);
	  } else {
	    zlib_inflate.inflateEnd(this.strm);
	  }

	  this.mode = exports.NONE;
	};

	Zlib.prototype.reset = function () {
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateReset(this.strm);
	      break;
	    case exports.INFLATE:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflateReset(this.strm);
	      break;
	  }

	  if (status !== exports.Z_OK) {
	    this._error(status);
	  }
	};

	Zlib.prototype._error = function (status) {
	  this.onerror(msg[status] + ': ' + this.strm.msg, status);

	  this.write_in_progress = false;
	  if (this.pending_close) this.close();
	};

	exports.Zlib = Zlib;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(193).Buffer))

/***/ },
/* 331 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  '2': 'need dictionary', /* Z_NEED_DICT       2  */
	  '1': 'stream end', /* Z_STREAM_END      1  */
	  '0': '', /* Z_OK              0  */
	  '-1': 'file error', /* Z_ERRNO         (-1) */
	  '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
	  '-3': 'data error', /* Z_DATA_ERROR    (-3) */
	  '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
	  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
	};

/***/ },
/* 332 */
/***/ function(module, exports) {

	'use strict';

	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = '' /*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2 /*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	module.exports = ZStream;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(334);
	var trees = __webpack_require__(335);
	var adler32 = __webpack_require__(336);
	var crc32 = __webpack_require__(337);
	var msg = __webpack_require__(331);

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH = 3;
	var Z_FINISH = 4;
	var Z_BLOCK = 5;
	//var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK = 0;
	var Z_STREAM_END = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR = -2;
	var Z_DATA_ERROR = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR = -5;
	//var Z_VERSION_ERROR = -6;


	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;

	var Z_FILTERED = 1;
	var Z_HUFFMAN_ONLY = 2;
	var Z_RLE = 3;
	var Z_FIXED = 4;
	var Z_DEFAULT_STRATEGY = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN = 2;

	/* The deflate compression method */
	var Z_DEFLATED = 8;

	/*============================================================================*/

	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;

	var LENGTH_CODES = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS = 256;
	/* number of literal bytes 0..255 */
	var L_CODES = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES = 30;
	/* number of distance codes */
	var BL_CODES = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

	var PRESET_DICT = 0x20;

	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;

	var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}

	function rank(f) {
	  return (f << 1) - (f > 4 ? 9 : 0);
	}

	function zero(buf) {
	  var len = buf.length;while (--len >= 0) {
	    buf[len] = 0;
	  }
	}

	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) {
	    return;
	  }

	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}

	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}

	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}

	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	  //  put_byte(s, (Byte)(b >> 8));
	  //  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}

	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;

	  if (len > size) {
	    len = size;
	  }
	  if (len === 0) {
	    return 0;
	  }

	  strm.avail_in -= len;

	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  } else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }

	  strm.next_in += len;
	  strm.total_in += len;

	  return len;
	}

	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length; /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match; /* matched string */
	  var len; /* length of current match */
	  var best_len = s.prev_length; /* best match length so far */
	  var nice_match = s.nice_match; /* stop if match long enough */
	  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1 = _win[scan + best_len - 1];
	  var scan_end = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) {
	    nice_match = s.lookahead;
	  }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;

	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1 = _win[scan + best_len - 1];
	      scan_end = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}

	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}


	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = m >= _w_size ? m - _w_size : 0;
	      } while (--n);

	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = m >= _w_size ? m - _w_size : 0;
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);

	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
	      //#if MIN_MATCH != 3
	      //        Call update_hash() MIN_MATCH-3 more times
	      //#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */
	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	  //  if (s.high_water < s.window_size) {
	  //    var curr = s.strstart + s.lookahead;
	  //    var init = 0;
	  //
	  //    if (s.high_water < curr) {
	  //      /* Previous high water mark below current data -- zero WIN_INIT
	  //       * bytes or up to end of window, whichever is less.
	  //       */
	  //      init = s.window_size - curr;
	  //      if (init > WIN_INIT)
	  //        init = WIN_INIT;
	  //      zmemzero(s->window + curr, (unsigned)init);
	  //      s->high_water = curr + init;
	  //    }
	  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
	  //      /* High water mark at or above current data, but below current data
	  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	  //       * to end of window, whichever is less.
	  //       */
	  //      init = (ulg)curr + WIN_INIT - s->high_water;
	  //      if (init > s->window_size - s->high_water)
	  //        init = s->window_size - s->high_water;
	  //      zmemzero(s->window + s->high_water, (unsigned)init);
	  //      s->high_water += init;
	  //    }
	  //  }
	  //
	  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	  //    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;

	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {

	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	      //        s.block_start >= s.w_size)) {
	      //        throw  new Error("slide too late");
	      //      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }

	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	    //    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;

	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;

	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }

	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head; /* head of the hash chain */
	  var bflush; /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0 /*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;

	        //#if MIN_MATCH != 3
	        //                Call UPDATE_HASH() MIN_MATCH-3 more times
	        //#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head; /* head of hash chain */
	  var bflush; /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break;
	      } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0 /*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;

	    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
	        /* To simplify the code, we prevent matches with the string
	         * of window index 0 (in particular we have to avoid a match
	         * of the string with itself at the start of the input file).
	         */
	        s.match_length = longest_match(s, hash_head);
	        /* longest_match() sets match_start */

	        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {

	          /* If prev_match is also MIN_MATCH, match_start is garbage
	           * but we will ignore the current match anyway.
	           */
	          s.match_length = MIN_MATCH - 1;
	        }
	      }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;

	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }
	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush; /* set if current block must be flushed */
	  var prev; /* byte at distance one to match */
	  var scan, strend; /* scan goes up to strend for length of run */

	  var _win = s.window;

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break;
	      } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush; /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break; /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	var Config = function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	};

	var configuration_table;

	configuration_table = [
	/*      good lazy nice chain */
	new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
	new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
	new Config(4, 5, 16, 8, deflate_fast), /* 2 */
	new Config(4, 6, 32, 32, deflate_fast), /* 3 */

	new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
	new Config(8, 16, 32, 32, deflate_slow), /* 5 */
	new Config(8, 16, 128, 128, deflate_slow), /* 6 */
	new Config(8, 32, 128, 256, deflate_slow), /* 7 */
	new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
	new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */
	];

	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;

	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}

	function DeflateState() {
	  this.strm = null; /* pointer back to this zlib stream */
	  this.status = 0; /* as the name implies */
	  this.pending_buf = null; /* output still pending */
	  this.pending_buf_size = 0; /* size of pending_buf */
	  this.pending_out = 0; /* next pending byte to output to the stream */
	  this.pending = 0; /* nb of bytes in the pending buffer */
	  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null; /* gzip header information to write */
	  this.gzindex = 0; /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1; /* value of flush param for previous deflate call */

	  this.w_size = 0; /* LZ77 window size (32K by default) */
	  this.w_bits = 0; /* log2(w_size)  (8..16) */
	  this.w_mask = 0; /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null; /* Heads of the hash chains or NIL. */

	  this.ins_h = 0; /* hash index of string to be inserted */
	  this.hash_size = 0; /* number of elements in hash table */
	  this.hash_bits = 0; /* log2(hash_size) */
	  this.hash_mask = 0; /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0; /* length of best match */
	  this.prev_match = 0; /* previous match */
	  this.match_available = 0; /* set if previous match exists */
	  this.strstart = 0; /* start of string to insert */
	  this.match_start = 0; /* start of matching string */
	  this.lookahead = 0; /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0; /* compression level (1..9) */
	  this.strategy = 0; /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	  /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);

	  this.l_desc = null; /* desc. for literal tree */
	  this.d_desc = null; /* desc. for distance tree */
	  this.bl_desc = null; /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */
	  zero(this.heap);

	  this.heap_len = 0; /* number of elements in the heap */
	  this.heap_max = 0; /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0; /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0; /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0; /* bit length of current block with optimal trees */
	  this.static_len = 0; /* bit length of current block with static trees */
	  this.matches = 0; /* number of string matches in current block */
	  this.insert = 0; /* bytes at end of window left to insert */

	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}

	function deflateResetKeep(strm) {
	  var s;

	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;

	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;

	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
	  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
	  : 1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}

	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}

	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  if (strm.state.wrap !== 2) {
	    return Z_STREAM_ERROR;
	  }
	  strm.state.gzhead = head;
	  return Z_OK;
	}

	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) {
	    // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;

	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }

	  if (windowBits < 0) {
	    /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  } else if (windowBits > 15) {
	    wrap = 2; /* write gzip wrapper instead */
	    windowBits -= 16;
	  }

	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();

	  strm.state = s;
	  s.strm = strm;

	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;

	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);

	  s.d_buf = s.lit_bufsize >> 1;
	  s.l_buf = (1 + 2) * s.lit_bufsize;

	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;

	  return deflateReset(strm);
	}

	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}

	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }

	  s = strm.state;

	  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
	    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }

	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {

	    if (s.wrap === 2) {
	      // GZIP header
	      strm.adler = 0; //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) {
	        // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      } else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, s.gzhead.time >> 8 & 0xff);
	        put_byte(s, s.gzhead.time >> 16 & 0xff);
	        put_byte(s, s.gzhead.time >> 24 & 0xff);
	        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    } else // DEFLATE header
	      {
	        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
	        var level_flags = -1;

	        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	          level_flags = 0;
	        } else if (s.level < 6) {
	          level_flags = 1;
	        } else if (s.level === 6) {
	          level_flags = 2;
	        } else {
	          level_flags = 3;
	        }
	        header |= level_flags << 6;
	        if (s.strstart !== 0) {
	          header |= PRESET_DICT;
	        }
	        header += 31 - header % 31;

	        s.status = BUSY_STATE;
	        putShortMSB(s, header);

	        /* Save the adler32 of the preset dictionary: */
	        if (s.strstart !== 0) {
	          putShortMSB(s, strm.adler >>> 16);
	          putShortMSB(s, strm.adler & 0xffff);
	        }
	        strm.adler = 1; // adler32(0L, Z_NULL, 0);
	      }
	  }

	  //#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra /* != Z_NULL*/) {
	        beg = s.pending; /* start of bytes to update crc */

	        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	          if (s.pending === s.pending_buf_size) {
	            if (s.gzhead.hcrc && s.pending > beg) {
	              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	            }
	            flush_pending(strm);
	            beg = s.pending;
	            if (s.pending === s.pending_buf_size) {
	              break;
	            }
	          }
	          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	          s.gzindex++;
	        }
	        if (s.gzhead.hcrc && s.pending > beg) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	        }
	        if (s.gzindex === s.gzhead.extra.length) {
	          s.gzindex = 0;
	          s.status = NAME_STATE;
	        }
	      } else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name /* != Z_NULL*/) {
	        beg = s.pending; /* start of bytes to update crc */
	        //int val;

	        do {
	          if (s.pending === s.pending_buf_size) {
	            if (s.gzhead.hcrc && s.pending > beg) {
	              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	            }
	            flush_pending(strm);
	            beg = s.pending;
	            if (s.pending === s.pending_buf_size) {
	              val = 1;
	              break;
	            }
	          }
	          // JS specific: little magic to add zero terminator to end of string
	          if (s.gzindex < s.gzhead.name.length) {
	            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	          } else {
	            val = 0;
	          }
	          put_byte(s, val);
	        } while (val !== 0);

	        if (s.gzhead.hcrc && s.pending > beg) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	        }
	        if (val === 0) {
	          s.gzindex = 0;
	          s.status = COMMENT_STATE;
	        }
	      } else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment /* != Z_NULL*/) {
	        beg = s.pending; /* start of bytes to update crc */
	        //int val;

	        do {
	          if (s.pending === s.pending_buf_size) {
	            if (s.gzhead.hcrc && s.pending > beg) {
	              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	            }
	            flush_pending(strm);
	            beg = s.pending;
	            if (s.pending === s.pending_buf_size) {
	              val = 1;
	              break;
	            }
	          }
	          // JS specific: little magic to add zero terminator to end of string
	          if (s.gzindex < s.gzhead.comment.length) {
	            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	          } else {
	            val = 0;
	          }
	          put_byte(s, val);
	        } while (val !== 0);

	        if (s.gzhead.hcrc && s.pending > beg) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	        }
	        if (val === 0) {
	          s.status = HCRC_STATE;
	        }
	      } else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, strm.adler >> 8 & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    } else {
	      s.status = BUSY_STATE;
	    }
	  }
	  //#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
	    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      } else if (flush !== Z_BLOCK) {
	        /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/ /* forget history */
	          zero(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH) {
	    return Z_OK;
	  }
	  if (s.wrap <= 0) {
	    return Z_STREAM_END;
	  }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, strm.adler >> 8 & 0xff);
	    put_byte(s, strm.adler >> 16 & 0xff);
	    put_byte(s, strm.adler >> 24 & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, strm.total_in >> 8 & 0xff);
	    put_byte(s, strm.total_in >> 16 & 0xff);
	    put_byte(s, strm.total_in >> 24 & 0xff);
	  } else {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }

	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) {
	    s.wrap = -s.wrap;
	  }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}

	function deflateEnd(strm) {
	  var status;

	  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {
	      return Z_STREAM_ERROR;
	    }

	  status = strm.state.status;
	  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.state = null;

	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}

	/* =========================================================================
	 * Copy the source state to the destination state
	 */
	//function deflateCopy(dest, source) {
	//
	//}

	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateInfo = 'pako deflate (from Nodeca project)';

	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/

/***/ },
/* 334 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) {
	      continue;
	    }

	    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }

	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }

	  return obj;
	};

	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) {
	    return buf;
	  }
	  if (buf.subarray) {
	    return buf.subarray(0, size);
	  }
	  buf.length = size;
	  return buf;
	};

	var fnTyped = {
	  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function flattenChunks(chunks) {
	    var i, l, len, pos, chunk, result;

	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }

	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }

	    return result;
	  }
	};

	var fnUntyped = {
	  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function flattenChunks(chunks) {
	    return [].concat.apply([], chunks);
	  }
	};

	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8 = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8 = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};

	exports.setTyped(TYPED_OK);

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(334);

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY = 0;
	var Z_TEXT = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN = 2;

	/*============================================================================*/

	function zero(buf) {
	  var len = buf.length;while (--len >= 0) {
	    buf[len] = 0;
	  }
	}

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES = 2;
	/* The three kinds of block type */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS = 256;
	/* number of literal bytes 0..255 */

	var L_CODES = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES = 30;
	/* number of distance codes */

	var BL_CODES = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE = 2 * L_CODES + 1;
	/* maximum heap size */

	var MAX_BITS = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size = 16;
	/* size of bit buffer in bi_buf */

	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK = 256;
	/* end of block literal code */

	var REP_3_6 = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10 = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	var extra_lbits = /* extra bits for each length code */
	[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

	var extra_dbits = /* extra bits for each distance code */
	[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

	var extra_blbits = /* extra bits for each bit length code */
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

	var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
	var static_ltree = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */

	var StaticTreeDesc = function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

	  this.static_tree = static_tree; /* static tree or NULL */
	  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
	  this.extra_base = extra_base; /* base index for extra_bits */
	  this.elems = elems; /* max number of elements in the tree */
	  this.max_length = max_length; /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree = static_tree && static_tree.length;
	};

	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;

	var TreeDesc = function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree; /* the dynamic tree */
	  this.max_code = 0; /* largest code with non zero frequency */
	  this.stat_desc = stat_desc; /* the corresponding static tree */
	};

	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}

	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	  //    put_byte(s, (uch)((w) & 0xff));
	  //    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = w & 0xff;
	  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
	}

	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > Buf_size - length) {
	    s.bi_buf |= value << s.bi_valid & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> Buf_size - s.bi_valid;
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= value << s.bi_valid & 0xffff;
	    s.bi_valid += length;
	  }
	}

	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
	}

	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}

	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;
	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}

	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree = desc.dyn_tree;
	  var max_code = desc.max_code;
	  var stree = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var extra = desc.stat_desc.extra_bits;
	  var base = desc.stat_desc.extra_base;
	  var max_length = desc.stat_desc.max_length;
	  var h; /* heap index */
	  var n, m; /* iterate over the tree elements */
	  var bits; /* bit length */
	  var xbits; /* extra bits */
	  var f; /* frequency */
	  var overflow = 0; /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1] /*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) {
	      continue;
	    } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2] /*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) {
	    return;
	  }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) {
	      bits--;
	    }
	    s.bl_count[bits]--; /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) {
	        continue;
	      }
	      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
	        tree[m * 2 + 1] /*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}

	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0; /* running code value */
	  var bits; /* bit index */
	  var n; /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = code + bl_count[bits - 1] << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0; n <= max_code; n++) {
	    var len = tree[n * 2 + 1] /*.Len*/;
	    if (len === 0) {
	      continue;
	    }
	    /* Now reverse the bits */
	    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}

	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n; /* iterates over tree elements */
	  var bits; /* bit counter */
	  var length; /* length value */
	  var code; /* code value */
	  var dist; /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	  /*#ifdef NO_INIT_GLOBAL_POINTERS
	    static_l_desc.static_tree = static_ltree;
	    static_l_desc.extra_bits = extra_lbits;
	    static_d_desc.static_tree = static_dtree;
	    static_d_desc.extra_bits = extra_dbits;
	    static_bl_desc.extra_bits = extra_blbits;
	  #endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < 1 << extra_lbits[code]; n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < 1 << extra_dbits[code]; n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }

	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1] /*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1] /*.Len*/ = 5;
	    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

	  //static_init_done = true;
	}

	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES; n++) {
	    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
	  }
	  for (n = 0; n < D_CODES; n++) {
	    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
	  }
	  for (n = 0; n < BL_CODES; n++) {
	    s.bl_tree[n * 2] /*.Freq*/ = 0;
	  }

	  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}

	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s) {
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s); /* align on byte boundary */

	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	  //  while (len--) {
	  //    put_byte(s, *buf++);
	  //  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1; /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) {
	      break;
	    }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}

	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist; /* distance of matched string */
	  var lc; /* match length or unmatched char (if dist == 0) */
	  var lx = 0; /* running index in l_buf */
	  var code; /* the code to send */
	  var extra; /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;

	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra); /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree); /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra); /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");
	    } while (lx < s.last_lit);
	  }

	  send_code(s, END_BLOCK, ltree);
	}

	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree = desc.dyn_tree;
	  var stree = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems = desc.stat_desc.elems;
	  var n, m; /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node; /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;

	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2] /*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;
	    } else {
	      tree[n * 2 + 1] /*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
	    tree[node * 2] /*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;

	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1] /*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
	    pqdownheap(s, tree, n);
	  }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems; /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1 /*SMALLEST*/];
	    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1 /*SMALLEST*/);
	    /***/

	    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1 /*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1 /*SMALLEST*/);
	  } while (s.heap_len >= 2);

	  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}

	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n; /* iterates over all tree elements */
	  var prevlen = -1; /* last emitted length */
	  var curlen; /* length of current code */

	  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

	  var count = 0; /* repeat count of the current code */
	  var max_count = 7; /* max repeat count */
	  var min_count = 4; /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;
	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2] /*.Freq*/ += count;
	    } else if (curlen !== 0) {

	      if (curlen !== prevlen) {
	        s.bl_tree[curlen * 2] /*.Freq*/++;
	      }
	      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
	    } else {
	      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;

	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}

	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n; /* iterates over all tree elements */
	  var prevlen = -1; /* last emitted length */
	  var curlen; /* length of current code */

	  var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

	  var count = 0; /* repeat count of the current code */
	  var max_count = 7; /* max repeat count */
	  var min_count = 4; /* min repeat count */

	  /* tree[max_code+1].Len = -1; */ /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;
	    } else if (count < min_count) {
	      do {
	        send_code(s, curlen, s.bl_tree);
	      } while (--count !== 0);
	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);
	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);
	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}

	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex; /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}

	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank; /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1, 5);
	  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}

	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}

	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s) {

	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }

	  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}

	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}

	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}

	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb; /* opt_len and static_len in bytes */
	  var max_blindex = 0; /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {

	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = s.opt_len + 3 + 7 >>> 3;
	    static_lenb = s.static_len + 3 + 7 >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) {
	      opt_lenb = static_lenb;
	    }
	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if (stored_len + 4 <= opt_lenb && buf !== -1) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);
	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);
	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);

	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;

	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2] /*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--; /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
	  }

	  // (!) This block is disabled in zlib defailts,
	  // don't enable it for binary compatibility

	  //#ifdef TRUNCATE_BLOCK
	  //  /* Try to guess if it is profitable to stop the current block here */
	  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	  //    /* Compute an upper bound for the compressed length */
	  //    out_length = s.last_lit*8;
	  //    in_length = s.strstart - s.block_start;
	  //
	  //    for (dcode = 0; dcode < D_CODES; dcode++) {
	  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	  //    }
	  //    out_length >>>= 3;
	  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	  //    //       s->last_lit, in_length, out_length,
	  //    //       100L - out_length*100L/in_length));
	  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	  //      return true;
	  //    }
	  //  }
	  //#endif

	  return s.last_lit === s.lit_bufsize - 1;
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	exports._tr_init = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;

/***/ },
/* 336 */
/***/ function(module, exports) {

	'use strict';

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.

	function adler32(adler, buf, len, pos) {
	  var s1 = adler & 0xffff | 0,
	      s2 = adler >>> 16 & 0xffff | 0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = s1 + buf[pos++] | 0;
	      s2 = s2 + s1 | 0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return s1 | s2 << 16 | 0;
	}

	module.exports = adler32;

/***/ },
/* 337 */
/***/ function(module, exports) {

	'use strict';

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.


	// Use ordinary array, since untyped makes no boost here

	function makeTable() {
	  var c,
	      table = [];

	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();

	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc = crc ^ -1;

	  for (var i = pos; i < end; i++) {
	    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return crc ^ -1; // >>> 0;
	}

	module.exports = crc32;

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(334);
	var adler32 = __webpack_require__(336);
	var crc32 = __webpack_require__(337);
	var inflate_fast = __webpack_require__(339);
	var inflate_table = __webpack_require__(340);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH = 4;
	var Z_BLOCK = 5;
	var Z_TREES = 6;

	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK = 0;
	var Z_STREAM_END = 1;
	var Z_NEED_DICT = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR = -2;
	var Z_DATA_ERROR = -3;
	var Z_MEM_ERROR = -4;
	var Z_BUF_ERROR = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED = 8;

	/* STATES ====================================================================*/
	/* ===========================================================================*/

	var HEAD = 1; /* i: waiting for magic header */
	var FLAGS = 2; /* i: waiting for method and flags (gzip) */
	var TIME = 3; /* i: waiting for modification time (gzip) */
	var OS = 4; /* i: waiting for extra flags and operating system (gzip) */
	var EXLEN = 5; /* i: waiting for extra length (gzip) */
	var EXTRA = 6; /* i: waiting for extra bytes (gzip) */
	var NAME = 7; /* i: waiting for end of file name (gzip) */
	var COMMENT = 8; /* i: waiting for end of comment (gzip) */
	var HCRC = 9; /* i: waiting for header crc (gzip) */
	var DICTID = 10; /* i: waiting for dictionary check value */
	var DICT = 11; /* waiting for inflateSetDictionary() call */
	var TYPE = 12; /* i: waiting for type bits, including last-flag bit */
	var TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */
	var STORED = 14; /* i: waiting for stored size (length and complement) */
	var COPY_ = 15; /* i/o: same as COPY below, but only first time in */
	var COPY = 16; /* i/o: waiting for input or output to copy stored block */
	var TABLE = 17; /* i: waiting for dynamic block table lengths */
	var LENLENS = 18; /* i: waiting for code length code lengths */
	var CODELENS = 19; /* i: waiting for length/lit and distance code lengths */
	var LEN_ = 20; /* i: same as LEN below, but only first time in */
	var LEN = 21; /* i: waiting for length/lit/eob code */
	var LENEXT = 22; /* i: waiting for length extra bits */
	var DIST = 23; /* i: waiting for distance code */
	var DISTEXT = 24; /* i: waiting for distance extra bits */
	var MATCH = 25; /* o: waiting for output space to copy string */
	var LIT = 26; /* o: waiting for output space to write literal */
	var CHECK = 27; /* i: waiting for 32-bit check value */
	var LENGTH = 28; /* i: waiting for 32-bit length (gzip) */
	var DONE = 29; /* finished check, done -- remain here until reset */
	var BAD = 30; /* got a data error -- remain here until reset */
	var MEM = 31; /* got an inflate() memory error -- remain here until reset */
	var SYNC = 32; /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/

	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;

	function ZSWAP32(q) {
	  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
	}

	function InflateState() {
	  this.mode = 0; /* current inflate mode */
	  this.last = false; /* true if processing last block */
	  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false; /* true if dictionary provided */
	  this.flags = 0; /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0; /* protected copy of check value */
	  this.total = 0; /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null; /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0; /* log base 2 of requested window size */
	  this.wsize = 0; /* window size or zero if not using window */
	  this.whave = 0; /* valid bytes in the window */
	  this.wnext = 0; /* window write index */
	  this.window = null; /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0; /* input bit accumulator */
	  this.bits = 0; /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0; /* literal or length of data to copy */
	  this.offset = 0; /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0; /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null; /* starting table for length/literal codes */
	  this.distcode = null; /* starting table for distance codes */
	  this.lenbits = 0; /* index bits for lencode */
	  this.distbits = 0; /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0; /* number of code length code lengths */
	  this.nlen = 0; /* number of length code lengths */
	  this.ndist = 0; /* number of distance code lengths */
	  this.have = 0; /* number of code lengths in lens[] */
	  this.next = null; /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
	  this.sane = 0; /* if false, allow invalid distance too far */
	  this.back = 0; /* bits back of last unprocessed length/lit */
	  this.was = 0; /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {
	    /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null /*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);
	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  } else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) {
	    return Z_STREAM_ERROR;
	  }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null /*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null /*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}

	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) {
	      state.lens[sym++] = 8;
	    }
	    while (sym < 256) {
	      state.lens[sym++] = 9;
	    }
	    while (sym < 280) {
	      state.lens[sym++] = 7;
	    }
	    while (sym < 288) {
	      state.lens[sym++] = 8;
	    }

	    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) {
	      state.lens[sym++] = 5;
	    }

	    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}

	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  } else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    } else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) {
	        state.wnext = 0;
	      }
	      if (state.whave < state.wsize) {
	        state.whave += dist;
	      }
	    }
	  }
	  return 0;
	}

	function inflate(strm, flush) {
	  var state;
	  var input, output; // input/output buffers
	  var next; /* next input INDEX */
	  var put; /* next output INDEX */
	  var have, left; /* available input and output */
	  var hold; /* bit buffer */
	  var bits; /* bits in bit buffer */
	  var _in, _out; /* save starting available input and output */
	  var copy; /* number of stored or match bytes to copy */
	  var from; /* where to copy match bytes from */
	  var from_source;
	  var here = 0; /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len; /* length to copy for repeats, bits to drop */
	  var ret; /* return code */
	  var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

	  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) {
	    state.mode = TYPEDO;
	  } /* skip check */

	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	      case HEAD:
	        if (state.wrap === 0) {
	          state.mode = TYPEDO;
	          break;
	        }
	        //=== NEEDBITS(16);
	        while (bits < 16) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.wrap & 2 && hold === 0x8b1f) {
	          /* gzip header */
	          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//

	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          state.mode = FLAGS;
	          break;
	        }
	        state.flags = 0; /* expect zlib header */
	        if (state.head) {
	          state.head.done = false;
	        }
	        if (!(state.wrap & 1) || /* check if zlib header allowed */
	        (((hold & 0xff) << /*BITS(8)*/8) + (hold >> 8)) % 31) {
	          strm.msg = 'incorrect header check';
	          state.mode = BAD;
	          break;
	        }
	        if ((hold & 0x0f) !== /*BITS(4)*/Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        len = (hold & 0x0f) + /*BITS(4)*/8;
	        if (state.wbits === 0) {
	          state.wbits = len;
	        } else if (len > state.wbits) {
	          strm.msg = 'invalid window size';
	          state.mode = BAD;
	          break;
	        }
	        state.dmax = 1 << len;
	        //Tracev((stderr, "inflate:   zlib header ok\n"));
	        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
	        state.mode = hold & 0x200 ? DICTID : TYPE;
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        break;
	      case FLAGS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.flags = hold;
	        if ((state.flags & 0xff) !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        if (state.flags & 0xe000) {
	          strm.msg = 'unknown header flags set';
	          state.mode = BAD;
	          break;
	        }
	        if (state.head) {
	          state.head.text = hold >> 8 & 1;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = TIME;
	      /* falls through */
	      case TIME:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.time = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC4(state.check, hold)
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          hbuf[2] = hold >>> 16 & 0xff;
	          hbuf[3] = hold >>> 24 & 0xff;
	          state.check = crc32(state.check, hbuf, 4, 0);
	          //===
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = OS;
	      /* falls through */
	      case OS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.xflags = hold & 0xff;
	          state.head.os = hold >> 8;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = hold >>> 8 & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = EXLEN;
	      /* falls through */
	      case EXLEN:
	        if (state.flags & 0x0400) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length = hold;
	          if (state.head) {
	            state.head.extra_len = hold;
	          }
	          if (state.flags & 0x0200) {
	            //=== CRC2(state.check, hold);
	            hbuf[0] = hold & 0xff;
	            hbuf[1] = hold >>> 8 & 0xff;
	            state.check = crc32(state.check, hbuf, 2, 0);
	            //===//
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        } else if (state.head) {
	          state.head.extra = null /*Z_NULL*/;
	        }
	        state.mode = EXTRA;
	      /* falls through */
	      case EXTRA:
	        if (state.flags & 0x0400) {
	          copy = state.length;
	          if (copy > have) {
	            copy = have;
	          }
	          if (copy) {
	            if (state.head) {
	              len = state.head.extra_len - state.length;
	              if (!state.head.extra) {
	                // Use untyped array for more conveniend processing later
	                state.head.extra = new Array(state.head.extra_len);
	              }
	              utils.arraySet(state.head.extra, input, next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len);
	              //zmemcpy(state.head.extra + len, next,
	              //        len + copy > state.head.extra_max ?
	              //        state.head.extra_max - len : copy);
	            }
	            if (state.flags & 0x0200) {
	              state.check = crc32(state.check, input, copy, next);
	            }
	            have -= copy;
	            next += copy;
	            state.length -= copy;
	          }
	          if (state.length) {
	            break inf_leave;
	          }
	        }
	        state.length = 0;
	        state.mode = NAME;
	      /* falls through */
	      case NAME:
	        if (state.flags & 0x0800) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          copy = 0;
	          do {
	            // TODO: 2 or 1 bytes?
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
	              state.head.name += String.fromCharCode(len);
	            }
	          } while (len && copy < have);

	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) {
	            break inf_leave;
	          }
	        } else if (state.head) {
	          state.head.name = null;
	        }
	        state.length = 0;
	        state.mode = COMMENT;
	      /* falls through */
	      case COMMENT:
	        if (state.flags & 0x1000) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          copy = 0;
	          do {
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
	              state.head.comment += String.fromCharCode(len);
	            }
	          } while (len && copy < have);
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) {
	            break inf_leave;
	          }
	        } else if (state.head) {
	          state.head.comment = null;
	        }
	        state.mode = HCRC;
	      /* falls through */
	      case HCRC:
	        if (state.flags & 0x0200) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.check & 0xffff)) {
	            strm.msg = 'header crc mismatch';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        if (state.head) {
	          state.head.hcrc = state.flags >> 9 & 1;
	          state.head.done = true;
	        }
	        strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
	        state.mode = TYPE;
	        break;
	      case DICTID:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        strm.adler = state.check = ZSWAP32(hold);
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = DICT;
	      /* falls through */
	      case DICT:
	        if (state.havedict === 0) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          return Z_NEED_DICT;
	        }
	        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
	        state.mode = TYPE;
	      /* falls through */
	      case TYPE:
	        if (flush === Z_BLOCK || flush === Z_TREES) {
	          break inf_leave;
	        }
	      /* falls through */
	      case TYPEDO:
	        if (state.last) {
	          //--- BYTEBITS() ---//
	          hold >>>= bits & 7;
	          bits -= bits & 7;
	          //---//
	          state.mode = CHECK;
	          break;
	        }
	        //=== NEEDBITS(3); */
	        while (bits < 3) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.last = hold & 0x01 /*BITS(1)*/;
	        //--- DROPBITS(1) ---//
	        hold >>>= 1;
	        bits -= 1;
	        //---//

	        switch (hold & 0x03) {/*BITS(2)*/case 0:
	            /* stored block */
	            //Tracev((stderr, "inflate:     stored block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = STORED;
	            break;
	          case 1:
	            /* fixed block */
	            fixedtables(state);
	            //Tracev((stderr, "inflate:     fixed codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = LEN_; /* decode codes */
	            if (flush === Z_TREES) {
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	              break inf_leave;
	            }
	            break;
	          case 2:
	            /* dynamic block */
	            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = TABLE;
	            break;
	          case 3:
	            strm.msg = 'invalid block type';
	            state.mode = BAD;
	        }
	        //--- DROPBITS(2) ---//
	        hold >>>= 2;
	        bits -= 2;
	        //---//
	        break;
	      case STORED:
	        //--- BYTEBITS() ---// /* go to byte boundary */
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
	          strm.msg = 'invalid stored block lengths';
	          state.mode = BAD;
	          break;
	        }
	        state.length = hold & 0xffff;
	        //Tracev((stderr, "inflate:       stored length %u\n",
	        //        state.length));
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = COPY_;
	        if (flush === Z_TREES) {
	          break inf_leave;
	        }
	      /* falls through */
	      case COPY_:
	        state.mode = COPY;
	      /* falls through */
	      case COPY:
	        copy = state.length;
	        if (copy) {
	          if (copy > have) {
	            copy = have;
	          }
	          if (copy > left) {
	            copy = left;
	          }
	          if (copy === 0) {
	            break inf_leave;
	          }
	          //--- zmemcpy(put, next, copy); ---
	          utils.arraySet(output, input, next, copy, put);
	          //---//
	          have -= copy;
	          next += copy;
	          left -= copy;
	          put += copy;
	          state.length -= copy;
	          break;
	        }
	        //Tracev((stderr, "inflate:       stored end\n"));
	        state.mode = TYPE;
	        break;
	      case TABLE:
	        //=== NEEDBITS(14); */
	        while (bits < 14) {
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.nlen = (hold & 0x1f) + /*BITS(5)*/257;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ndist = (hold & 0x1f) + /*BITS(5)*/1;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ncode = (hold & 0x0f) + /*BITS(4)*/4;
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        //#ifndef PKZIP_BUG_WORKAROUND
	        if (state.nlen > 286 || state.ndist > 30) {
	          strm.msg = 'too many length or distance symbols';
	          state.mode = BAD;
	          break;
	        }
	        //#endif
	        //Tracev((stderr, "inflate:       table sizes ok\n"));
	        state.have = 0;
	        state.mode = LENLENS;
	      /* falls through */
	      case LENLENS:
	        while (state.have < state.ncode) {
	          //=== NEEDBITS(3);
	          while (bits < 3) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
	          //--- DROPBITS(3) ---//
	          hold >>>= 3;
	          bits -= 3;
	          //---//
	        }
	        while (state.have < 19) {
	          state.lens[order[state.have++]] = 0;
	        }
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        //state.next = state.codes;
	        //state.lencode = state.next;
	        // Switch to use dynamic table
	        state.lencode = state.lendyn;
	        state.lenbits = 7;

	        opts = { bits: state.lenbits };
	        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	        state.lenbits = opts.bits;

	        if (ret) {
	          strm.msg = 'invalid code lengths set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, "inflate:       code lengths ok\n"));
	        state.have = 0;
	        state.mode = CODELENS;
	      /* falls through */
	      case CODELENS:
	        while (state.have < state.nlen + state.ndist) {
	          for (;;) {
	            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
	            here_bits = here >>> 24;
	            here_op = here >>> 16 & 0xff;
	            here_val = here & 0xffff;

	            if (here_bits <= bits) {
	              break;
	            }
	            //--- PULLBYTE() ---//
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          if (here_val < 16) {
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            state.lens[state.have++] = here_val;
	          } else {
	            if (here_val === 16) {
	              //=== NEEDBITS(here.bits + 2);
	              n = here_bits + 2;
	              while (bits < n) {
	                if (have === 0) {
	                  break inf_leave;
	                }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              if (state.have === 0) {
	                strm.msg = 'invalid bit length repeat';
	                state.mode = BAD;
	                break;
	              }
	              len = state.lens[state.have - 1];
	              copy = 3 + (hold & 0x03); //BITS(2);
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	            } else if (here_val === 17) {
	              //=== NEEDBITS(here.bits + 3);
	              n = here_bits + 3;
	              while (bits < n) {
	                if (have === 0) {
	                  break inf_leave;
	                }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 3 + (hold & 0x07); //BITS(3);
	              //--- DROPBITS(3) ---//
	              hold >>>= 3;
	              bits -= 3;
	              //---//
	            } else {
	              //=== NEEDBITS(here.bits + 7);
	              n = here_bits + 7;
	              while (bits < n) {
	                if (have === 0) {
	                  break inf_leave;
	                }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 11 + (hold & 0x7f); //BITS(7);
	              //--- DROPBITS(7) ---//
	              hold >>>= 7;
	              bits -= 7;
	              //---//
	            }
	            if (state.have + copy > state.nlen + state.ndist) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            while (copy--) {
	              state.lens[state.have++] = len;
	            }
	          }
	        }

	        /* handle error breaks in while */
	        if (state.mode === BAD) {
	          break;
	        }

	        /* check for end-of-block code (better have one) */
	        if (state.lens[256] === 0) {
	          strm.msg = 'invalid code -- missing end-of-block';
	          state.mode = BAD;
	          break;
	        }

	        /* build code tables -- note: do not change the lenbits or distbits
	           values here (9 and 6) without reading the comments in inftrees.h
	           concerning the ENOUGH constants, which depend on those values */
	        state.lenbits = 9;

	        opts = { bits: state.lenbits };
	        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.lenbits = opts.bits;
	        // state.lencode = state.next;

	        if (ret) {
	          strm.msg = 'invalid literal/lengths set';
	          state.mode = BAD;
	          break;
	        }

	        state.distbits = 6;
	        //state.distcode.copy(state.codes);
	        // Switch to use dynamic table
	        state.distcode = state.distdyn;
	        opts = { bits: state.distbits };
	        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.distbits = opts.bits;
	        // state.distcode = state.next;

	        if (ret) {
	          strm.msg = 'invalid distances set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, 'inflate:       codes ok\n'));
	        state.mode = LEN_;
	        if (flush === Z_TREES) {
	          break inf_leave;
	        }
	      /* falls through */
	      case LEN_:
	        state.mode = LEN;
	      /* falls through */
	      case LEN:
	        if (have >= 6 && left >= 258) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          inflate_fast(strm, _out);
	          //--- LOAD() ---
	          put = strm.next_out;
	          output = strm.output;
	          left = strm.avail_out;
	          next = strm.next_in;
	          input = strm.input;
	          have = strm.avail_in;
	          hold = state.hold;
	          bits = state.bits;
	          //---

	          if (state.mode === TYPE) {
	            state.back = -1;
	          }
	          break;
	        }
	        state.back = 0;
	        for (;;) {
	          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = here >>> 16 & 0xff;
	          here_val = here & 0xffff;

	          if (here_bits <= bits) {
	            break;
	          }
	          //--- PULLBYTE() ---//
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_op && (here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
	            here_bits = here >>> 24;
	            here_op = here >>> 16 & 0xff;
	            here_val = here & 0xffff;

	            if (last_bits + here_bits <= bits) {
	              break;
	            }
	            //--- PULLBYTE() ---//
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        state.length = here_val;
	        if (here_op === 0) {
	          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	          //        "inflate:         literal '%c'\n" :
	          //        "inflate:         literal 0x%02x\n", here.val));
	          state.mode = LIT;
	          break;
	        }
	        if (here_op & 32) {
	          //Tracevv((stderr, "inflate:         end of block\n"));
	          state.back = -1;
	          state.mode = TYPE;
	          break;
	        }
	        if (here_op & 64) {
	          strm.msg = 'invalid literal/length code';
	          state.mode = BAD;
	          break;
	        }
	        state.extra = here_op & 15;
	        state.mode = LENEXT;
	      /* falls through */
	      case LENEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", state.length));
	        state.was = state.length;
	        state.mode = DIST;
	      /* falls through */
	      case DIST:
	        for (;;) {
	          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
	          here_bits = here >>> 24;
	          here_op = here >>> 16 & 0xff;
	          here_val = here & 0xffff;

	          if (here_bits <= bits) {
	            break;
	          }
	          //--- PULLBYTE() ---//
	          if (have === 0) {
	            break inf_leave;
	          }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if ((here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/last_bits)];
	            here_bits = here >>> 24;
	            here_op = here >>> 16 & 0xff;
	            here_val = here & 0xffff;

	            if (last_bits + here_bits <= bits) {
	              break;
	            }
	            //--- PULLBYTE() ---//
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        if (here_op & 64) {
	          strm.msg = 'invalid distance code';
	          state.mode = BAD;
	          break;
	        }
	        state.offset = here_val;
	        state.extra = here_op & 15;
	        state.mode = DISTEXT;
	      /* falls through */
	      case DISTEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //#ifdef INFLATE_STRICT
	        if (state.offset > state.dmax) {
	          strm.msg = 'invalid distance too far back';
	          state.mode = BAD;
	          break;
	        }
	        //#endif
	        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	        state.mode = MATCH;
	      /* falls through */
	      case MATCH:
	        if (left === 0) {
	          break inf_leave;
	        }
	        copy = _out - left;
	        if (state.offset > copy) {
	          /* copy from window */
	          copy = state.offset - copy;
	          if (copy > state.whave) {
	            if (state.sane) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break;
	            }
	            // (!) This block is disabled in zlib defailts,
	            // don't enable it for binary compatibility
	            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	            //          Trace((stderr, "inflate.c too far\n"));
	            //          copy -= state.whave;
	            //          if (copy > state.length) { copy = state.length; }
	            //          if (copy > left) { copy = left; }
	            //          left -= copy;
	            //          state.length -= copy;
	            //          do {
	            //            output[put++] = 0;
	            //          } while (--copy);
	            //          if (state.length === 0) { state.mode = LEN; }
	            //          break;
	            //#endif
	          }
	          if (copy > state.wnext) {
	            copy -= state.wnext;
	            from = state.wsize - copy;
	          } else {
	            from = state.wnext - copy;
	          }
	          if (copy > state.length) {
	            copy = state.length;
	          }
	          from_source = state.window;
	        } else {
	          /* copy from output */
	          from_source = output;
	          from = put - state.offset;
	          copy = state.length;
	        }
	        if (copy > left) {
	          copy = left;
	        }
	        left -= copy;
	        state.length -= copy;
	        do {
	          output[put++] = from_source[from++];
	        } while (--copy);
	        if (state.length === 0) {
	          state.mode = LEN;
	        }
	        break;
	      case LIT:
	        if (left === 0) {
	          break inf_leave;
	        }
	        output[put++] = state.length;
	        left--;
	        state.mode = LEN;
	        break;
	      case CHECK:
	        if (state.wrap) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            // Use '|' insdead of '+' to make sure that result is signed
	            hold |= input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          _out -= left;
	          strm.total_out += _out;
	          state.total += _out;
	          if (_out) {
	            strm.adler = state.check =
	            /*UPDATE(state.check, put - _out, _out);*/
	            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
	          }
	          _out = left;
	          // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
	          if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
	            strm.msg = 'incorrect data check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   check matches trailer\n"));
	        }
	        state.mode = LENGTH;
	      /* falls through */
	      case LENGTH:
	        if (state.wrap && state.flags) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) {
	              break inf_leave;
	            }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.total & 0xffffffff)) {
	            strm.msg = 'incorrect length check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   length matches trailer\n"));
	        }
	        state.mode = DONE;
	      /* falls through */
	      case DONE:
	        ret = Z_STREAM_END;
	        break inf_leave;
	      case BAD:
	        ret = Z_DATA_ERROR;
	        break inf_leave;
	      case MEM:
	        return Z_MEM_ERROR;
	      case SYNC:
	      /* falls through */
	      default:
	        return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	      return Z_STREAM_ERROR;
	    }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) {
	    return Z_STREAM_ERROR;
	  }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) {
	    return Z_STREAM_ERROR;
	  }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}

	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/

/***/ },
/* 339 */
/***/ function(module, exports) {

	'use strict';

	// See state defs from inflate.js

	var BAD = 30; /* got a data error -- remain here until reset */
	var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in; /* local strm.input */
	  var last; /* have enough input while in < last */
	  var _out; /* local strm.output */
	  var beg; /* inflate()'s initial strm.output */
	  var end; /* while out < end, enough space available */
	  //#ifdef INFLATE_STRICT
	  var dmax; /* maximum distance from zlib header */
	  //#endif
	  var wsize; /* window size or zero if not using window */
	  var whave; /* valid bytes in the window */
	  var wnext; /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window; /* allocated sliding window, if wsize != 0 */
	  var hold; /* local strm.hold */
	  var bits; /* local strm.bits */
	  var lcode; /* local strm.lencode */
	  var dcode; /* local strm.distcode */
	  var lmask; /* mask for first level of length codes */
	  var dmask; /* mask for first level of distance codes */
	  var here; /* retrieved table entry */
	  var op; /* code bits, operation, extra bits, or */
	  /*  window position, window bytes to copy */
	  var len; /* match length, unused bytes */
	  var dist; /* match distance */
	  var from; /* where to copy match from */
	  var from_source;

	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	  //#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	  //#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;

	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top: do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen: for (;;) {
	      // Goto emulation
	      op = here >>> 24 /*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = here >>> 16 & 0xff /*here.op*/;
	      if (op === 0) {
	        /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff /*here.val*/;
	      } else if (op & 16) {
	        /* length base */
	        len = here & 0xffff /*here.val*/;
	        op &= 15; /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & (1 << op) - 1;
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist: for (;;) {
	          // goto emulation
	          op = here >>> 24 /*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = here >>> 16 & 0xff /*here.op*/;

	          if (op & 16) {
	            /* distance base */
	            dist = here & 0xffff /*here.val*/;
	            op &= 15; /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & (1 << op) - 1;
	            //#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	            //#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg; /* max distance in output */
	            if (dist > op) {
	              /* see if copy from window */
	              op = dist - op; /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	                // (!) This block is disabled in zlib defailts,
	                // don't enable it for binary compatibility
	                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	                //                if (len <= op - whave) {
	                //                  do {
	                //                    output[_out++] = 0;
	                //                  } while (--len);
	                //                  continue top;
	                //                }
	                //                len -= op - whave;
	                //                do {
	                //                  output[_out++] = 0;
	                //                } while (--op > whave);
	                //                if (op === 0) {
	                //                  from = _out - dist;
	                //                  do {
	                //                    output[_out++] = output[from++];
	                //                  } while (--len);
	                //                  continue top;
	                //                }
	                //#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {
	                /* very common case */
	                from += wsize - op;
	                if (op < len) {
	                  /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist; /* rest from output */
	                  from_source = output;
	                }
	              } else if (wnext < op) {
	                /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {
	                  /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {
	                    /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist; /* rest from output */
	                    from_source = output;
	                  }
	                }
	              } else {
	                /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {
	                  /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist; /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            } else {
	              from = _out - dist; /* copy direct from output */
	              do {
	                /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          } else if ((op & 64) === 0) {
	            /* 2nd level distance code */
	            here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
	            continue dodist;
	          } else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      } else if ((op & 64) === 0) {
	        /* 2nd level length code */
	        here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
	        continue dolen;
	      } else if (op & 32) {
	        /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      } else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
	  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(334);

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [/* Length codes 257..285 base */
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];

	var lext = [/* Length codes 257..285 extra */
	16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];

	var dbase = [/* Distance codes 0..29 base */
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];

	var dext = [/* Distance codes 0..29 extra */
	16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
	  var bits = opts.bits;
	  //here = opts.here; /* table entry for duplication */

	  var len = 0; /* a code's length in bits */
	  var sym = 0; /* index of code symbols */
	  var min = 0,
	      max = 0; /* minimum and maximum code lengths */
	  var root = 0; /* number of index bits for root table */
	  var curr = 0; /* number of index bits for current table */
	  var drop = 0; /* code bits to drop for sub-table */
	  var left = 0; /* number of prefix codes available */
	  var used = 0; /* code entries in table used */
	  var huff = 0; /* Huffman code */
	  var incr; /* for incrementing code, index */
	  var fill; /* index for replicating entries */
	  var low; /* low bits for current root entry */
	  var mask; /* mask for low root bits */
	  var next; /* next available space in table */
	  var base = null; /* base value table to use */
	  var base_index = 0;
	  //  var shoextra;    /* extra bits table to use */
	  var end; /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.
	    This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.
	    The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.
	    The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) {
	      break;
	    }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {
	    /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = 1 << 24 | 64 << 16 | 0;

	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = 1 << 24 | 64 << 16 | 0;

	    opts.bits = 1;
	    return 0; /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) {
	      break;
	    }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    } /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1; /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.
	    root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.
	    When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.
	    used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.
	    sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work; /* dummy value--not used */
	    end = 19;
	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;
	  } else {
	    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0; /* starting code */
	  sym = 0; /* starting code symbol */
	  len = min; /* starting code length */
	  next = table_index; /* current table to fill in */
	  curr = root; /* current table index bits */
	  drop = 0; /* current bits to drop from code for index */
	  low = -1; /* trigger new sub-table when len > root */
	  used = 1 << root; /* use root table entries */
	  mask = used - 1; /* mask for comparing low */

	  /* check available table space */
	  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
	    return 1;
	  }

	  var i = 0;
	  /* process all codes and make table entries */
	  for (;;) {
	    i++;
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    } else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    } else {
	      here_op = 32 + 64; /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << len - drop;
	    fill = 1 << curr;
	    min = fill; /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << len - 1;
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) {
	        break;
	      }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min; /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) {
	          break;
	        }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = root << 24 | curr << 16 | next - table_index | 0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};

/***/ },
/* 341 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH: 0,
	  Z_PARTIAL_FLUSH: 1,
	  Z_SYNC_FLUSH: 2,
	  Z_FULL_FLUSH: 3,
	  Z_FINISH: 4,
	  Z_BLOCK: 5,
	  Z_TREES: 6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK: 0,
	  Z_STREAM_END: 1,
	  Z_NEED_DICT: 2,
	  Z_ERRNO: -1,
	  Z_STREAM_ERROR: -2,
	  Z_DATA_ERROR: -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR: -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION: 0,
	  Z_BEST_SPEED: 1,
	  Z_BEST_COMPRESSION: 9,
	  Z_DEFAULT_COMPRESSION: -1,

	  Z_FILTERED: 1,
	  Z_HUFFMAN_ONLY: 2,
	  Z_RLE: 3,
	  Z_FIXED: 4,
	  Z_DEFAULT_STRATEGY: 0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY: 0,
	  Z_TEXT: 1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN: 2,

	  /* The deflate compression method */
	  Z_DEFLATED: 8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(263);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = function () {
	  return function foo() {}.name === 'foo';
	}();
	function pToString(obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' + name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	    // 7.2. If the expected value is a Date object, the actual value is
	    // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	    // 7.3 If the expected value is a RegExp object, the actual value is
	    // equivalent if it is also a RegExp object with the same source and
	    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

	    // 7.4. Other pairs that do not both pass typeof value == 'object',
	    // equivalence is determined by ==.
	  } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	    // If both values are instances of typed arrays, wrap their underlying
	    // ArrayBuffers in a Buffer each to increase performance
	    // This optimization requires the arrays to have the same type as checked by
	    // Object.prototype.toString (aka pToString). Never perform binary
	    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	    // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;

	    // 7.5 For all other Object pairs, including Array objects, equivalence is
	    // determined by having the same number of owned properties (as verified
	    // with Object.prototype.hasOwnProperty.call), the same set of keys
	    // (although not necessarily the same order), equivalent values for every
	    // corresponding key, and an identical 'prototype' property. Note: this
	    // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || { actual: [], expected: [] };

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length) return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i]) return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function (block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function (err) {
	  if (err) throw err;
	};

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var bytes = __webpack_require__(305);
	var debug = __webpack_require__(197)('body-parser:raw');
	var read = __webpack_require__(306);
	var typeis = __webpack_require__(291);

	/**
	 * Module exports.
	 */

	module.exports = raw;

	/**
	 * Create a middleware to parse raw bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @api public
	 */

	function raw(options) {
	  var opts = options || {};

	  var inflate = opts.inflate !== false;
	  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
	  var type = opts.type || 'application/octet-stream';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function');
	  }

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;

	  function parse(buf) {
	    return buf;
	  }

	  return function rawParser(req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return;
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return;
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return;
	    }

	    // read
	    read(req, res, next, parse, debug, {
	      encoding: null,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  };
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker(type) {
	  return function checkType(req) {
	    return Boolean(typeis(req, type));
	  };
	}

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var bytes = __webpack_require__(305);
	var contentType = __webpack_require__(233);
	var debug = __webpack_require__(197)('body-parser:text');
	var read = __webpack_require__(306);
	var typeis = __webpack_require__(291);

	/**
	 * Module exports.
	 */

	module.exports = text;

	/**
	 * Create a middleware to parse text bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @api public
	 */

	function text(options) {
	  var opts = options || {};

	  var defaultCharset = opts.defaultCharset || 'utf-8';
	  var inflate = opts.inflate !== false;
	  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
	  var type = opts.type || 'text/plain';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function');
	  }

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;

	  function parse(buf) {
	    return buf;
	  }

	  return function textParser(req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return;
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return;
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return;
	    }

	    // get charset
	    var charset = getCharset(req) || defaultCharset;

	    // read
	    read(req, res, next, parse, debug, {
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  };
	}

	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */

	function getCharset(req) {
	  try {
	    return contentType.parse(req).parameters.charset.toLowerCase();
	  } catch (e) {
	    return undefined;
	  }
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker(type) {
	  return function checkType(req) {
	    return Boolean(typeis(req, type));
	  };
	}

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * body-parser
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var bytes = __webpack_require__(305);
	var contentType = __webpack_require__(233);
	var createError = __webpack_require__(235);
	var debug = __webpack_require__(197)('body-parser:urlencoded');
	var deprecate = __webpack_require__(214)('body-parser');
	var read = __webpack_require__(306);
	var typeis = __webpack_require__(291);

	/**
	 * Module exports.
	 */

	module.exports = urlencoded;

	/**
	 * Cache of parser modules.
	 */

	var parsers = Object.create(null);

	/**
	 * Create a middleware to parse urlencoded bodies.
	 *
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function urlencoded(options) {
	  var opts = options || {};

	  // notice because option default will flip in next major
	  if (opts.extended === undefined) {
	    deprecate('undefined extended: provide extended option');
	  }

	  var extended = opts.extended !== false;
	  var inflate = opts.inflate !== false;
	  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
	  var type = opts.type || 'application/x-www-form-urlencoded';
	  var verify = opts.verify || false;

	  if (verify !== false && typeof verify !== 'function') {
	    throw new TypeError('option verify must be function');
	  }

	  // create the appropriate query parser
	  var queryparse = extended ? extendedparser(opts) : simpleparser(opts);

	  // create the appropriate type checking function
	  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;

	  function parse(body) {
	    return body.length ? queryparse(body) : {};
	  }

	  return function urlencodedParser(req, res, next) {
	    if (req._body) {
	      debug('body already parsed');
	      next();
	      return;
	    }

	    req.body = req.body || {};

	    // skip requests without bodies
	    if (!typeis.hasBody(req)) {
	      debug('skip empty body');
	      next();
	      return;
	    }

	    debug('content-type %j', req.headers['content-type']);

	    // determine if request should be parsed
	    if (!shouldParse(req)) {
	      debug('skip parsing');
	      next();
	      return;
	    }

	    // assert charset
	    var charset = getCharset(req) || 'utf-8';
	    if (charset !== 'utf-8') {
	      debug('invalid charset');
	      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
	        charset: charset
	      }));
	      return;
	    }

	    // read
	    read(req, res, next, parse, debug, {
	      debug: debug,
	      encoding: charset,
	      inflate: inflate,
	      limit: limit,
	      verify: verify
	    });
	  };
	}

	/**
	 * Get the extended query parser.
	 *
	 * @param {object} options
	 */

	function extendedparser(options) {
	  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
	  var parse = parser('qs');

	  if (isNaN(parameterLimit) || parameterLimit < 1) {
	    throw new TypeError('option parameterLimit must be a positive number');
	  }

	  if (isFinite(parameterLimit)) {
	    parameterLimit = parameterLimit | 0;
	  }

	  return function queryparse(body) {
	    var paramCount = parameterCount(body, parameterLimit);

	    if (paramCount === undefined) {
	      debug('too many parameters');
	      throw createError(413, 'too many parameters');
	    }

	    var arrayLimit = Math.max(100, paramCount);

	    debug('parse extended urlencoding');
	    return parse(body, {
	      allowPrototypes: true,
	      arrayLimit: arrayLimit,
	      depth: Infinity,
	      parameterLimit: parameterLimit
	    });
	  };
	}

	/**
	 * Get the charset of a request.
	 *
	 * @param {object} req
	 * @api private
	 */

	function getCharset(req) {
	  try {
	    return contentType.parse(req).parameters.charset.toLowerCase();
	  } catch (e) {
	    return undefined;
	  }
	}

	/**
	 * Count the number of parameters, stopping once limit reached
	 *
	 * @param {string} body
	 * @param {number} limit
	 * @api private
	 */

	function parameterCount(body, limit) {
	  var count = 0;
	  var index = 0;

	  while ((index = body.indexOf('&', index)) !== -1) {
	    count++;
	    index++;

	    if (count === limit) {
	      return undefined;
	    }
	  }

	  return count;
	}

	/**
	 * Get parser for module name dynamically.
	 *
	 * @param {string} name
	 * @return {function}
	 * @api private
	 */

	function parser(name) {
	  var mod = parsers[name];

	  if (mod !== undefined) {
	    return mod.parse;
	  }

	  // this uses a switch for static require analysis
	  switch (name) {
	    case 'qs':
	      mod = __webpack_require__(225);
	      break;
	    case 'querystring':
	      mod = __webpack_require__(220);
	      break;
	  }

	  // store to prevent invoking require()
	  parsers[name] = mod;

	  return mod.parse;
	}

	/**
	 * Get the simple query parser.
	 *
	 * @param {object} options
	 */

	function simpleparser(options) {
	  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
	  var parse = parser('querystring');

	  if (isNaN(parameterLimit) || parameterLimit < 1) {
	    throw new TypeError('option parameterLimit must be a positive number');
	  }

	  if (isFinite(parameterLimit)) {
	    parameterLimit = parameterLimit | 0;
	  }

	  return function queryparse(body) {
	    var paramCount = parameterCount(body, parameterLimit);

	    if (paramCount === undefined) {
	      debug('too many parameters');
	      throw createError(413, 'too many parameters');
	    }

	    debug('parse urlencoding');
	    return parse(body, undefined, undefined, { maxKeys: parameterLimit });
	  };
	}

	/**
	 * Get the simple type checker.
	 *
	 * @param {string} type
	 * @return {function}
	 */

	function typeChecker(type) {
	  return function checkType(req) {
	    return Boolean(typeis(req, type));
	  };
	}

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate, Buffer) {/*!
	 * express-session
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var cookie = __webpack_require__(299);
	var crc = __webpack_require__(347).crc32;
	var debug = __webpack_require__(197)('express-session');
	var deprecate = __webpack_require__(214)('express-session');
	var parseUrl = __webpack_require__(215);
	var uid = __webpack_require__(359).sync,
	    onHeaders = __webpack_require__(362),
	    signature = __webpack_require__(298);

	var Session = __webpack_require__(363),
	    MemoryStore = __webpack_require__(364),
	    Cookie = __webpack_require__(366),
	    Store = __webpack_require__(365);

	// environment

	var env = process.env.NODE_ENV;

	/**
	 * Expose the middleware.
	 */

	exports = module.exports = session;

	/**
	 * Expose constructors.
	 */

	exports.Store = Store;
	exports.Cookie = Cookie;
	exports.Session = Session;
	exports.MemoryStore = MemoryStore;

	/**
	 * Warning message for `MemoryStore` usage in production.
	 * @private
	 */

	var warning = 'Warning: connect.session() MemoryStore is not\n' + 'designed for a production environment, as it will leak\n' + 'memory, and will not scale past a single process.';

	/**
	 * Node.js 0.8+ async implementation.
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
	  process.nextTick(fn.bind.apply(fn, arguments));
	};

	/**
	 * Setup session store with the given `options`.
	 *
	 * @param {Object} [options]
	 * @param {Object} [options.cookie] Options for cookie
	 * @param {Function} [options.genid]
	 * @param {String} [options.name=connect.sid] Session ID cookie name
	 * @param {Boolean} [options.proxy]
	 * @param {Boolean} [options.resave] Resave unmodified sessions back to the store
	 * @param {Boolean} [options.rolling] Enable/disable rolling session expiration
	 * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store
	 * @param {String|Array} [options.secret] Secret for signing session ID
	 * @param {Object} [options.store=MemoryStore] Session store
	 * @param {String} [options.unset]
	 * @return {Function} middleware
	 * @public
	 */

	function session(options) {
	  var opts = options || {};

	  // get the cookie options
	  var cookieOptions = opts.cookie || {};

	  // get the session id generate function
	  var generateId = opts.genid || generateSessionId;

	  // get the session cookie name
	  var name = opts.name || opts.key || 'connect.sid';

	  // get the session store
	  var store = opts.store || new MemoryStore();

	  // get the trust proxy setting
	  var trustProxy = opts.proxy;

	  // get the resave session option
	  var resaveSession = opts.resave;

	  // get the rolling session option
	  var rollingSessions = Boolean(opts.rolling);

	  // get the save uninitialized session option
	  var saveUninitializedSession = opts.saveUninitialized;

	  // get the cookie signing secret
	  var secret = opts.secret;

	  if (typeof generateId !== 'function') {
	    throw new TypeError('genid option must be a function');
	  }

	  if (resaveSession === undefined) {
	    deprecate('undefined resave option; provide resave option');
	    resaveSession = true;
	  }

	  if (saveUninitializedSession === undefined) {
	    deprecate('undefined saveUninitialized option; provide saveUninitialized option');
	    saveUninitializedSession = true;
	  }

	  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {
	    throw new TypeError('unset option must be "destroy" or "keep"');
	  }

	  // TODO: switch to "destroy" on next major
	  var unsetDestroy = opts.unset === 'destroy';

	  if (Array.isArray(secret) && secret.length === 0) {
	    throw new TypeError('secret option array must contain one or more strings');
	  }

	  if (secret && !Array.isArray(secret)) {
	    secret = [secret];
	  }

	  if (!secret) {
	    deprecate('req.secret; provide secret option');
	  }

	  // notify user that this store is not
	  // meant for a production environment
	  if ('production' == env && store instanceof MemoryStore) {
	    /* istanbul ignore next: not tested */
	    console.warn(warning);
	  }

	  // generates the new session
	  store.generate = function (req) {
	    req.sessionID = generateId(req);
	    req.session = new Session(req);
	    req.session.cookie = new Cookie(cookieOptions);

	    if (cookieOptions.secure === 'auto') {
	      req.session.cookie.secure = issecure(req, trustProxy);
	    }
	  };

	  var storeImplementsTouch = typeof store.touch === 'function';

	  // register event listeners for the store to track readiness
	  var storeReady = true;
	  store.on('disconnect', function ondisconnect() {
	    storeReady = false;
	  });
	  store.on('connect', function onconnect() {
	    storeReady = true;
	  });

	  return function session(req, res, next) {
	    // self-awareness
	    if (req.session) {
	      next();
	      return;
	    }

	    // Handle connection as if there is no session if
	    // the store has temporarily disconnected etc
	    if (!storeReady) {
	      debug('store is disconnected');
	      next();
	      return;
	    }

	    // pathname mismatch
	    var originalPath = parseUrl.original(req).pathname;
	    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next();

	    // ensure a secret is available or bail
	    if (!secret && !req.secret) {
	      next(new Error('secret option required for sessions'));
	      return;
	    }

	    // backwards compatibility for signed cookies
	    // req.secret is passed from the cookie parser middleware
	    var secrets = secret || [req.secret];

	    var originalHash;
	    var originalId;
	    var savedHash;

	    // expose store
	    req.sessionStore = store;

	    // get the session ID from the cookie
	    var cookieId = req.sessionID = getcookie(req, name, secrets);

	    // set-cookie
	    onHeaders(res, function () {
	      if (!req.session) {
	        debug('no session');
	        return;
	      }

	      if (!shouldSetCookie(req)) {
	        return;
	      }

	      // only send secure cookies via https
	      if (req.session.cookie.secure && !issecure(req, trustProxy)) {
	        debug('not secured');
	        return;
	      }

	      // touch session
	      req.session.touch();

	      // set cookie
	      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);
	    });

	    // proxy end() to commit the session
	    var _end = res.end;
	    var _write = res.write;
	    var ended = false;
	    res.end = function end(chunk, encoding) {
	      if (ended) {
	        return false;
	      }

	      ended = true;

	      var ret;
	      var sync = true;

	      function writeend() {
	        if (sync) {
	          ret = _end.call(res, chunk, encoding);
	          sync = false;
	          return;
	        }

	        _end.call(res);
	      }

	      function writetop() {
	        if (!sync) {
	          return ret;
	        }

	        if (chunk == null) {
	          ret = true;
	          return ret;
	        }

	        var contentLength = Number(res.getHeader('Content-Length'));

	        if (!isNaN(contentLength) && contentLength > 0) {
	          // measure chunk
	          chunk = !Buffer.isBuffer(chunk) ? new Buffer(chunk, encoding) : chunk;
	          encoding = undefined;

	          if (chunk.length !== 0) {
	            debug('split response');
	            ret = _write.call(res, chunk.slice(0, chunk.length - 1));
	            chunk = chunk.slice(chunk.length - 1, chunk.length);
	            return ret;
	          }
	        }

	        ret = _write.call(res, chunk, encoding);
	        sync = false;

	        return ret;
	      }

	      if (shouldDestroy(req)) {
	        // destroy session
	        debug('destroying');
	        store.destroy(req.sessionID, function ondestroy(err) {
	          if (err) {
	            defer(next, err);
	          }

	          debug('destroyed');
	          writeend();
	        });

	        return writetop();
	      }

	      // no session to save
	      if (!req.session) {
	        debug('no session');
	        return _end.call(res, chunk, encoding);
	      }

	      if (shouldSave(req)) {
	        req.session.save(function onsave(err) {
	          if (err) {
	            defer(next, err);
	          }

	          writeend();
	        });

	        return writetop();
	      } else if (storeImplementsTouch && shouldTouch(req)) {
	        // store implements touch method
	        debug('touching');
	        store.touch(req.sessionID, req.session, function ontouch(err) {
	          if (err) {
	            defer(next, err);
	          }

	          debug('touched');
	          writeend();
	        });

	        return writetop();
	      }

	      return _end.call(res, chunk, encoding);
	    };

	    // generate the session
	    function generate() {
	      store.generate(req);
	      originalId = req.sessionID;
	      originalHash = hash(req.session);
	      wrapmethods(req.session);
	    }

	    // wrap session methods
	    function wrapmethods(sess) {
	      var _save = sess.save;

	      function save() {
	        debug('saving %s', this.id);
	        savedHash = hash(this);
	        _save.apply(this, arguments);
	      }

	      Object.defineProperty(sess, 'save', {
	        configurable: true,
	        enumerable: false,
	        value: save,
	        writable: true
	      });
	    }

	    // check if session has been modified
	    function isModified(sess) {
	      return originalId !== sess.id || originalHash !== hash(sess);
	    }

	    // check if session has been saved
	    function isSaved(sess) {
	      return originalId === sess.id && savedHash === hash(sess);
	    }

	    // determine if session should be destroyed
	    function shouldDestroy(req) {
	      return req.sessionID && unsetDestroy && req.session == null;
	    }

	    // determine if session should be saved to store
	    function shouldSave(req) {
	      // cannot set cookie without a session ID
	      if (typeof req.sessionID !== 'string') {
	        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
	        return false;
	      }

	      return !saveUninitializedSession && cookieId !== req.sessionID ? isModified(req.session) : !isSaved(req.session);
	    }

	    // determine if session should be touched
	    function shouldTouch(req) {
	      // cannot set cookie without a session ID
	      if (typeof req.sessionID !== 'string') {
	        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
	        return false;
	      }

	      return cookieId === req.sessionID && !shouldSave(req);
	    }

	    // determine if cookie should be set on response
	    function shouldSetCookie(req) {
	      // cannot set cookie without a session ID
	      if (typeof req.sessionID !== 'string') {
	        return false;
	      }

	      return cookieId != req.sessionID ? saveUninitializedSession || isModified(req.session) : rollingSessions || req.session.cookie.expires != null && isModified(req.session);
	    }

	    // generate a session if the browser doesn't send a sessionID
	    if (!req.sessionID) {
	      debug('no SID sent, generating session');
	      generate();
	      next();
	      return;
	    }

	    // generate the session object
	    debug('fetching %s', req.sessionID);
	    store.get(req.sessionID, function (err, sess) {
	      // error handling
	      if (err) {
	        debug('error %j', err);

	        if (err.code !== 'ENOENT') {
	          next(err);
	          return;
	        }

	        generate();
	        // no session
	      } else if (!sess) {
	        debug('no session found');
	        generate();
	        // populate req.session
	      } else {
	        debug('session found');
	        store.createSession(req, sess);
	        originalId = req.sessionID;
	        originalHash = hash(sess);

	        if (!resaveSession) {
	          savedHash = originalHash;
	        }

	        wrapmethods(req.session);
	      }

	      next();
	    });
	  };
	};

	/**
	 * Generate a session ID for a new session.
	 *
	 * @return {String}
	 * @private
	 */

	function generateSessionId(sess) {
	  return uid(24);
	}

	/**
	 * Get the session ID cookie from request.
	 *
	 * @return {string}
	 * @private
	 */

	function getcookie(req, name, secrets) {
	  var header = req.headers.cookie;
	  var raw;
	  var val;

	  // read from cookie header
	  if (header) {
	    var cookies = cookie.parse(header);

	    raw = cookies[name];

	    if (raw) {
	      if (raw.substr(0, 2) === 's:') {
	        val = unsigncookie(raw.slice(2), secrets);

	        if (val === false) {
	          debug('cookie signature invalid');
	          val = undefined;
	        }
	      } else {
	        debug('cookie unsigned');
	      }
	    }
	  }

	  // back-compat read from cookieParser() signedCookies data
	  if (!val && req.signedCookies) {
	    val = req.signedCookies[name];

	    if (val) {
	      deprecate('cookie should be available in req.headers.cookie');
	    }
	  }

	  // back-compat read from cookieParser() cookies data
	  if (!val && req.cookies) {
	    raw = req.cookies[name];

	    if (raw) {
	      if (raw.substr(0, 2) === 's:') {
	        val = unsigncookie(raw.slice(2), secrets);

	        if (val) {
	          deprecate('cookie should be available in req.headers.cookie');
	        }

	        if (val === false) {
	          debug('cookie signature invalid');
	          val = undefined;
	        }
	      } else {
	        debug('cookie unsigned');
	      }
	    }
	  }

	  return val;
	}

	/**
	 * Hash the given `sess` object omitting changes to `.cookie`.
	 *
	 * @param {Object} sess
	 * @return {String}
	 * @private
	 */

	function hash(sess) {
	  return crc(JSON.stringify(sess, function (key, val) {
	    if (key !== 'cookie') {
	      return val;
	    }
	  }));
	}

	/**
	 * Determine if request is secure.
	 *
	 * @param {Object} req
	 * @param {Boolean} [trustProxy]
	 * @return {Boolean}
	 * @private
	 */

	function issecure(req, trustProxy) {
	  // socket is https server
	  if (req.connection && req.connection.encrypted) {
	    return true;
	  }

	  // do not trust proxy
	  if (trustProxy === false) {
	    return false;
	  }

	  // no explicit trust; try req.secure from express
	  if (trustProxy !== true) {
	    var secure = req.secure;
	    return typeof secure === 'boolean' ? secure : false;
	  }

	  // read the proto from x-forwarded-proto header
	  var header = req.headers['x-forwarded-proto'] || '';
	  var index = header.indexOf(',');
	  var proto = index !== -1 ? header.substr(0, index).toLowerCase().trim() : header.toLowerCase().trim();

	  return proto === 'https';
	}

	/**
	 * Set cookie on response.
	 *
	 * @private
	 */

	function setcookie(res, name, val, secret, options) {
	  var signed = 's:' + signature.sign(val, secret);
	  var data = cookie.serialize(name, signed, options);

	  debug('set-cookie %s', data);

	  var prev = res.getHeader('set-cookie') || [];
	  var header = Array.isArray(prev) ? prev.concat(data) : Array.isArray(data) ? [prev].concat(data) : [prev, data];

	  res.setHeader('set-cookie', header);
	}

	/**
	 * Verify and decode the given `val` with `secrets`.
	 *
	 * @param {String} val
	 * @param {Array} secrets
	 * @returns {String|Boolean}
	 * @private
	 */
	function unsigncookie(val, secrets) {
	  for (var i = 0; i < secrets.length; i++) {
	    var result = signature.unsign(val, secrets[i]);

	    if (result !== false) {
	      return result;
	    }
	  }

	  return false;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(192).setImmediate, __webpack_require__(193).Buffer))

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  crc1: __webpack_require__(348),
	  crc8: __webpack_require__(350),
	  crc81wire: __webpack_require__(351),
	  crc16: __webpack_require__(352),
	  crc16ccitt: __webpack_require__(353),
	  crc16modbus: __webpack_require__(354),
	  crc16xmodem: __webpack_require__(355),
	  crc16kermit: __webpack_require__(356),
	  crc24: __webpack_require__(357),
	  crc32: __webpack_require__(358)
	};

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	module.exports = (0, _define_crc2.default)('crc1', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = ~~previous;
	  var accum = 0;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    accum += byte;
	  }

	  crc += accum % 256;
	  return crc % 256;
	});

/***/ },
/* 349 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (model, calc) {
	  var fn = function fn(buf, previous) {
	    return calc(buf, previous) >>> 0;
	  };
	  fn.signed = calc;
	  fn.unsigned = fn;
	  fn.model = model;

	  return fn;
	};

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=crc-8 --generate=c`
	var TABLE = [0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15, 0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d, 0x70, 0x77, 0x7e, 0x79, 0x6c, 0x6b, 0x62, 0x65, 0x48, 0x4f, 0x46, 0x41, 0x54, 0x53, 0x5a, 0x5d, 0xe0, 0xe7, 0xee, 0xe9, 0xfc, 0xfb, 0xf2, 0xf5, 0xd8, 0xdf, 0xd6, 0xd1, 0xc4, 0xc3, 0xca, 0xcd, 0x90, 0x97, 0x9e, 0x99, 0x8c, 0x8b, 0x82, 0x85, 0xa8, 0xaf, 0xa6, 0xa1, 0xb4, 0xb3, 0xba, 0xbd, 0xc7, 0xc0, 0xc9, 0xce, 0xdb, 0xdc, 0xd5, 0xd2, 0xff, 0xf8, 0xf1, 0xf6, 0xe3, 0xe4, 0xed, 0xea, 0xb7, 0xb0, 0xb9, 0xbe, 0xab, 0xac, 0xa5, 0xa2, 0x8f, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9d, 0x9a, 0x27, 0x20, 0x29, 0x2e, 0x3b, 0x3c, 0x35, 0x32, 0x1f, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0d, 0x0a, 0x57, 0x50, 0x59, 0x5e, 0x4b, 0x4c, 0x45, 0x42, 0x6f, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7d, 0x7a, 0x89, 0x8e, 0x87, 0x80, 0x95, 0x92, 0x9b, 0x9c, 0xb1, 0xb6, 0xbf, 0xb8, 0xad, 0xaa, 0xa3, 0xa4, 0xf9, 0xfe, 0xf7, 0xf0, 0xe5, 0xe2, 0xeb, 0xec, 0xc1, 0xc6, 0xcf, 0xc8, 0xdd, 0xda, 0xd3, 0xd4, 0x69, 0x6e, 0x67, 0x60, 0x75, 0x72, 0x7b, 0x7c, 0x51, 0x56, 0x5f, 0x58, 0x4d, 0x4a, 0x43, 0x44, 0x19, 0x1e, 0x17, 0x10, 0x05, 0x02, 0x0b, 0x0c, 0x21, 0x26, 0x2f, 0x28, 0x3d, 0x3a, 0x33, 0x34, 0x4e, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5c, 0x5b, 0x76, 0x71, 0x78, 0x7f, 0x6a, 0x6d, 0x64, 0x63, 0x3e, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2c, 0x2b, 0x06, 0x01, 0x08, 0x0f, 0x1a, 0x1d, 0x14, 0x13, 0xae, 0xa9, 0xa0, 0xa7, 0xb2, 0xb5, 0xbc, 0xbb, 0x96, 0x91, 0x98, 0x9f, 0x8a, 0x8d, 0x84, 0x83, 0xde, 0xd9, 0xd0, 0xd7, 0xc2, 0xc5, 0xcc, 0xcb, 0xe6, 0xe1, 0xe8, 0xef, 0xfa, 0xfd, 0xf4, 0xf3];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('crc-8', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = ~~previous;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
	  }

	  return crc;
	});

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=dallas-1-wire --generate=c`
	var TABLE = [0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83, 0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41, 0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e, 0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc, 0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0, 0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62, 0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d, 0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff, 0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5, 0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07, 0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58, 0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a, 0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6, 0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24, 0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b, 0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9, 0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f, 0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd, 0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92, 0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50, 0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c, 0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee, 0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1, 0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73, 0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49, 0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b, 0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4, 0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16, 0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a, 0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8, 0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7, 0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('dallas-1-wire', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = ~~previous;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
	  }

	  return crc;
	});

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=crc-16 --generate=c`
	var TABLE = [0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('crc-16', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = ~~previous;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
	  }

	  return crc;
	});

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=ccitt --generate=c`
	var TABLE = [0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('ccitt', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = typeof previous !== 'undefined' ? ~~previous : 0xffff;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = (TABLE[(crc >> 8 ^ byte) & 0xff] ^ crc << 8) & 0xffff;
	  }

	  return crc;
	});

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=crc-16-modbus --generate=c`
	var TABLE = [0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('crc-16-modbus', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = typeof previous !== 'undefined' ? ~~previous : 0xffff;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
	  }

	  return crc;
	});

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	module.exports = (0, _define_crc2.default)('xmodem', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = typeof previous !== 'undefined' ? ~~previous : 0x0;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    var code = crc >>> 8 & 0xFF;

	    code ^= byte & 0xFF;
	    code ^= code >>> 4;
	    crc = crc << 8 & 0xFFFF;
	    crc ^= code;
	    code = code << 5 & 0xFFFF;
	    crc ^= code;
	    code = code << 7 & 0xFFFF;
	    crc ^= code;
	  }

	  return crc;
	});

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=kermit --generate=c`
	var TABLE = [0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876, 0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1, 0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70, 0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff, 0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a, 0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9, 0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('kermit', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = typeof previous !== 'undefined' ? ~~previous : 0x0000;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
	  }

	  return crc;
	});

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-drive --model=crc-24 --generate=c`
	var TABLE = [0x000000, 0x864cfb, 0x8ad50d, 0x0c99f6, 0x93e6e1, 0x15aa1a, 0x1933ec, 0x9f7f17, 0xa18139, 0x27cdc2, 0x2b5434, 0xad18cf, 0x3267d8, 0xb42b23, 0xb8b2d5, 0x3efe2e, 0xc54e89, 0x430272, 0x4f9b84, 0xc9d77f, 0x56a868, 0xd0e493, 0xdc7d65, 0x5a319e, 0x64cfb0, 0xe2834b, 0xee1abd, 0x685646, 0xf72951, 0x7165aa, 0x7dfc5c, 0xfbb0a7, 0x0cd1e9, 0x8a9d12, 0x8604e4, 0x00481f, 0x9f3708, 0x197bf3, 0x15e205, 0x93aefe, 0xad50d0, 0x2b1c2b, 0x2785dd, 0xa1c926, 0x3eb631, 0xb8faca, 0xb4633c, 0x322fc7, 0xc99f60, 0x4fd39b, 0x434a6d, 0xc50696, 0x5a7981, 0xdc357a, 0xd0ac8c, 0x56e077, 0x681e59, 0xee52a2, 0xe2cb54, 0x6487af, 0xfbf8b8, 0x7db443, 0x712db5, 0xf7614e, 0x19a3d2, 0x9fef29, 0x9376df, 0x153a24, 0x8a4533, 0x0c09c8, 0x00903e, 0x86dcc5, 0xb822eb, 0x3e6e10, 0x32f7e6, 0xb4bb1d, 0x2bc40a, 0xad88f1, 0xa11107, 0x275dfc, 0xdced5b, 0x5aa1a0, 0x563856, 0xd074ad, 0x4f0bba, 0xc94741, 0xc5deb7, 0x43924c, 0x7d6c62, 0xfb2099, 0xf7b96f, 0x71f594, 0xee8a83, 0x68c678, 0x645f8e, 0xe21375, 0x15723b, 0x933ec0, 0x9fa736, 0x19ebcd, 0x8694da, 0x00d821, 0x0c41d7, 0x8a0d2c, 0xb4f302, 0x32bff9, 0x3e260f, 0xb86af4, 0x2715e3, 0xa15918, 0xadc0ee, 0x2b8c15, 0xd03cb2, 0x567049, 0x5ae9bf, 0xdca544, 0x43da53, 0xc596a8, 0xc90f5e, 0x4f43a5, 0x71bd8b, 0xf7f170, 0xfb6886, 0x7d247d, 0xe25b6a, 0x641791, 0x688e67, 0xeec29c, 0x3347a4, 0xb50b5f, 0xb992a9, 0x3fde52, 0xa0a145, 0x26edbe, 0x2a7448, 0xac38b3, 0x92c69d, 0x148a66, 0x181390, 0x9e5f6b, 0x01207c, 0x876c87, 0x8bf571, 0x0db98a, 0xf6092d, 0x7045d6, 0x7cdc20, 0xfa90db, 0x65efcc, 0xe3a337, 0xef3ac1, 0x69763a, 0x578814, 0xd1c4ef, 0xdd5d19, 0x5b11e2, 0xc46ef5, 0x42220e, 0x4ebbf8, 0xc8f703, 0x3f964d, 0xb9dab6, 0xb54340, 0x330fbb, 0xac70ac, 0x2a3c57, 0x26a5a1, 0xa0e95a, 0x9e1774, 0x185b8f, 0x14c279, 0x928e82, 0x0df195, 0x8bbd6e, 0x872498, 0x016863, 0xfad8c4, 0x7c943f, 0x700dc9, 0xf64132, 0x693e25, 0xef72de, 0xe3eb28, 0x65a7d3, 0x5b59fd, 0xdd1506, 0xd18cf0, 0x57c00b, 0xc8bf1c, 0x4ef3e7, 0x426a11, 0xc426ea, 0x2ae476, 0xaca88d, 0xa0317b, 0x267d80, 0xb90297, 0x3f4e6c, 0x33d79a, 0xb59b61, 0x8b654f, 0x0d29b4, 0x01b042, 0x87fcb9, 0x1883ae, 0x9ecf55, 0x9256a3, 0x141a58, 0xefaaff, 0x69e604, 0x657ff2, 0xe33309, 0x7c4c1e, 0xfa00e5, 0xf69913, 0x70d5e8, 0x4e2bc6, 0xc8673d, 0xc4fecb, 0x42b230, 0xddcd27, 0x5b81dc, 0x57182a, 0xd154d1, 0x26359f, 0xa07964, 0xace092, 0x2aac69, 0xb5d37e, 0x339f85, 0x3f0673, 0xb94a88, 0x87b4a6, 0x01f85d, 0x0d61ab, 0x8b2d50, 0x145247, 0x921ebc, 0x9e874a, 0x18cbb1, 0xe37b16, 0x6537ed, 0x69ae1b, 0xefe2e0, 0x709df7, 0xf6d10c, 0xfa48fa, 0x7c0401, 0x42fa2f, 0xc4b6d4, 0xc82f22, 0x4e63d9, 0xd11cce, 0x575035, 0x5bc9c3, 0xdd8538];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('crc-24', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = typeof previous !== 'undefined' ? ~~previous : 0xb704ce;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = (TABLE[(crc >> 16 ^ byte) & 0xff] ^ crc << 8) & 0xffffff;
	  }

	  return crc;
	});

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _buffer = __webpack_require__(193);

	var _define_crc = __webpack_require__(349);

	var _define_crc2 = _interopRequireDefault(_define_crc);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`
	var TABLE = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];

	if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

	module.exports = (0, _define_crc2.default)('crc-32', function (buf, previous) {
	  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _buffer.Buffer)(buf);

	  var crc = previous === 0 ? 0 : ~~previous ^ -1;

	  for (var index = 0; index < buf.length; index++) {
	    var byte = buf[index];
	    crc = TABLE[(crc ^ byte) & 0xff] ^ crc >>> 8;
	  }

	  return crc ^ -1;
	});

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * uid-safe
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var escape = __webpack_require__(360).escape;
	var randomBytes = __webpack_require__(361);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = uid;
	module.exports.sync = uidSync;

	/**
	 * Create a unique ID.
	 *
	 * @param {number} length
	 * @param {function} [callback]
	 * @return {Promise}
	 * @public
	 */

	function uid(length, callback) {
	  // validate callback is a function, if provided
	  if (callback !== undefined && typeof callback !== 'function') {
	    throw new TypeError('argument callback must be a function');
	  }

	  // require the callback without promises
	  if (!callback && !global.Promise) {
	    throw new TypeError('argument callback is required');
	  }

	  if (callback) {
	    // classic callback style
	    return generateUid(length, callback);
	  }

	  return new Promise(function executor(resolve, reject) {
	    generateUid(length, function onUid(err, str) {
	      if (err) return reject(err);
	      resolve(str);
	    });
	  });
	}

	/**
	 * Create a unique ID sync.
	 *
	 * @param {number} length
	 * @return {string}
	 * @public
	 */

	function uidSync(length) {
	  return toString(randomBytes.sync(length));
	}

	/**
	 * Generate a unique ID string.
	 *
	 * @param {number} length
	 * @param {function} callback
	 * @private
	 */

	function generateUid(length, callback) {
	  randomBytes(length, function (err, buf) {
	    if (err) return callback(err);
	    callback(null, toString(buf));
	  });
	}

	/**
	 * Change a Buffer into a string.
	 *
	 * @param {Buffer} buf
	 * @return {string}
	 * @private
	 */

	function toString(buf) {
	  return escape(buf.toString('base64'));
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var base64url = module.exports;

	base64url.unescape = function unescape(str) {
	  return (str + Array(5 - str.length % 4).join('=')).replace(/\-/g, '+').replace(/_/g, '/');
	};

	base64url.escape = function escape(str) {
	  return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
	};

	base64url.encode = function encode(str) {
	  return this.escape(new Buffer(str).toString('base64'));
	};

	base64url.decode = function decode(str) {
	  return new Buffer(this.unescape(str), 'base64').toString();
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * random-bytes
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var crypto = __webpack_require__(256);

	/**
	 * Module variables.
	 * @private
	 */

	var generateAttempts = crypto.randomBytes === crypto.pseudoRandomBytes ? 1 : 3;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = randomBytes;
	module.exports.sync = randomBytesSync;

	/**
	 * Generates strong pseudo-random bytes.
	 *
	 * @param {number} size
	 * @param {function} [callback]
	 * @return {Promise}
	 * @public
	 */

	function randomBytes(size, callback) {
	  // validate callback is a function, if provided
	  if (callback !== undefined && typeof callback !== 'function') {
	    throw new TypeError('argument callback must be a function');
	  }

	  // require the callback without promises
	  if (!callback && !global.Promise) {
	    throw new TypeError('argument callback is required');
	  }

	  if (callback) {
	    // classic callback style
	    return generateRandomBytes(size, generateAttempts, callback);
	  }

	  return new Promise(function executor(resolve, reject) {
	    generateRandomBytes(size, generateAttempts, function onRandomBytes(err, str) {
	      if (err) return reject(err);
	      resolve(str);
	    });
	  });
	}

	/**
	 * Generates strong pseudo-random bytes sync.
	 *
	 * @param {number} size
	 * @return {Buffer}
	 * @public
	 */

	function randomBytesSync(size) {
	  var err = null;

	  for (var i = 0; i < generateAttempts; i++) {
	    try {
	      return crypto.randomBytes(size);
	    } catch (e) {
	      err = e;
	    }
	  }

	  throw err;
	}

	/**
	 * Generates strong pseudo-random bytes.
	 *
	 * @param {number} size
	 * @param {number} attempts
	 * @param {function} callback
	 * @private
	 */

	function generateRandomBytes(size, attempts, callback) {
	  crypto.randomBytes(size, function onRandomBytes(err, buf) {
	    if (!err) return callback(null, buf);
	    if (! --attempts) return callback(err);
	    setTimeout(generateRandomBytes.bind(null, size, attempts, callback), 10);
	  });
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 362 */
/***/ function(module, exports) {

	/*!
	 * on-headers
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Reference to Array slice.
	 */

	var slice = Array.prototype.slice;

	/**
	 * Execute a listener when a response is about to write headers.
	 *
	 * @param {Object} res
	 * @return {Function} listener
	 * @api public
	 */

	module.exports = function onHeaders(res, listener) {
	  if (!res) {
	    throw new TypeError('argument res is required');
	  }

	  if (typeof listener !== 'function') {
	    throw new TypeError('argument listener must be a function');
	  }

	  res.writeHead = createWriteHead(res.writeHead, listener);
	};

	function createWriteHead(prevWriteHead, listener) {
	  var fired = false;

	  // return function with core name and argument list
	  return function writeHead(statusCode) {
	    // set headers from arguments
	    var args = setWriteHeadHeaders.apply(this, arguments);

	    // fire listener
	    if (!fired) {
	      fired = true;
	      listener.call(this);

	      // pass-along an updated status code
	      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {
	        args[0] = this.statusCode;
	        args.length = 1;
	      }
	    }

	    prevWriteHead.apply(this, args);
	  };
	}

	function setWriteHeadHeaders(statusCode) {
	  var length = arguments.length;
	  var headerIndex = length > 1 && typeof arguments[1] === 'string' ? 2 : 1;

	  var headers = length >= headerIndex + 1 ? arguments[headerIndex] : undefined;

	  this.statusCode = statusCode;

	  // the following block is from node.js core
	  if (Array.isArray(headers)) {
	    // handle array case
	    for (var i = 0, len = headers.length; i < len; ++i) {
	      this.setHeader(headers[i][0], headers[i][1]);
	    }
	  } else if (headers) {
	    // handle object case
	    var keys = Object.keys(headers);
	    for (var i = 0; i < keys.length; i++) {
	      var k = keys[i];
	      if (k) this.setHeader(k, headers[k]);
	    }
	  }

	  // copy leading arguments
	  var args = new Array(Math.min(length, headerIndex));
	  for (var i = 0; i < args.length; i++) {
	    args[i] = arguments[i];
	  }

	  return args;
	}

/***/ },
/* 363 */
/***/ function(module, exports) {

	/*!
	 * Connect - session - Session
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Expose Session.
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	module.exports = Session;

	/**
	 * Create a new `Session` with the given request and `data`.
	 *
	 * @param {IncomingRequest} req
	 * @param {Object} data
	 * @api private
	 */

	function Session(req, data) {
	  Object.defineProperty(this, 'req', { value: req });
	  Object.defineProperty(this, 'id', { value: req.sessionID });

	  if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null) {
	    // merge data into this, ignoring prototype properties
	    for (var prop in data) {
	      if (!(prop in this)) {
	        this[prop] = data[prop];
	      }
	    }
	  }
	}

	/**
	 * Update reset `.cookie.maxAge` to prevent
	 * the cookie from expiring when the
	 * session is still active.
	 *
	 * @return {Session} for chaining
	 * @api public
	 */

	defineMethod(Session.prototype, 'touch', function touch() {
	  return this.resetMaxAge();
	});

	/**
	 * Reset `.maxAge` to `.originalMaxAge`.
	 *
	 * @return {Session} for chaining
	 * @api public
	 */

	defineMethod(Session.prototype, 'resetMaxAge', function resetMaxAge() {
	  this.cookie.maxAge = this.cookie.originalMaxAge;
	  return this;
	});

	/**
	 * Save the session data with optional callback `fn(err)`.
	 *
	 * @param {Function} fn
	 * @return {Session} for chaining
	 * @api public
	 */

	defineMethod(Session.prototype, 'save', function save(fn) {
	  this.req.sessionStore.set(this.id, this, fn || function () {});
	  return this;
	});

	/**
	 * Re-loads the session data _without_ altering
	 * the maxAge properties. Invokes the callback `fn(err)`,
	 * after which time if no exception has occurred the
	 * `req.session` property will be a new `Session` object,
	 * although representing the same session.
	 *
	 * @param {Function} fn
	 * @return {Session} for chaining
	 * @api public
	 */

	defineMethod(Session.prototype, 'reload', function reload(fn) {
	  var req = this.req,
	      store = this.req.sessionStore;
	  store.get(this.id, function (err, sess) {
	    if (err) return fn(err);
	    if (!sess) return fn(new Error('failed to load session'));
	    store.createSession(req, sess);
	    fn();
	  });
	  return this;
	});

	/**
	 * Destroy `this` session.
	 *
	 * @param {Function} fn
	 * @return {Session} for chaining
	 * @api public
	 */

	defineMethod(Session.prototype, 'destroy', function destroy(fn) {
	  delete this.req.session;
	  this.req.sessionStore.destroy(this.id, fn);
	  return this;
	});

	/**
	 * Regenerate this request's session.
	 *
	 * @param {Function} fn
	 * @return {Session} for chaining
	 * @api public
	 */

	defineMethod(Session.prototype, 'regenerate', function regenerate(fn) {
	  this.req.sessionStore.regenerate(this.req, fn);
	  return this;
	});

	/**
	 * Helper function for creating a method on a prototype.
	 *
	 * @param {Object} obj
	 * @param {String} name
	 * @param {Function} fn
	 * @private
	 */
	function defineMethod(obj, name, fn) {
	  Object.defineProperty(obj, name, {
	    configurable: true,
	    enumerable: false,
	    value: fn,
	    writable: true
	  });
	};

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process) {/*!
	 * express-session
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var Store = __webpack_require__(365);
	var util = __webpack_require__(263);

	/**
	 * Shim setImmediate for node.js < 0.10
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
	  process.nextTick(fn.bind.apply(fn, arguments));
	};

	/**
	 * Module exports.
	 */

	module.exports = MemoryStore;

	/**
	 * A session store in memory.
	 * @public
	 */

	function MemoryStore() {
	  Store.call(this);
	  this.sessions = Object.create(null);
	}

	/**
	 * Inherit from Store.
	 */

	util.inherits(MemoryStore, Store);

	/**
	 * Get all active sessions.
	 *
	 * @param {function} callback
	 * @public
	 */

	MemoryStore.prototype.all = function all(callback) {
	  var sessionIds = Object.keys(this.sessions);
	  var sessions = Object.create(null);

	  for (var i = 0; i < sessionIds.length; i++) {
	    var sessionId = sessionIds[i];
	    var session = getSession.call(this, sessionId);

	    if (session) {
	      sessions[sessionId] = session;
	    }
	  }

	  callback && defer(callback, null, sessions);
	};

	/**
	 * Clear all sessions.
	 *
	 * @param {function} callback
	 * @public
	 */

	MemoryStore.prototype.clear = function clear(callback) {
	  this.sessions = Object.create(null);
	  callback && defer(callback);
	};

	/**
	 * Destroy the session associated with the given session ID.
	 *
	 * @param {string} sessionId
	 * @public
	 */

	MemoryStore.prototype.destroy = function destroy(sessionId, callback) {
	  delete this.sessions[sessionId];
	  callback && defer(callback);
	};

	/**
	 * Fetch session by the given session ID.
	 *
	 * @param {string} sessionId
	 * @param {function} callback
	 * @public
	 */

	MemoryStore.prototype.get = function get(sessionId, callback) {
	  defer(callback, null, getSession.call(this, sessionId));
	};

	/**
	 * Commit the given session associated with the given sessionId to the store.
	 *
	 * @param {string} sessionId
	 * @param {object} session
	 * @param {function} callback
	 * @public
	 */

	MemoryStore.prototype.set = function set(sessionId, session, callback) {
	  this.sessions[sessionId] = JSON.stringify(session);
	  callback && defer(callback);
	};

	/**
	 * Get number of active sessions.
	 *
	 * @param {function} callback
	 * @public
	 */

	MemoryStore.prototype.length = function length(callback) {
	  this.all(function (err, sessions) {
	    if (err) return callback(err);
	    callback(null, Object.keys(sessions).length);
	  });
	};

	/**
	 * Touch the given session object associated with the given session ID.
	 *
	 * @param {string} sessionId
	 * @param {object} session
	 * @param {function} callback
	 * @public
	 */

	MemoryStore.prototype.touch = function touch(sessionId, session, callback) {
	  var currentSession = getSession.call(this, sessionId);

	  if (currentSession) {
	    // update expiration
	    currentSession.cookie = session.cookie;
	    this.sessions[sessionId] = JSON.stringify(currentSession);
	  }

	  callback && defer(callback);
	};

	/**
	 * Get session from the store.
	 * @private
	 */

	function getSession(sessionId) {
	  var sess = this.sessions[sessionId];

	  if (!sess) {
	    return;
	  }

	  // parse
	  sess = JSON.parse(sess);

	  var expires = typeof sess.cookie.expires === 'string' ? new Date(sess.cookie.expires) : sess.cookie.expires;

	  // destroy expired session
	  if (expires && expires <= Date.now()) {
	    delete this.sessions[sessionId];
	    return;
	  }

	  return sess;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate, __webpack_require__(4)))

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Connect - session - Store
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var Cookie = __webpack_require__(366);
	var EventEmitter = __webpack_require__(188).EventEmitter;
	var Session = __webpack_require__(363);
	var util = __webpack_require__(263);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Store;

	/**
	 * Abstract base class for session stores.
	 * @public
	 */

	function Store() {
	  EventEmitter.call(this);
	}

	/**
	 * Inherit from EventEmitter.
	 */

	util.inherits(Store, EventEmitter);

	/**
	 * Re-generate the given requests's session.
	 *
	 * @param {IncomingRequest} req
	 * @return {Function} fn
	 * @api public
	 */

	Store.prototype.regenerate = function (req, fn) {
	  var self = this;
	  this.destroy(req.sessionID, function (err) {
	    self.generate(req);
	    fn(err);
	  });
	};

	/**
	 * Load a `Session` instance via the given `sid`
	 * and invoke the callback `fn(err, sess)`.
	 *
	 * @param {String} sid
	 * @param {Function} fn
	 * @api public
	 */

	Store.prototype.load = function (sid, fn) {
	  var self = this;
	  this.get(sid, function (err, sess) {
	    if (err) return fn(err);
	    if (!sess) return fn();
	    var req = { sessionID: sid, sessionStore: self };
	    fn(null, self.createSession(req, sess));
	  });
	};

	/**
	 * Create session from JSON `sess` data.
	 *
	 * @param {IncomingRequest} req
	 * @param {Object} sess
	 * @return {Session}
	 * @api private
	 */

	Store.prototype.createSession = function (req, sess) {
	  var expires = sess.cookie.expires,
	      orig = sess.cookie.originalMaxAge;
	  sess.cookie = new Cookie(sess.cookie);
	  if ('string' == typeof expires) sess.cookie.expires = new Date(expires);
	  sess.cookie.originalMaxAge = orig;
	  req.session = new Session(req, sess);
	  return req.session;
	};

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Connect - session - Cookie
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var merge = __webpack_require__(213),
	    cookie = __webpack_require__(299);

	/**
	 * Initialize a new `Cookie` with the given `options`.
	 *
	 * @param {IncomingMessage} req
	 * @param {Object} options
	 * @api private
	 */

	var Cookie = module.exports = function Cookie(options) {
	  this.path = '/';
	  this.maxAge = null;
	  this.httpOnly = true;
	  if (options) merge(this, options);
	  this.originalMaxAge = undefined == this.originalMaxAge ? this.maxAge : this.originalMaxAge;
	};

	/*!
	 * Prototype.
	 */

	Cookie.prototype = {

	  /**
	   * Set expires `date`.
	   *
	   * @param {Date} date
	   * @api public
	   */

	  set expires(date) {
	    this._expires = date;
	    this.originalMaxAge = this.maxAge;
	  },

	  /**
	   * Get expires `date`.
	   *
	   * @return {Date}
	   * @api public
	   */

	  get expires() {
	    return this._expires;
	  },

	  /**
	   * Set expires via max-age in `ms`.
	   *
	   * @param {Number} ms
	   * @api public
	   */

	  set maxAge(ms) {
	    this.expires = 'number' == typeof ms ? new Date(Date.now() + ms) : ms;
	  },

	  /**
	   * Get expires max-age in `ms`.
	   *
	   * @return {Number}
	   * @api public
	   */

	  get maxAge() {
	    return this.expires instanceof Date ? this.expires.valueOf() - Date.now() : this.expires;
	  },

	  /**
	   * Return cookie data object.
	   *
	   * @return {Object}
	   * @api private
	   */

	  get data() {
	    return {
	      originalMaxAge: this.originalMaxAge,
	      expires: this._expires,
	      secure: this.secure,
	      httpOnly: this.httpOnly,
	      domain: this.domain,
	      path: this.path
	    };
	  },

	  /**
	   * Return a serialized cookie string.
	   *
	   * @return {String}
	   * @api public
	   */

	  serialize: function serialize(name, val) {
	    return cookie.serialize(name, val, this.data);
	  },

	  /**
	   * Return JSON representation of this cookie.
	   *
	   * @return {Object}
	   * @api private
	   */

	  toJSON: function toJSON() {
	    return this.data;
	  }
	};

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2014, Yahoo Inc. All rights reserved.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */

	'use strict';

	var ExpressHandlebars = __webpack_require__(368);

	exports = module.exports = exphbs;
	exports.create = create;
	exports.ExpressHandlebars = ExpressHandlebars;

	// -----------------------------------------------------------------------------

	function exphbs(config) {
	    return create(config).engine;
	}

	function create(config) {
	    return new ExpressHandlebars(config);
	}

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*
	 * Copyright (c) 2015, Yahoo Inc. All rights reserved.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Promise = global.Promise || __webpack_require__(369);

	var glob = __webpack_require__(379);
	var Handlebars = __webpack_require__(390);
	var fs = __webpack_require__(420);
	var path = __webpack_require__(230);

	var utils = __webpack_require__(425);

	module.exports = ExpressHandlebars;

	// -----------------------------------------------------------------------------

	function ExpressHandlebars(config) {
	    // Config properties with defaults.
	    utils.assign(this, {
	        handlebars: Handlebars,
	        extname: '.handlebars',
	        layoutsDir: 'views/layouts/',
	        partialsDir: 'views/partials/',
	        defaultLayout: undefined,
	        helpers: undefined,
	        compilerOptions: undefined
	    }, config);

	    // Express view engine integration point.
	    this.engine = this.renderView.bind(this);

	    // Normalize `extname`.
	    if (this.extname.charAt(0) !== '.') {
	        this.extname = '.' + this.extname;
	    }

	    // Internal caches of compiled and precompiled templates.
	    this.compiled = Object.create(null);
	    this.precompiled = Object.create(null);

	    // Private internal file system cache.
	    this._fsCache = Object.create(null);
	}

	ExpressHandlebars.prototype.getPartials = function (options) {
	    var partialsDirs = Array.isArray(this.partialsDir) ? this.partialsDir : [this.partialsDir];

	    partialsDirs = partialsDirs.map(function (dir) {
	        var dirPath;
	        var dirTemplates;
	        var dirNamespace;

	        // Support `partialsDir` collection with object entries that contain a
	        // templates promise and a namespace.
	        if (typeof dir === 'string') {
	            dirPath = dir;
	        } else if ((typeof dir === 'undefined' ? 'undefined' : _typeof(dir)) === 'object') {
	            dirTemplates = dir.templates;
	            dirNamespace = dir.namespace;
	            dirPath = dir.dir;
	        }

	        // We must have some path to templates, or templates themselves.
	        if (!(dirPath || dirTemplates)) {
	            throw new Error('A partials dir must be a string or config object');
	        }

	        // Make sure we're have a promise for the templates.
	        var templatesPromise = dirTemplates ? Promise.resolve(dirTemplates) : this.getTemplates(dirPath, options);

	        return templatesPromise.then(function (templates) {
	            return {
	                templates: templates,
	                namespace: dirNamespace
	            };
	        });
	    }, this);

	    return Promise.all(partialsDirs).then(function (dirs) {
	        var getTemplateName = this._getTemplateName.bind(this);

	        return dirs.reduce(function (partials, dir) {
	            var templates = dir.templates;
	            var namespace = dir.namespace;
	            var filePaths = Object.keys(templates);

	            filePaths.forEach(function (filePath) {
	                var partialName = getTemplateName(filePath, namespace);
	                partials[partialName] = templates[filePath];
	            });

	            return partials;
	        }, {});
	    }.bind(this));
	};

	ExpressHandlebars.prototype.getTemplate = function (filePath, options) {
	    filePath = path.resolve(filePath);
	    options || (options = {});

	    var precompiled = options.precompiled;
	    var cache = precompiled ? this.precompiled : this.compiled;
	    var template = options.cache && cache[filePath];

	    if (template) {
	        return template;
	    }

	    // Optimistically cache template promise to reduce file system I/O, but
	    // remove from cache if there was a problem.
	    template = cache[filePath] = this._getFile(filePath, { cache: options.cache }).then(function (file) {
	        if (precompiled) {
	            return this._precompileTemplate(file, this.compilerOptions);
	        }

	        return this._compileTemplate(file, this.compilerOptions);
	    }.bind(this));

	    return template.catch(function (err) {
	        delete cache[filePath];
	        throw err;
	    });
	};

	ExpressHandlebars.prototype.getTemplates = function (dirPath, options) {
	    options || (options = {});
	    var cache = options.cache;

	    return this._getDir(dirPath, { cache: cache }).then(function (filePaths) {
	        var templates = filePaths.map(function (filePath) {
	            return this.getTemplate(path.join(dirPath, filePath), options);
	        }, this);

	        return Promise.all(templates).then(function (templates) {
	            return filePaths.reduce(function (hash, filePath, i) {
	                hash[filePath] = templates[i];
	                return hash;
	            }, {});
	        });
	    }.bind(this));
	};

	ExpressHandlebars.prototype.render = function (filePath, context, options) {
	    options || (options = {});

	    return Promise.all([this.getTemplate(filePath, { cache: options.cache }), options.partials || this.getPartials({ cache: options.cache })]).then(function (templates) {
	        var template = templates[0];
	        var partials = templates[1];
	        var helpers = options.helpers || this.helpers;

	        // Add ExpressHandlebars metadata to the data channel so that it's
	        // accessible within the templates and helpers, namespaced under:
	        // `@exphbs.*`
	        var data = utils.assign({}, options.data, {
	            exphbs: utils.assign({}, options, {
	                filePath: filePath,
	                helpers: helpers,
	                partials: partials
	            })
	        });

	        return this._renderTemplate(template, context, {
	            data: data,
	            helpers: helpers,
	            partials: partials
	        });
	    }.bind(this));
	};

	ExpressHandlebars.prototype.renderView = function (viewPath, options, callback) {
	    options || (options = {});

	    var context = options;

	    // Express provides `settings.views` which is the path to the views dir that
	    // the developer set on the Express app. When this value exists, it's used
	    // to compute the view's name.
	    var view;
	    var viewsPath = options.settings && options.settings.views;
	    if (viewsPath) {
	        view = this._getTemplateName(path.relative(viewsPath, viewPath));
	    }

	    // Merge render-level and instance-level helpers together.
	    var helpers = utils.assign({}, this.helpers, options.helpers);

	    // Merge render-level and instance-level partials together.
	    var partials = Promise.all([this.getPartials({ cache: options.cache }), Promise.resolve(options.partials)]).then(function (partials) {
	        return utils.assign.apply(null, [{}].concat(partials));
	    });

	    // Pluck-out ExpressHandlebars-specific options and Handlebars-specific
	    // rendering options.
	    options = {
	        cache: options.cache,
	        view: view,
	        layout: 'layout' in options ? options.layout : this.defaultLayout,

	        data: options.data,
	        helpers: helpers,
	        partials: partials
	    };

	    this.render(viewPath, context, options).then(function (body) {
	        var layoutPath = this._resolveLayoutPath(options.layout);

	        if (layoutPath) {
	            return this.render(layoutPath, utils.assign({}, context, { body: body }), utils.assign({}, options, { layout: undefined }));
	        }

	        return body;
	    }.bind(this)).then(utils.passValue(callback)).catch(utils.passError(callback));
	};

	// -- Protected Hooks ----------------------------------------------------------

	ExpressHandlebars.prototype._compileTemplate = function (template, options) {
	    return this.handlebars.compile(template, options);
	};

	ExpressHandlebars.prototype._precompileTemplate = function (template, options) {
	    return this.handlebars.precompile(template, options);
	};

	ExpressHandlebars.prototype._renderTemplate = function (template, context, options) {
	    return template(context, options);
	};

	// -- Private ------------------------------------------------------------------

	ExpressHandlebars.prototype._getDir = function (dirPath, options) {
	    dirPath = path.resolve(dirPath);
	    options || (options = {});

	    var cache = this._fsCache;
	    var dir = options.cache && cache[dirPath];

	    if (dir) {
	        return dir.then(function (dir) {
	            return dir.concat();
	        });
	    }

	    var pattern = '**/*' + this.extname;

	    // Optimistically cache dir promise to reduce file system I/O, but remove
	    // from cache if there was a problem.
	    dir = cache[dirPath] = new Promise(function (resolve, reject) {
	        glob(pattern, {
	            cwd: dirPath,
	            follow: true
	        }, function (err, dir) {
	            if (err) {
	                reject(err);
	            } else {
	                resolve(dir);
	            }
	        });
	    });

	    return dir.then(function (dir) {
	        return dir.concat();
	    }).catch(function (err) {
	        delete cache[dirPath];
	        throw err;
	    });
	};

	ExpressHandlebars.prototype._getFile = function (filePath, options) {
	    filePath = path.resolve(filePath);
	    options || (options = {});

	    var cache = this._fsCache;
	    var file = options.cache && cache[filePath];

	    if (file) {
	        return file;
	    }

	    // Optimistically cache file promise to reduce file system I/O, but remove
	    // from cache if there was a problem.
	    file = cache[filePath] = new Promise(function (resolve, reject) {
	        fs.readFile(filePath, 'utf8', function (err, file) {
	            if (err) {
	                reject(err);
	            } else {
	                resolve(file);
	            }
	        });
	    });

	    return file.catch(function (err) {
	        delete cache[filePath];
	        throw err;
	    });
	};

	ExpressHandlebars.prototype._getTemplateName = function (filePath, namespace) {
	    var extRegex = new RegExp(this.extname + '$');
	    var name = filePath.replace(extRegex, '');

	    if (namespace) {
	        name = namespace + '/' + name;
	    }

	    return name;
	};

	ExpressHandlebars.prototype._resolveLayoutPath = function (layoutPath) {
	    if (!layoutPath) {
	        return null;
	    }

	    if (!path.extname(layoutPath)) {
	        layoutPath += this.extname;
	    }

	    return path.resolve(this.layoutsDir, layoutPath);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(370);

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(371);
	__webpack_require__(373);
	__webpack_require__(374);
	__webpack_require__(375);
	__webpack_require__(376);
	__webpack_require__(378);

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var asap = __webpack_require__(372);

	function noop() {}

	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable

	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.


	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}

	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}

	module.exports = Promise;

	function Promise(fn) {
	  if (_typeof(this) !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._45 = 0;
	  this._81 = 0;
	  this._65 = null;
	  this._54 = null;
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._10 = null;
	Promise._97 = null;
	Promise._61 = noop;

	Promise.prototype.then = function (onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};

	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._81 === 3) {
	    self = self._65;
	  }
	  if (Promise._10) {
	    Promise._10(self);
	  }
	  if (self._81 === 0) {
	    if (self._45 === 0) {
	      self._45 = 1;
	      self._54 = deferred;
	      return;
	    }
	    if (self._45 === 1) {
	      self._45 = 2;
	      self._54 = [self._54, deferred];
	      return;
	    }
	    self._54.push(deferred);
	    return;
	  }
	  handleResolved(self, deferred);
	}

	function handleResolved(self, deferred) {
	  asap(function () {
	    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._81 === 1) {
	        resolve(deferred.promise, self._65);
	      } else {
	        reject(deferred.promise, self._65);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._65);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(self, new TypeError('A promise cannot be resolved with itself.'));
	  }
	  if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (then === self.then && newValue instanceof Promise) {
	      self._81 = 3;
	      self._65 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._81 = 1;
	  self._65 = newValue;
	  finale(self);
	}

	function reject(self, newValue) {
	  self._81 = 2;
	  self._65 = newValue;
	  if (Promise._97) {
	    Promise._97(self, newValue);
	  }
	  finale(self);
	}
	function finale(self) {
	  if (self._45 === 1) {
	    handle(self, self._54);
	    self._54 = null;
	  }
	  if (self._45 === 2) {
	    for (var i = 0; i < self._54.length; i++) {
	      handle(self, self._54[i]);
	    }
	    self._54 = null;
	  }
	}

	function Handler(onFulfilled, onRejected, promise) {
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  });
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}

/***/ },
/* 372 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.

	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}

	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}

	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);

	    // MessageChannels are desirable because they give direct access to the HTML
	    // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	    // 11-12, and in web workers in many engines.
	    // Although message channels yield to any queued rendering and IO tasks, they
	    // would be better than imposing the 4ms delay of timers.
	    // However, they do not work reliably in Internet Explorer or Safari.

	    // Internet Explorer 10 is the only browser that has setImmediate but does
	    // not have MutationObservers.
	    // Although setImmediate yields to the browser's renderer, it would be
	    // preferrable to falling back to setTimeout since it does not have
	    // the minimum 4ms penalty.
	    // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	    // Desktop to a lesser extent) that renders both setImmediate and
	    // MessageChannel useless for the purposes of ASAP.
	    // https://github.com/kriskowal/q/issues/396

	    // Timers are implemented universally.
	    // We fall back to timers in workers in most engines, and in foreground
	    // contexts in the following browsers.
	    // However, note that even this simple case requires nuances to operate in a
	    // broad spectrum of browsers.
	    //
	    // - Firefox 3-13
	    // - Internet Explorer 6-9
	    // - iPad Safari 4.3
	    // - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}

	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.jss
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;

	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, { characterData: true });
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}

	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html

	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.

	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }

	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.

	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }

	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.

	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.

	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);

	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}

	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(371);

	module.exports = Promise;
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this;
	  self.then(null, function (err) {
	    setTimeout(function () {
	      throw err;
	    }, 0);
	  });
	};

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(371);

	module.exports = Promise;
	Promise.prototype['finally'] = function (f) {
	  return this.then(function (value) {
	    return Promise.resolve(f()).then(function () {
	      return value;
	    });
	  }, function (err) {
	    return Promise.resolve(f()).then(function () {
	      throw err;
	    });
	  });
	};

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains the ES6 extensions to the core Promises/A+ API

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Promise = __webpack_require__(371);

	module.exports = Promise;

	/* Static Functions */

	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');

	function valuePromise(value) {
	  var p = new Promise(Promise._61);
	  p._81 = 1;
	  p._65 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;

	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;

	  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};

	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);

	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._81 === 3) {
	            val = val._65;
	          }
	          if (val._81 === 1) return res(i, val._65);
	          if (val._81 === 2) reject(val._65);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};

	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};

	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function (value) {
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};

	/* Prototype Methods */

	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// This file contains then/promise specific extensions that are only useful
	// for node.js interop

	var Promise = __webpack_require__(371);
	var asap = __webpack_require__(377);

	module.exports = Promise;

	/* Static Functions */

	Promise.denodeify = function (fn, argumentCount) {
	  if (typeof argumentCount === 'number' && argumentCount !== Infinity) {
	    return denodeifyWithCount(fn, argumentCount);
	  } else {
	    return denodeifyWithoutCount(fn);
	  }
	};

	var callbackFn = 'function (err, res) {' + 'if (err) { rj(err); } else { rs(res); }' + '}';
	function denodeifyWithCount(fn, argumentCount) {
	  var args = [];
	  for (var i = 0; i < argumentCount; i++) {
	    args.push('a' + i);
	  }
	  var body = ['return function (' + args.join(',') + ') {', 'var self = this;', 'return new Promise(function (rs, rj) {', 'var res = fn.call(', ['self'].concat(args).concat([callbackFn]).join(','), ');', 'if (res &&', '(typeof res === "object" || typeof res === "function") &&', 'typeof res.then === "function"', ') {rs(res);}', '});', '};'].join('');
	  return Function(['Promise', 'fn'], body)(Promise, fn);
	}
	function denodeifyWithoutCount(fn) {
	  var fnLength = Math.max(fn.length - 1, 3);
	  var args = [];
	  for (var i = 0; i < fnLength; i++) {
	    args.push('a' + i);
	  }
	  var body = ['return function (' + args.join(',') + ') {', 'var self = this;', 'var args;', 'var argLength = arguments.length;', 'if (arguments.length > ' + fnLength + ') {', 'args = new Array(arguments.length + 1);', 'for (var i = 0; i < arguments.length; i++) {', 'args[i] = arguments[i];', '}', '}', 'return new Promise(function (rs, rj) {', 'var cb = ' + callbackFn + ';', 'var res;', 'switch (argLength) {', args.concat(['extra']).map(function (_, index) {
	    return 'case ' + index + ':' + 'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' + 'break;';
	  }).join(''), 'default:', 'args[argLength] = cb;', 'res = fn.apply(self, args);', '}', 'if (res &&', '(typeof res === "object" || typeof res === "function") &&', 'typeof res.then === "function"', ') {rs(res);}', '});', '};'].join('');

	  return Function(['Promise', 'fn'], body)(Promise, fn);
	}

	Promise.nodeify = function (fn) {
	  return function () {
	    var args = Array.prototype.slice.call(arguments);
	    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
	    var ctx = this;
	    try {
	      return fn.apply(this, arguments).nodeify(callback, ctx);
	    } catch (ex) {
	      if (callback === null || typeof callback == 'undefined') {
	        return new Promise(function (resolve, reject) {
	          reject(ex);
	        });
	      } else {
	        asap(function () {
	          callback.call(ctx, ex);
	        });
	      }
	    }
	  };
	};

	Promise.prototype.nodeify = function (callback, ctx) {
	  if (typeof callback != 'function') return this;

	  this.then(function (value) {
	    asap(function () {
	      callback.call(ctx, null, value);
	    });
	  }, function (err) {
	    asap(function () {
	      callback.call(ctx, err);
	    });
	  });
	};

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// rawAsap provides everything we need except exception management.

	var rawAsap = __webpack_require__(372);
	// RawTasks are recycled to reduce GC churn.
	var freeTasks = [];
	// We queue errors to ensure they are thrown in right order (FIFO).
	// Array-as-queue is good enough here, since we are just dealing with exceptions.
	var pendingErrors = [];
	var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

	function throwFirstError() {
	    if (pendingErrors.length) {
	        throw pendingErrors.shift();
	    }
	}

	/**
	 * Calls a task as soon as possible after returning, in its own event, with priority
	 * over other events like animation, reflow, and repaint. An error thrown from an
	 * event will not interrupt, nor even substantially slow down the processing of
	 * other events, but will be rather postponed to a lower priority event.
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	module.exports = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawAsap(rawTask);
	}

	// We wrap tasks with recyclable task objects.  A task object implements
	// `call`, just like a function.
	function RawTask() {
	    this.task = null;
	}

	// The sole purpose of wrapping the task is to catch the exception and recycle
	// the task object after its single use.
	RawTask.prototype.call = function () {
	    try {
	        this.task.call();
	    } catch (error) {
	        if (asap.onerror) {
	            // This hook exists purely for testing purposes.
	            // Its name will be periodically randomized to break any code that
	            // depends on its existence.
	            asap.onerror(error);
	        } else {
	            // In a web browser, exceptions are not fatal. However, to avoid
	            // slowing down the queue of pending tasks, we rethrow the error in a
	            // lower priority turn.
	            pendingErrors.push(error);
	            requestErrorThrow();
	        }
	    } finally {
	        this.task = null;
	        freeTasks[freeTasks.length] = this;
	    }
	};

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(371);

	module.exports = Promise;
	Promise.enableSynchronous = function () {
	  Promise.prototype.isPending = function () {
	    return this.getState() == 0;
	  };

	  Promise.prototype.isFulfilled = function () {
	    return this.getState() == 1;
	  };

	  Promise.prototype.isRejected = function () {
	    return this.getState() == 2;
	  };

	  Promise.prototype.getValue = function () {
	    if (this._81 === 3) {
	      return this._65.getValue();
	    }

	    if (!this.isFulfilled()) {
	      throw new Error('Cannot get a value of an unfulfilled promise.');
	    }

	    return this._65;
	  };

	  Promise.prototype.getReason = function () {
	    if (this._81 === 3) {
	      return this._65.getReason();
	    }

	    if (!this.isRejected()) {
	      throw new Error('Cannot get a rejection reason of a non-rejected promise.');
	    }

	    return this._65;
	  };

	  Promise.prototype.getState = function () {
	    if (this._81 === 3) {
	      return this._65.getState();
	    }
	    if (this._81 === -1 || this._81 === -2) {
	      return 0;
	    }

	    return this._81;
	  };
	};

	Promise.disableSynchronous = function () {
	  Promise.prototype.isPending = undefined;
	  Promise.prototype.isFulfilled = undefined;
	  Promise.prototype.isRejected = undefined;
	  Promise.prototype.getValue = undefined;
	  Promise.prototype.getReason = undefined;
	  Promise.prototype.getState = undefined;
	};

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern, false)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern, inGlobStar)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	//
	// If inGlobStar and PREFIX is symlink and points to dir
	//   set ENTRIES = []
	// else readdir(PREFIX) as ENTRIES
	//   If fail, END
	//
	// with ENTRIES
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       // Mark that this entry is a globstar match
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.

	module.exports = glob;

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var minimatch = __webpack_require__(380);
	var Minimatch = minimatch.Minimatch;
	var inherits = __webpack_require__(237);
	var EE = __webpack_require__(188).EventEmitter;
	var path = __webpack_require__(230);
	var assert = __webpack_require__(342);
	var isAbsolute = __webpack_require__(384);
	var globSync = __webpack_require__(385);
	var common = __webpack_require__(386);
	var alphasort = common.alphasort;
	var alphasorti = common.alphasorti;
	var setopts = common.setopts;
	var ownProp = common.ownProp;
	var inflight = __webpack_require__(387);
	var util = __webpack_require__(263);
	var childrenIgnored = common.childrenIgnored;
	var isIgnored = common.isIgnored;

	var once = __webpack_require__(389);

	function glob(pattern, options, cb) {
	  if (typeof options === 'function') cb = options, options = {};
	  if (!options) options = {};

	  if (options.sync) {
	    if (cb) throw new TypeError('callback provided to sync glob');
	    return globSync(pattern, options);
	  }

	  return new Glob(pattern, options, cb);
	}

	glob.sync = globSync;
	var GlobSync = glob.GlobSync = globSync.GlobSync;

	// old api surface
	glob.glob = glob;

	function extend(origin, add) {
	  if (add === null || (typeof add === 'undefined' ? 'undefined' : _typeof(add)) !== 'object') {
	    return origin;
	  }

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}

	glob.hasMagic = function (pattern, options_) {
	  var options = extend({}, options_);
	  options.noprocess = true;

	  var g = new Glob(pattern, options);
	  var set = g.minimatch.set;
	  if (set.length > 1) return true;

	  for (var j = 0; j < set[0].length; j++) {
	    if (typeof set[0][j] !== 'string') return true;
	  }

	  return false;
	};

	glob.Glob = Glob;
	inherits(Glob, EE);
	function Glob(pattern, options, cb) {
	  if (typeof options === 'function') {
	    cb = options;
	    options = null;
	  }

	  if (options && options.sync) {
	    if (cb) throw new TypeError('callback provided to sync glob');
	    return new GlobSync(pattern, options);
	  }

	  if (!(this instanceof Glob)) return new Glob(pattern, options, cb);

	  setopts(this, pattern, options);
	  this._didRealPath = false;

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length;

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n);

	  if (typeof cb === 'function') {
	    cb = once(cb);
	    this.on('error', cb);
	    this.on('end', function (matches) {
	      cb(null, matches);
	    });
	  }

	  var self = this;
	  var n = this.minimatch.set.length;
	  this._processing = 0;
	  this.matches = new Array(n);

	  this._emitQueue = [];
	  this._processQueue = [];
	  this.paused = false;

	  if (this.noprocess) return this;

	  if (n === 0) return done();

	  for (var i = 0; i < n; i++) {
	    this._process(this.minimatch.set[i], i, false, done);
	  }

	  function done() {
	    --self._processing;
	    if (self._processing <= 0) self._finish();
	  }
	}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob);
	  if (this.aborted) return;

	  if (this.realpath && !this._didRealpath) return this._realpath();

	  common.finish(this);
	  this.emit('end', this.found);
	};

	Glob.prototype._realpath = function () {
	  if (this._didRealpath) return;

	  this._didRealpath = true;

	  var n = this.matches.length;
	  if (n === 0) return this._finish();

	  var self = this;
	  for (var i = 0; i < this.matches.length; i++) {
	    this._realpathSet(i, next);
	  }function next() {
	    if (--n === 0) self._finish();
	  }
	};

	Glob.prototype._realpathSet = function (index, cb) {
	  var matchset = this.matches[index];
	  if (!matchset) return cb();

	  var found = Object.keys(matchset);
	  var self = this;
	  var n = found.length;

	  if (n === 0) return cb();

	  var set = this.matches[index] = Object.create(null);
	  found.forEach(function (p, i) {
	    // If there's a problem with the stat, then it means that
	    // one or more of the links in the realpath couldn't be
	    // resolved.  just return the abs value in that case.
	    p = self._makeAbs(p);
	    fs.realpath(p, self.realpathCache, function (er, real) {
	      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here

	      if (--n === 0) {
	        self.matches[index] = set;
	        cb();
	      }
	    });
	  });
	};

	Glob.prototype._mark = function (p) {
	  return common.mark(this, p);
	};

	Glob.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f);
	};

	Glob.prototype.abort = function () {
	  this.aborted = true;
	  this.emit('abort');
	};

	Glob.prototype.pause = function () {
	  if (!this.paused) {
	    this.paused = true;
	    this.emit('pause');
	  }
	};

	Glob.prototype.resume = function () {
	  if (this.paused) {
	    this.emit('resume');
	    this.paused = false;
	    if (this._emitQueue.length) {
	      var eq = this._emitQueue.slice(0);
	      this._emitQueue.length = 0;
	      for (var i = 0; i < eq.length; i++) {
	        var e = eq[i];
	        this._emitMatch(e[0], e[1]);
	      }
	    }
	    if (this._processQueue.length) {
	      var pq = this._processQueue.slice(0);
	      this._processQueue.length = 0;
	      for (var i = 0; i < pq.length; i++) {
	        var p = pq[i];
	        this._processing--;
	        this._process(p[0], p[1], p[2], p[3]);
	      }
	    }
	  }
	};

	Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
	  assert(this instanceof Glob);
	  assert(typeof cb === 'function');

	  if (this.aborted) return;

	  this._processing++;
	  if (this.paused) {
	    this._processQueue.push([pattern, index, inGlobStar, cb]);
	    return;
	  }

	  //console.error('PROCESS %d', this._processing, pattern)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0;
	  while (typeof pattern[n] === 'string') {
	    n++;
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix;
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index, cb);
	      return;

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null;
	      break;

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/');
	      break;
	  }

	  var remain = pattern.slice(n);

	  // get the list of entries.
	  var read;
	  if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;
	    read = prefix;
	  } else read = prefix;

	  var abs = this._makeAbs(read);

	  //if ignored, skip _processing
	  if (childrenIgnored(this, read)) return cb();

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR;
	  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
	};

	Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this;
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
	  });
	};

	Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries) return cb();

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0];
	  var negate = !!this.minimatch.negate;
	  var rawGlob = pn._glob;
	  var dotOk = this.dot || rawGlob.charAt(0) === '.';

	  var matchedEntries = [];
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i];
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m;
	      if (negate && !prefix) {
	        m = !e.match(pn);
	      } else {
	        m = e.match(pn);
	      }
	      if (m) matchedEntries.push(e);
	    }
	  }

	  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

	  var len = matchedEntries.length;
	  // If there are no matched entries, then nothing matches.
	  if (len === 0) return cb();

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index]) this.matches[index] = Object.create(null);

	    for (var i = 0; i < len; i++) {
	      var e = matchedEntries[i];
	      if (prefix) {
	        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e);
	      }
	      this._emitMatch(index, e);
	    }
	    // This was the last one, and no stats were needed
	    return cb();
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift();
	  for (var i = 0; i < len; i++) {
	    var e = matchedEntries[i];
	    var newPattern;
	    if (prefix) {
	      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
	    }
	    this._process([e].concat(remain), index, inGlobStar, cb);
	  }
	  cb();
	};

	Glob.prototype._emitMatch = function (index, e) {
	  if (this.aborted) return;

	  if (this.matches[index][e]) return;

	  if (isIgnored(this, e)) return;

	  if (this.paused) {
	    this._emitQueue.push([index, e]);
	    return;
	  }

	  var abs = this._makeAbs(e);

	  if (this.nodir) {
	    var c = this.cache[abs];
	    if (c === 'DIR' || Array.isArray(c)) return;
	  }

	  if (this.mark) e = this._mark(e);

	  this.matches[index][e] = true;

	  var st = this.statCache[abs];
	  if (st) this.emit('stat', e, st);

	  this.emit('match', e);
	};

	Glob.prototype._readdirInGlobStar = function (abs, cb) {
	  if (this.aborted) return;

	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow) return this._readdir(abs, false, cb);

	  var lstatkey = 'lstat\0' + abs;
	  var self = this;
	  var lstatcb = inflight(lstatkey, lstatcb_);

	  if (lstatcb) fs.lstat(abs, lstatcb);

	  function lstatcb_(er, lstat) {
	    if (er) return cb();

	    var isSym = lstat.isSymbolicLink();
	    self.symlinks[abs] = isSym;

	    // If it's not a symlink or a dir, then it's definitely a regular file.
	    // don't bother doing a readdir in that case.
	    if (!isSym && !lstat.isDirectory()) {
	      self.cache[abs] = 'FILE';
	      cb();
	    } else self._readdir(abs, false, cb);
	  }
	};

	Glob.prototype._readdir = function (abs, inGlobStar, cb) {
	  if (this.aborted) return;

	  cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
	  if (!cb) return;

	  //console.error('RD %j %j', +inGlobStar, abs)
	  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs];
	    if (!c || c === 'FILE') return cb();

	    if (Array.isArray(c)) return cb(null, c);
	  }

	  var self = this;
	  fs.readdir(abs, readdirCb(this, abs, cb));
	};

	function readdirCb(self, abs, cb) {
	  return function (er, entries) {
	    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);
	  };
	}

	Glob.prototype._readdirEntries = function (abs, entries, cb) {
	  if (this.aborted) return;

	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i++) {
	      var e = entries[i];
	      if (abs === '/') e = abs + e;else e = abs + '/' + e;
	      this.cache[e] = true;
	    }
	  }

	  this.cache[abs] = entries;
	  return cb(null, entries);
	};

	Glob.prototype._readdirError = function (f, er, cb) {
	  if (this.aborted) return;

	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR':
	      // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE';
	      break;

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false;
	      break;

	    default:
	      // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false;
	      if (this.strict) {
	        this.emit('error', er);
	        // If the error is handled, then we abort
	        // if not, we threw out of here
	        this.abort();
	      }
	      if (!this.silent) console.error('glob error', er);
	      break;
	  }

	  return cb();
	};

	Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this;
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
	  });
	};

	Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	  //console.error('pgs2', prefix, remain[0], entries)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries) return cb();

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1);
	  var gspref = prefix ? [prefix] : [];
	  var noGlobStar = gspref.concat(remainWithoutGlobStar);

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false, cb);

	  var isSym = this.symlinks[abs];
	  var len = entries.length;

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar) return cb();

	  for (var i = 0; i < len; i++) {
	    var e = entries[i];
	    if (e.charAt(0) === '.' && !this.dot) continue;

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
	    this._process(instead, index, true, cb);

	    var below = gspref.concat(entries[i], remain);
	    this._process(below, index, true, cb);
	  }

	  cb();
	};

	Glob.prototype._processSimple = function (prefix, index, cb) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var self = this;
	  this._stat(prefix, function (er, exists) {
	    self._processSimple2(prefix, index, er, exists, cb);
	  });
	};
	Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

	  //console.error('ps2', prefix, exists)

	  if (!this.matches[index]) this.matches[index] = Object.create(null);

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists) return cb();

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix);
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix);
	    } else {
	      prefix = path.resolve(this.root, prefix);
	      if (trail) prefix += '/';
	    }
	  }

	  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');

	  // Mark this as a match
	  this._emitMatch(index, prefix);
	  cb();
	};

	// Returns either 'DIR', 'FILE', or false
	Glob.prototype._stat = function (f, cb) {
	  var abs = this._makeAbs(f);
	  var needDir = f.slice(-1) === '/';

	  if (f.length > this.maxLength) return cb();

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs];

	    if (Array.isArray(c)) c = 'DIR';

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR') return cb(null, c);

	    if (needDir && c === 'FILE') return cb();

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists;
	  var stat = this.statCache[abs];
	  if (stat !== undefined) {
	    if (stat === false) return cb(null, stat);else {
	      var type = stat.isDirectory() ? 'DIR' : 'FILE';
	      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);
	    }
	  }

	  var self = this;
	  var statcb = inflight('stat\0' + abs, lstatcb_);
	  if (statcb) fs.lstat(abs, statcb);

	  function lstatcb_(er, lstat) {
	    if (lstat && lstat.isSymbolicLink()) {
	      // If it's a symlink, then treat it as the target, unless
	      // the target does not exist, then treat it as a file.
	      return fs.stat(abs, function (er, stat) {
	        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);
	      });
	    } else {
	      self._stat2(f, abs, er, lstat, cb);
	    }
	  }
	};

	Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
	  if (er) {
	    this.statCache[abs] = false;
	    return cb();
	  }

	  var needDir = f.slice(-1) === '/';
	  this.statCache[abs] = stat;

	  if (abs.slice(-1) === '/' && !stat.isDirectory()) return cb(null, false, stat);

	  var c = stat.isDirectory() ? 'DIR' : 'FILE';
	  this.cache[abs] = this.cache[abs] || c;

	  if (needDir && c !== 'DIR') return cb();

	  return cb(null, c, stat);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = minimatch;
	minimatch.Minimatch = Minimatch;

	var path = { sep: '/' };
	try {
	  path = __webpack_require__(230);
	} catch (er) {}

	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
	var expand = __webpack_require__(381);

	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]';

	// * => any number of characters
	var star = qmark + '*?';

	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!');

	// "abc" -> { a:true, b:true, c:true }
	function charSet(s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true;
	    return set;
	  }, {});
	}

	// normalizes slashes.
	var slashSplit = /\/+/;

	minimatch.filter = filter;
	function filter(pattern, options) {
	  options = options || {};
	  return function (p, i, list) {
	    return minimatch(p, pattern, options);
	  };
	}

	function ext(a, b) {
	  a = a || {};
	  b = b || {};
	  var t = {};
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k];
	  });
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k];
	  });
	  return t;
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch;

	  var orig = minimatch;

	  var m = function minimatch(p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options));
	  };

	  m.Minimatch = function Minimatch(pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options));
	  };

	  return m;
	};

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch;
	  return minimatch.defaults(def).Minimatch;
	};

	function minimatch(p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required');
	  }

	  if (!options) options = {};

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false;
	  }

	  // "" only matches ""
	  if (pattern.trim() === '') return p === '';

	  return new Minimatch(pattern, options).match(p);
	}

	function Minimatch(pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options);
	  }

	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required');
	  }

	  if (!options) options = {};
	  pattern = pattern.trim();

	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/');
	  }

	  this.options = options;
	  this.set = [];
	  this.pattern = pattern;
	  this.regexp = null;
	  this.negate = false;
	  this.comment = false;
	  this.empty = false;

	  // make the set of regexps etc.
	  this.make();
	}

	Minimatch.prototype.debug = function () {};

	Minimatch.prototype.make = make;
	function make() {
	  // don't do it more than once.
	  if (this._made) return;

	  var pattern = this.pattern;
	  var options = this.options;

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true;
	    return;
	  }
	  if (!pattern) {
	    this.empty = true;
	    return;
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate();

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand();

	  if (options.debug) this.debug = console.error;

	  this.debug(this.pattern, set);

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit);
	  });

	  this.debug(this.pattern, set);

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this);
	  }, this);

	  this.debug(this.pattern, set);

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1;
	  });

	  this.debug(this.pattern, set);

	  this.set = set;
	}

	Minimatch.prototype.parseNegate = parseNegate;
	function parseNegate() {
	  var pattern = this.pattern;
	  var negate = false;
	  var options = this.options;
	  var negateOffset = 0;

	  if (options.nonegate) return;

	  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
	    negate = !negate;
	    negateOffset++;
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset);
	  this.negate = negate;
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options);
	};

	Minimatch.prototype.braceExpand = braceExpand;

	function braceExpand(pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options;
	    } else {
	      options = {};
	    }
	  }

	  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

	  if (typeof pattern === 'undefined') {
	    throw new TypeError('undefined pattern');
	  }

	  if (options.nobrace || !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern];
	  }

	  return expand(pattern);
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse;
	var SUBPARSE = {};
	function parse(pattern, isSub) {
	  if (pattern.length > 1024 * 64) {
	    throw new TypeError('pattern is too long');
	  }

	  var options = this.options;

	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR;
	  if (pattern === '') return '';

	  var re = '';
	  var hasMagic = !!options.nocase;
	  var escaping = false;
	  // ? => one single character
	  var patternListStack = [];
	  var negativeLists = [];
	  var plType;
	  var stateChar;
	  var inClass = false;
	  var reClassStart = -1;
	  var classStart = -1;
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
	  var self = this;

	  function clearStateChar() {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star;
	          hasMagic = true;
	          break;
	        case '?':
	          re += qmark;
	          hasMagic = true;
	          break;
	        default:
	          re += '\\' + stateChar;
	          break;
	      }
	      self.debug('clearStateChar %j %j', stateChar, re);
	      stateChar = false;
	    }
	  }

	  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c);

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c;
	      escaping = false;
	      continue;
	    }

	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false;

	      case '\\':
	        clearStateChar();
	        escaping = true;
	        continue;

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class');
	          if (c === '!' && i === classStart + 1) c = '^';
	          re += c;
	          continue;
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar);
	        clearStateChar();
	        stateChar = c;
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar();
	        continue;

	      case '(':
	        if (inClass) {
	          re += '(';
	          continue;
	        }

	        if (!stateChar) {
	          re += '\\(';
	          continue;
	        }

	        plType = stateChar;
	        patternListStack.push({
	          type: plType,
	          start: i - 1,
	          reStart: re.length
	        });
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
	        this.debug('plType %j %j', stateChar, re);
	        stateChar = false;
	        continue;

	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)';
	          continue;
	        }

	        clearStateChar();
	        hasMagic = true;
	        re += ')';
	        var pl = patternListStack.pop();
	        plType = pl.type;
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case '!':
	            negativeLists.push(pl);
	            re += ')[^/]*?)';
	            pl.reEnd = re.length;
	            break;
	          case '?':
	          case '+':
	          case '*':
	            re += plType;
	            break;
	          case '@':
	            break; // the default anyway
	        }
	        continue;

	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|';
	          escaping = false;
	          continue;
	        }

	        clearStateChar();
	        re += '|';
	        continue;

	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar();

	        if (inClass) {
	          re += '\\' + c;
	          continue;
	        }

	        inClass = true;
	        classStart = i;
	        reClassStart = re.length;
	        re += c;
	        continue;

	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c;
	          escaping = false;
	          continue;
	        }

	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i);
	          try {
	            RegExp('[' + cs + ']');
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE);
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
	            hasMagic = hasMagic || sp[1];
	            inClass = false;
	            continue;
	          }
	        }

	        // finish up the class.
	        hasMagic = true;
	        inClass = false;
	        re += c;
	        continue;

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar();

	        if (escaping) {
	          // no need
	          escaping = false;
	        } else if (reSpecials[c] && !(c === '^' && inClass)) {
	          re += '\\';
	        }

	        re += c;

	    } // switch
	  } // for

	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1);
	    sp = this.parse(cs, SUBPARSE);
	    re = re.substr(0, reClassStart) + '\\[' + sp[0];
	    hasMagic = hasMagic || sp[1];
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3);
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\';
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|';
	    });

	    this.debug('tail=%j\n   %s', tail, tail);
	    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;

	    hasMagic = true;
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar();
	  if (escaping) {
	    // trailing \\
	    re += '\\\\';
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false;
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(':
	      addPatternStart = true;
	  }

	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n];

	    var nlBefore = re.slice(0, nl.reStart);
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
	    var nlAfter = re.slice(nl.reEnd);

	    nlLast += nlAfter;

	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1;
	    var cleanAfter = nlAfter;
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
	    }
	    nlAfter = cleanAfter;

	    var dollar = '';
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$';
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
	    re = newRe;
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re;
	  }

	  if (addPatternStart) {
	    re = patternStart + re;
	  }

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic];
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern);
	  }

	  var flags = options.nocase ? 'i' : '';
	  try {
	    var regExp = new RegExp('^' + re + '$', flags);
	  } catch (er) {
	    // If it was an invalid regular expression, then it can't match
	    // anything.  This trick looks for a character after the end of
	    // the string, which is of course impossible, except in multi-line
	    // mode, but it's not a /m regex.
	    return new RegExp('$.');
	  }

	  regExp._glob = pattern;
	  regExp._src = re;

	  return regExp;
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe();
	};

	Minimatch.prototype.makeRe = makeRe;
	function makeRe() {
	  if (this.regexp || this.regexp === false) return this.regexp;

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set;

	  if (!set.length) {
	    this.regexp = false;
	    return this.regexp;
	  }
	  var options = this.options;

	  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
	  var flags = options.nocase ? 'i' : '';

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
	    }).join('\\\/');
	  }).join('|');

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$';

	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$';

	  try {
	    this.regexp = new RegExp(re, flags);
	  } catch (ex) {
	    this.regexp = false;
	  }
	  return this.regexp;
	}

	minimatch.match = function (list, pattern, options) {
	  options = options || {};
	  var mm = new Minimatch(pattern, options);
	  list = list.filter(function (f) {
	    return mm.match(f);
	  });
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern);
	  }
	  return list;
	};

	Minimatch.prototype.match = match;
	function match(f, partial) {
	  this.debug('match', f, this.pattern);
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false;
	  if (this.empty) return f === '';

	  if (f === '/' && partial) return true;

	  var options = this.options;

	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/');
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit);
	  this.debug(this.pattern, 'split', f);

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set;
	  this.debug(this.pattern, 'set', set);

	  // Find the basename of the path by looking for the last non-empty segment
	  var filename;
	  var i;
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i];
	    if (filename) break;
	  }

	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i];
	    var file = f;
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename];
	    }
	    var hit = this.matchOne(file, pattern, partial);
	    if (hit) {
	      if (options.flipNegate) return true;
	      return !this.negate;
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false;
	  return this.negate;
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options;

	  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

	  this.debug('matchOne', file.length, pattern.length);

	  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
	    this.debug('matchOne loop');
	    var p = pattern[pi];
	    var f = file[fi];

	    this.debug(pattern, p, f);

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false;

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f]);

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi;
	      var pr = pi + 1;
	      if (pr === pl) {
	        this.debug('** at the end');
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
	        }
	        return true;
	      }

	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr];

	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee);
	          // found a match.
	          return true;
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
	            this.debug('dot detected!', file, fr, pattern, pr);
	            break;
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue');
	          fr++;
	        }
	      }

	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
	        if (fr === fl) return true;
	      }
	      return false;
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit;
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase();
	      } else {
	        hit = f === p;
	      }
	      this.debug('string match', p, f, hit);
	    } else {
	      hit = f.match(p);
	      this.debug('pattern match', p, f, hit);
	    }

	    if (!hit) return false;
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true;
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial;
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
	    return emptyFileEnd;
	  }

	  // should be unreachable.
	  throw new Error('wtf?');
	};

	// replace stuff like \* with *
	function globUnescape(s) {
	  return s.replace(/\\(.)/g, '$1');
	}

	function regExpEscape(s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
	}

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var concatMap = __webpack_require__(382);
	var balanced = __webpack_require__(383);

	module.exports = expandTop;

	var escSlash = '\0SLASH' + Math.random() + '\0';
	var escOpen = '\0OPEN' + Math.random() + '\0';
	var escClose = '\0CLOSE' + Math.random() + '\0';
	var escComma = '\0COMMA' + Math.random() + '\0';
	var escPeriod = '\0PERIOD' + Math.random() + '\0';

	function numeric(str) {
	  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
	}

	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str) return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m) return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length - 1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length - 1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str) return [];

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function identity(e) {
	  return e;
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return (/^-?0\d/.test(el)
	  );
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];

	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }

	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length ? expand(m.post, false) : [''];
	        return post.map(function (p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }

	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length ? expand(m.post, false) : [''];

	  var N;

	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length);
	    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);

	    N = [];

	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\') c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function (el) {
	      return expand(el, false);
	    });
	  }

	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion) expansions.push(expansion);
	    }
	  }

	  return expansions;
	}

/***/ },
/* 382 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);else res.push(x);
	    }
	    return res;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

/***/ },
/* 383 */
/***/ function(module, exports) {

	"use strict";

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;

	    while (i < str.length && i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [begs.pop(), bi];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [left, right];
	    }
	  }

	  return result;
	}

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	function posix(path) {
		return path.charAt(0) === '/';
	};

	function win32(path) {
		// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = !!device && device.charAt(1) !== ':';

		// UNC paths are always absolute
		return !!result[2] || isUnc;
	};

	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = globSync;
	globSync.GlobSync = GlobSync;

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var minimatch = __webpack_require__(380);
	var Minimatch = minimatch.Minimatch;
	var Glob = __webpack_require__(379).Glob;
	var util = __webpack_require__(263);
	var path = __webpack_require__(230);
	var assert = __webpack_require__(342);
	var isAbsolute = __webpack_require__(384);
	var common = __webpack_require__(386);
	var alphasort = common.alphasort;
	var alphasorti = common.alphasorti;
	var setopts = common.setopts;
	var ownProp = common.ownProp;
	var childrenIgnored = common.childrenIgnored;

	function globSync(pattern, options) {
	  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');

	  return new GlobSync(pattern, options).found;
	}

	function GlobSync(pattern, options) {
	  if (!pattern) throw new Error('must provide pattern');

	  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');

	  if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);

	  setopts(this, pattern, options);

	  if (this.noprocess) return this;

	  var n = this.minimatch.set.length;
	  this.matches = new Array(n);
	  for (var i = 0; i < n; i++) {
	    this._process(this.minimatch.set[i], i, false);
	  }
	  this._finish();
	}

	GlobSync.prototype._finish = function () {
	  assert(this instanceof GlobSync);
	  if (this.realpath) {
	    var self = this;
	    this.matches.forEach(function (matchset, index) {
	      var set = self.matches[index] = Object.create(null);
	      for (var p in matchset) {
	        try {
	          p = self._makeAbs(p);
	          var real = fs.realpathSync(p, self.realpathCache);
	          set[real] = true;
	        } catch (er) {
	          if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;
	        }
	      }
	    });
	  }
	  common.finish(this);
	};

	GlobSync.prototype._process = function (pattern, index, inGlobStar) {
	  assert(this instanceof GlobSync);

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0;
	  while (typeof pattern[n] === 'string') {
	    n++;
	  }
	  // now n is the index of the first one that is *not* a string.

	  // See if there's anything else
	  var prefix;
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index);
	      return;

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null;
	      break;

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/');
	      break;
	  }

	  var remain = pattern.slice(n);

	  // get the list of entries.
	  var read;
	  if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;
	    read = prefix;
	  } else read = prefix;

	  var abs = this._makeAbs(read);

	  //if ignored, skip processing
	  if (childrenIgnored(this, read)) return;

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR;
	  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
	};

	GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
	  var entries = this._readdir(abs, inGlobStar);

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries) return;

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0];
	  var negate = !!this.minimatch.negate;
	  var rawGlob = pn._glob;
	  var dotOk = this.dot || rawGlob.charAt(0) === '.';

	  var matchedEntries = [];
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i];
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m;
	      if (negate && !prefix) {
	        m = !e.match(pn);
	      } else {
	        m = e.match(pn);
	      }
	      if (m) matchedEntries.push(e);
	    }
	  }

	  var len = matchedEntries.length;
	  // If there are no matched entries, then nothing matches.
	  if (len === 0) return;

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index]) this.matches[index] = Object.create(null);

	    for (var i = 0; i < len; i++) {
	      var e = matchedEntries[i];
	      if (prefix) {
	        if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e);
	      }
	      this.matches[index][e] = true;
	    }
	    // This was the last one, and no stats were needed
	    return;
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift();
	  for (var i = 0; i < len; i++) {
	    var e = matchedEntries[i];
	    var newPattern;
	    if (prefix) newPattern = [prefix, e];else newPattern = [e];
	    this._process(newPattern.concat(remain), index, inGlobStar);
	  }
	};

	GlobSync.prototype._emitMatch = function (index, e) {
	  var abs = this._makeAbs(e);
	  if (this.mark) e = this._mark(e);

	  if (this.matches[index][e]) return;

	  if (this.nodir) {
	    var c = this.cache[this._makeAbs(e)];
	    if (c === 'DIR' || Array.isArray(c)) return;
	  }

	  this.matches[index][e] = true;
	  if (this.stat) this._stat(e);
	};

	GlobSync.prototype._readdirInGlobStar = function (abs) {
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow) return this._readdir(abs, false);

	  var entries;
	  var lstat;
	  var stat;
	  try {
	    lstat = fs.lstatSync(abs);
	  } catch (er) {
	    // lstat failed, doesn't exist
	    return null;
	  }

	  var isSym = lstat.isSymbolicLink();
	  this.symlinks[abs] = isSym;

	  // If it's not a symlink or a dir, then it's definitely a regular file.
	  // don't bother doing a readdir in that case.
	  if (!isSym && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);

	  return entries;
	};

	GlobSync.prototype._readdir = function (abs, inGlobStar) {
	  var entries;

	  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs];
	    if (!c || c === 'FILE') return null;

	    if (Array.isArray(c)) return c;
	  }

	  try {
	    return this._readdirEntries(abs, fs.readdirSync(abs));
	  } catch (er) {
	    this._readdirError(abs, er);
	    return null;
	  }
	};

	GlobSync.prototype._readdirEntries = function (abs, entries) {
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i++) {
	      var e = entries[i];
	      if (abs === '/') e = abs + e;else e = abs + '/' + e;
	      this.cache[e] = true;
	    }
	  }

	  this.cache[abs] = entries;

	  // mark and cache dir-ness
	  return entries;
	};

	GlobSync.prototype._readdirError = function (f, er) {
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR':
	      // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE';
	      break;

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false;
	      break;

	    default:
	      // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false;
	      if (this.strict) throw er;
	      if (!this.silent) console.error('glob error', er);
	      break;
	  }
	};

	GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

	  var entries = this._readdir(abs, inGlobStar);

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries) return;

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1);
	  var gspref = prefix ? [prefix] : [];
	  var noGlobStar = gspref.concat(remainWithoutGlobStar);

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false);

	  var len = entries.length;
	  var isSym = this.symlinks[abs];

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar) return;

	  for (var i = 0; i < len; i++) {
	    var e = entries[i];
	    if (e.charAt(0) === '.' && !this.dot) continue;

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
	    this._process(instead, index, true);

	    var below = gspref.concat(entries[i], remain);
	    this._process(below, index, true);
	  }
	};

	GlobSync.prototype._processSimple = function (prefix, index) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var exists = this._stat(prefix);

	  if (!this.matches[index]) this.matches[index] = Object.create(null);

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists) return;

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix);
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix);
	    } else {
	      prefix = path.resolve(this.root, prefix);
	      if (trail) prefix += '/';
	    }
	  }

	  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');

	  // Mark this as a match
	  this.matches[index][prefix] = true;
	};

	// Returns either 'DIR', 'FILE', or false
	GlobSync.prototype._stat = function (f) {
	  var abs = this._makeAbs(f);
	  var needDir = f.slice(-1) === '/';

	  if (f.length > this.maxLength) return false;

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs];

	    if (Array.isArray(c)) c = 'DIR';

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR') return c;

	    if (needDir && c === 'FILE') return false;

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists;
	  var stat = this.statCache[abs];
	  if (!stat) {
	    var lstat;
	    try {
	      lstat = fs.lstatSync(abs);
	    } catch (er) {
	      return false;
	    }

	    if (lstat.isSymbolicLink()) {
	      try {
	        stat = fs.statSync(abs);
	      } catch (er) {
	        stat = lstat;
	      }
	    } else {
	      stat = lstat;
	    }
	  }

	  this.statCache[abs] = stat;

	  var c = stat.isDirectory() ? 'DIR' : 'FILE';
	  this.cache[abs] = this.cache[abs] || c;

	  if (needDir && c !== 'DIR') return false;

	  return c;
	};

	GlobSync.prototype._mark = function (p) {
	  return common.mark(this, p);
	};

	GlobSync.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	exports.alphasort = alphasort;
	exports.alphasorti = alphasorti;
	exports.setopts = setopts;
	exports.ownProp = ownProp;
	exports.makeAbs = makeAbs;
	exports.finish = finish;
	exports.mark = mark;
	exports.isIgnored = isIgnored;
	exports.childrenIgnored = childrenIgnored;

	function ownProp(obj, field) {
	  return Object.prototype.hasOwnProperty.call(obj, field);
	}

	var path = __webpack_require__(230);
	var minimatch = __webpack_require__(380);
	var isAbsolute = __webpack_require__(384);
	var Minimatch = minimatch.Minimatch;

	function alphasorti(a, b) {
	  return a.toLowerCase().localeCompare(b.toLowerCase());
	}

	function alphasort(a, b) {
	  return a.localeCompare(b);
	}

	function setupIgnores(self, options) {
	  self.ignore = options.ignore || [];

	  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];

	  if (self.ignore.length) {
	    self.ignore = self.ignore.map(ignoreMap);
	  }
	}

	// ignore patterns are always in dot:true mode.
	function ignoreMap(pattern) {
	  var gmatcher = null;
	  if (pattern.slice(-3) === '/**') {
	    var gpattern = pattern.replace(/(\/\*\*)+$/, '');
	    gmatcher = new Minimatch(gpattern, { dot: true });
	  }

	  return {
	    matcher: new Minimatch(pattern, { dot: true }),
	    gmatcher: gmatcher
	  };
	}

	function setopts(self, pattern, options) {
	  if (!options) options = {};

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar");
	    }
	    pattern = "**/" + pattern;
	  }

	  self.silent = !!options.silent;
	  self.pattern = pattern;
	  self.strict = options.strict !== false;
	  self.realpath = !!options.realpath;
	  self.realpathCache = options.realpathCache || Object.create(null);
	  self.follow = !!options.follow;
	  self.dot = !!options.dot;
	  self.mark = !!options.mark;
	  self.nodir = !!options.nodir;
	  if (self.nodir) self.mark = true;
	  self.sync = !!options.sync;
	  self.nounique = !!options.nounique;
	  self.nonull = !!options.nonull;
	  self.nosort = !!options.nosort;
	  self.nocase = !!options.nocase;
	  self.stat = !!options.stat;
	  self.noprocess = !!options.noprocess;

	  self.maxLength = options.maxLength || Infinity;
	  self.cache = options.cache || Object.create(null);
	  self.statCache = options.statCache || Object.create(null);
	  self.symlinks = options.symlinks || Object.create(null);

	  setupIgnores(self, options);

	  self.changedCwd = false;
	  var cwd = process.cwd();
	  if (!ownProp(options, "cwd")) self.cwd = cwd;else {
	    self.cwd = options.cwd;
	    self.changedCwd = path.resolve(options.cwd) !== cwd;
	  }

	  self.root = options.root || path.resolve(self.cwd, "/");
	  self.root = path.resolve(self.root);
	  if (process.platform === "win32") self.root = self.root.replace(/\\/g, "/");

	  self.nomount = !!options.nomount;

	  // disable comments and negation in Minimatch.
	  // Note that they are not supported in Glob itself anyway.
	  options.nonegate = true;
	  options.nocomment = true;

	  self.minimatch = new Minimatch(pattern, options);
	  self.options = self.minimatch.options;
	}

	function finish(self) {
	  var nou = self.nounique;
	  var all = nou ? [] : Object.create(null);

	  for (var i = 0, l = self.matches.length; i < l; i++) {
	    var matches = self.matches[i];
	    if (!matches || Object.keys(matches).length === 0) {
	      if (self.nonull) {
	        // do like the shell, and spit out the literal glob
	        var literal = self.minimatch.globSet[i];
	        if (nou) all.push(literal);else all[literal] = true;
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches);
	      if (nou) all.push.apply(all, m);else m.forEach(function (m) {
	        all[m] = true;
	      });
	    }
	  }

	  if (!nou) all = Object.keys(all);

	  if (!self.nosort) all = all.sort(self.nocase ? alphasorti : alphasort);

	  // at *some* point we statted all of these
	  if (self.mark) {
	    for (var i = 0; i < all.length; i++) {
	      all[i] = self._mark(all[i]);
	    }
	    if (self.nodir) {
	      all = all.filter(function (e) {
	        return !/\/$/.test(e);
	      });
	    }
	  }

	  if (self.ignore.length) all = all.filter(function (m) {
	    return !isIgnored(self, m);
	  });

	  self.found = all;
	}

	function mark(self, p) {
	  var abs = makeAbs(self, p);
	  var c = self.cache[abs];
	  var m = p;
	  if (c) {
	    var isDir = c === 'DIR' || Array.isArray(c);
	    var slash = p.slice(-1) === '/';

	    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);

	    if (m !== p) {
	      var mabs = makeAbs(self, m);
	      self.statCache[mabs] = self.statCache[abs];
	      self.cache[mabs] = self.cache[abs];
	    }
	  }

	  return m;
	}

	// lotta situps...
	function makeAbs(self, f) {
	  var abs = f;
	  if (f.charAt(0) === '/') {
	    abs = path.join(self.root, f);
	  } else if (isAbsolute(f) || f === '') {
	    abs = f;
	  } else if (self.changedCwd) {
	    abs = path.resolve(self.cwd, f);
	  } else {
	    abs = path.resolve(f);
	  }
	  return abs;
	}

	// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
	// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
	function isIgnored(self, path) {
	  if (!self.ignore.length) return false;

	  return self.ignore.some(function (item) {
	    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
	  });
	}

	function childrenIgnored(self, path) {
	  if (!self.ignore.length) return false;

	  return self.ignore.some(function (item) {
	    return !!(item.gmatcher && item.gmatcher.match(path));
	  });
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var wrappy = __webpack_require__(388);
	var reqs = Object.create(null);
	var once = __webpack_require__(389);

	module.exports = wrappy(inflight);

	function inflight(key, cb) {
	  if (reqs[key]) {
	    reqs[key].push(cb);
	    return null;
	  } else {
	    reqs[key] = [cb];
	    return makeres(key);
	  }
	}

	function makeres(key) {
	  return once(function RES() {
	    var cbs = reqs[key];
	    var len = cbs.length;
	    var args = slice(arguments);
	    for (var i = 0; i < len; i++) {
	      cbs[i].apply(null, args);
	    }
	    if (cbs.length > len) {
	      // added more in the interim.
	      // de-zalgo, just in case, but don't call again.
	      cbs.splice(0, len);
	      process.nextTick(function () {
	        RES.apply(null, args);
	      });
	    } else {
	      delete reqs[key];
	    }
	  });
	}

	function slice(args) {
	  var length = args.length;
	  var array = [];

	  for (var i = 0; i < length; i++) {
	    array[i] = args[i];
	  }return array;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 388 */
/***/ function(module, exports) {

	'use strict';

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy;
	function wrappy(fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb);

	  if (typeof fn !== 'function') throw new TypeError('need wrapper function');

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k];
	  });

	  return wrapper;

	  function wrapper() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    var ret = fn.apply(this, args);
	    var cb = args[args.length - 1];
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k];
	      });
	    }
	    return ret;
	  }
	}

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var wrappy = __webpack_require__(388);
	module.exports = wrappy(once);

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function value() {
	      return once(this);
	    },
	    configurable: true
	  });
	});

	function once(fn) {
	  var f = function f() {
	    if (f.called) return f.value;
	    f.called = true;
	    return f.value = fn.apply(this, arguments);
	  };
	  f.called = false;
	  return f;
	}

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// USAGE:
	// var handlebars = require('handlebars');
	/* eslint-disable no-var */

	// var local = handlebars.create();

	var handlebars = __webpack_require__(391)['default'];

	var printer = __webpack_require__(419);
	handlebars.PrintVisitor = printer.PrintVisitor;
	handlebars.print = printer.print;

	module.exports = handlebars;

	// Publish a Node.js require() handler for .handlebars and .hbs files
	function extension(module, filename) {
	  var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	  var templateString = fs.readFileSync(filename, 'utf8');
	  module.exports = handlebars.compile(templateString);
	}
	/* istanbul ignore else */
	if ("function" !== 'undefined' && (void 0)) {
	  (void 0)['.handlebars'] = extension;
	  (void 0)['.hbs'] = extension;
	}

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _handlebarsRuntime = __webpack_require__(392);

	var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

	// Compiler imports

	var _handlebarsCompilerAst = __webpack_require__(410);

	var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

	var _handlebarsCompilerBase = __webpack_require__(411);

	var _handlebarsCompilerCompiler = __webpack_require__(416);

	var _handlebarsCompilerJavascriptCompiler = __webpack_require__(417);

	var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

	var _handlebarsCompilerVisitor = __webpack_require__(414);

	var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

	var _handlebarsNoConflict = __webpack_require__(409);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	var _create = _handlebarsRuntime2['default'].create;
	function create() {
	  var hb = _create();

	  hb.compile = function (input, options) {
	    return _handlebarsCompilerCompiler.compile(input, options, hb);
	  };
	  hb.precompile = function (input, options) {
	    return _handlebarsCompilerCompiler.precompile(input, options, hb);
	  };

	  hb.AST = _handlebarsCompilerAst2['default'];
	  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
	  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
	  hb.Parser = _handlebarsCompilerBase.parser;
	  hb.parse = _handlebarsCompilerBase.parse;

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst.Visitor = _handlebarsCompilerVisitor2['default'];

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	// istanbul ignore next

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj['default'] = obj;return newObj;
	  }
	}

	var _handlebarsBase = __webpack_require__(393);

	var base = _interopRequireWildcard(_handlebarsBase);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _handlebarsSafeString = __webpack_require__(407);

	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

	var _handlebarsException = __webpack_require__(395);

	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

	var _handlebarsUtils = __webpack_require__(394);

	var Utils = _interopRequireWildcard(_handlebarsUtils);

	var _handlebarsRuntime = __webpack_require__(408);

	var runtime = _interopRequireWildcard(_handlebarsRuntime);

	var _handlebarsNoConflict = __webpack_require__(409);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(394);

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	var _helpers = __webpack_require__(396);

	var _decorators = __webpack_require__(404);

	var _logger = __webpack_require__(406);

	var _logger2 = _interopRequireDefault(_logger);

	var VERSION = '4.0.5';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 7;

	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];

/***/ },
/* 394 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function isFunction(value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ },
/* 395 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  if (loc) {
	    this.lineNumber = line;
	    this.column = column;
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _helpersBlockHelperMissing = __webpack_require__(397);

	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

	var _helpersEach = __webpack_require__(398);

	var _helpersEach2 = _interopRequireDefault(_helpersEach);

	var _helpersHelperMissing = __webpack_require__(399);

	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

	var _helpersIf = __webpack_require__(400);

	var _helpersIf2 = _interopRequireDefault(_helpersIf);

	var _helpersLog = __webpack_require__(401);

	var _helpersLog2 = _interopRequireDefault(_helpersLog);

	var _helpersLookup = __webpack_require__(402);

	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

	var _helpersWith = __webpack_require__(403);

	var _helpersWith2 = _interopRequireDefault(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(394);

	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(394);

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && (typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(394);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 401 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 402 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(394);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _decoratorsInline = __webpack_require__(405);

	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(394);

	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function ret(context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(394);

	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

/***/ },
/* 407 */
/***/ function(module, exports) {

	// Build out our basic SafeString type
	'use strict';

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	// istanbul ignore next

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj['default'] = obj;return newObj;
	  }
	}

	var _utils = __webpack_require__(394);

	var Utils = _interopRequireWildcard(_utils);

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	var _base = __webpack_require__(393);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + (typeof templateSpec === 'undefined' ? 'undefined' : _typeof(templateSpec)));
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }

	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context !== depths[0]) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    options.data = _base.createFrame(options.data);
	    partialBlock = options.data['partial-block'] = options.fn;

	    if (partialBlock.partials) {
	      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
	    }
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

/***/ },
/* 409 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 410 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var AST = {
	  // Public API used to evaluate derived attributes regarding AST nodes
	  helpers: {
	    // a mustache is definitely a helper if:
	    // * it is an eligible helper, and
	    // * it has at least one parameter or hash segment
	    helperExpression: function helperExpression(node) {
	      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
	    },

	    scopedId: function scopedId(path) {
	      return (/^\.|this\b/.test(path.original)
	      );
	    },

	    // an ID is simple if it only has one part, and that part is not
	    // `..` or `this`.
	    simpleId: function simpleId(path) {
	      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
	    }
	  }
	};

	// Must be exported as an object rather than the root of the module as the jison lexer
	// must modify the object to operate properly.
	exports['default'] = AST;
	module.exports = exports['default'];

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.parse = parse;
	// istanbul ignore next

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj['default'] = obj;return newObj;
	  }
	}

	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _parser = __webpack_require__(412);

	var _parser2 = _interopRequireDefault(_parser);

	var _whitespaceControl = __webpack_require__(413);

	var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

	var _helpers = __webpack_require__(415);

	var Helpers = _interopRequireWildcard(_helpers);

	var _utils = __webpack_require__(394);

	exports.parser = _parser2['default'];

	var yy = {};
	_utils.extend(yy, Helpers);

	function parse(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }

	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };

	  var strip = new _whitespaceControl2['default'](options);
	  return strip.accept(_parser2['default'].parse(input));
	}

/***/ },
/* 412 */
/***/ function(module, exports) {

	/* istanbul ignore next */
	/* Jison generated parser */
	"use strict";

	var handlebars = function () {
	    var parser = { trace: function trace() {},
	        yy: {},
	        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
	        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
	        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
	        /**/) {

	            var $0 = $$.length - 1;
	            switch (yystate) {
	                case 1:
	                    return $$[$0 - 1];
	                    break;
	                case 2:
	                    this.$ = yy.prepareProgram($$[$0]);
	                    break;
	                case 3:
	                    this.$ = $$[$0];
	                    break;
	                case 4:
	                    this.$ = $$[$0];
	                    break;
	                case 5:
	                    this.$ = $$[$0];
	                    break;
	                case 6:
	                    this.$ = $$[$0];
	                    break;
	                case 7:
	                    this.$ = $$[$0];
	                    break;
	                case 8:
	                    this.$ = $$[$0];
	                    break;
	                case 9:
	                    this.$ = {
	                        type: 'CommentStatement',
	                        value: yy.stripComment($$[$0]),
	                        strip: yy.stripFlags($$[$0], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 10:
	                    this.$ = {
	                        type: 'ContentStatement',
	                        original: $$[$0],
	                        value: $$[$0],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 11:
	                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 12:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
	                    break;
	                case 13:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
	                    break;
	                case 14:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
	                    break;
	                case 15:
	                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 16:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 17:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 18:
	                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
	                    break;
	                case 19:
	                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
	                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
	                    program.chained = true;

	                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

	                    break;
	                case 20:
	                    this.$ = $$[$0];
	                    break;
	                case 21:
	                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
	                    break;
	                case 22:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 23:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 24:
	                    this.$ = {
	                        type: 'PartialStatement',
	                        name: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        indent: '',
	                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 25:
	                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 26:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
	                    break;
	                case 27:
	                    this.$ = $$[$0];
	                    break;
	                case 28:
	                    this.$ = $$[$0];
	                    break;
	                case 29:
	                    this.$ = {
	                        type: 'SubExpression',
	                        path: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 30:
	                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 31:
	                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 32:
	                    this.$ = yy.id($$[$0 - 1]);
	                    break;
	                case 33:
	                    this.$ = $$[$0];
	                    break;
	                case 34:
	                    this.$ = $$[$0];
	                    break;
	                case 35:
	                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 36:
	                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
	                    break;
	                case 37:
	                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
	                    break;
	                case 38:
	                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
	                    break;
	                case 39:
	                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
	                    break;
	                case 40:
	                    this.$ = $$[$0];
	                    break;
	                case 41:
	                    this.$ = $$[$0];
	                    break;
	                case 42:
	                    this.$ = yy.preparePath(true, $$[$0], this._$);
	                    break;
	                case 43:
	                    this.$ = yy.preparePath(false, $$[$0], this._$);
	                    break;
	                case 44:
	                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
	                    break;
	                case 45:
	                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
	                    break;
	                case 46:
	                    this.$ = [];
	                    break;
	                case 47:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 48:
	                    this.$ = [$$[$0]];
	                    break;
	                case 49:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 50:
	                    this.$ = [];
	                    break;
	                case 51:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 58:
	                    this.$ = [];
	                    break;
	                case 59:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 64:
	                    this.$ = [];
	                    break;
	                case 65:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 70:
	                    this.$ = [];
	                    break;
	                case 71:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 78:
	                    this.$ = [];
	                    break;
	                case 79:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 82:
	                    this.$ = [];
	                    break;
	                case 83:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 86:
	                    this.$ = [];
	                    break;
	                case 87:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 90:
	                    this.$ = [];
	                    break;
	                case 91:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 94:
	                    this.$ = [];
	                    break;
	                case 95:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 98:
	                    this.$ = [$$[$0]];
	                    break;
	                case 99:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 100:
	                    this.$ = [$$[$0]];
	                    break;
	                case 101:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	            }
	        },
	        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
	        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
	        parseError: function parseError(str, hash) {
	            throw new Error(str);
	        },
	        parse: function parse(input) {
	            var self = this,
	                stack = [0],
	                vstack = [null],
	                lstack = [],
	                table = this.table,
	                yytext = "",
	                yylineno = 0,
	                yyleng = 0,
	                recovering = 0,
	                TERROR = 2,
	                EOF = 1;
	            this.lexer.setInput(input);
	            this.lexer.yy = this.yy;
	            this.yy.lexer = this.lexer;
	            this.yy.parser = this;
	            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
	            var yyloc = this.lexer.yylloc;
	            lstack.push(yyloc);
	            var ranges = this.lexer.options && this.lexer.options.ranges;
	            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
	            function popStack(n) {
	                stack.length = stack.length - 2 * n;
	                vstack.length = vstack.length - n;
	                lstack.length = lstack.length - n;
	            }
	            function lex() {
	                var token;
	                token = self.lexer.lex() || 1;
	                if (typeof token !== "number") {
	                    token = self.symbols_[token] || token;
	                }
	                return token;
	            }
	            var symbol,
	                preErrorSymbol,
	                state,
	                action,
	                a,
	                r,
	                yyval = {},
	                p,
	                len,
	                newState,
	                expected;
	            while (true) {
	                state = stack[stack.length - 1];
	                if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                } else {
	                    if (symbol === null || typeof symbol == "undefined") {
	                        symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                }
	                if (typeof action === "undefined" || !action.length || !action[0]) {
	                    var errStr = "";
	                    if (!recovering) {
	                        expected = [];
	                        for (p in table[state]) {
	                            if (this.terminals_[p] && p > 2) {
	                                expected.push("'" + this.terminals_[p] + "'");
	                            }
	                        }if (this.lexer.showPosition) {
	                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
	                        } else {
	                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
	                        }
	                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
	                    }
	                }
	                if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
	                }
	                switch (action[0]) {
	                    case 1:
	                        stack.push(symbol);
	                        vstack.push(this.lexer.yytext);
	                        lstack.push(this.lexer.yylloc);
	                        stack.push(action[1]);
	                        symbol = null;
	                        if (!preErrorSymbol) {
	                            yyleng = this.lexer.yyleng;
	                            yytext = this.lexer.yytext;
	                            yylineno = this.lexer.yylineno;
	                            yyloc = this.lexer.yylloc;
	                            if (recovering > 0) recovering--;
	                        } else {
	                            symbol = preErrorSymbol;
	                            preErrorSymbol = null;
	                        }
	                        break;
	                    case 2:
	                        len = this.productions_[action[1]][1];
	                        yyval.$ = vstack[vstack.length - len];
	                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
	                        if (ranges) {
	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                        }
	                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
	                        if (typeof r !== "undefined") {
	                            return r;
	                        }
	                        if (len) {
	                            stack = stack.slice(0, -1 * len * 2);
	                            vstack = vstack.slice(0, -1 * len);
	                            lstack = lstack.slice(0, -1 * len);
	                        }
	                        stack.push(this.productions_[action[1]][0]);
	                        vstack.push(yyval.$);
	                        lstack.push(yyval._$);
	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                        stack.push(newState);
	                        break;
	                    case 3:
	                        return true;
	                }
	            }
	            return true;
	        }
	    };
	    /* Jison generated lexer */
	    var lexer = function () {
	        var lexer = { EOF: 1,
	            parseError: function parseError(str, hash) {
	                if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                } else {
	                    throw new Error(str);
	                }
	            },
	            setInput: function setInput(input) {
	                this._input = input;
	                this._more = this._less = this.done = false;
	                this.yylineno = this.yyleng = 0;
	                this.yytext = this.matched = this.match = '';
	                this.conditionStack = ['INITIAL'];
	                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
	                if (this.options.ranges) this.yylloc.range = [0, 0];
	                this.offset = 0;
	                return this;
	            },
	            input: function input() {
	                var ch = this._input[0];
	                this.yytext += ch;
	                this.yyleng++;
	                this.offset++;
	                this.match += ch;
	                this.matched += ch;
	                var lines = ch.match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                } else {
	                    this.yylloc.last_column++;
	                }
	                if (this.options.ranges) this.yylloc.range[1]++;

	                this._input = this._input.slice(1);
	                return ch;
	            },
	            unput: function unput(ch) {
	                var len = ch.length;
	                var lines = ch.split(/(?:\r\n?|\n)/g);

	                this._input = ch + this._input;
	                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	                //this.yyleng -= len;
	                this.offset -= len;
	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                this.match = this.match.substr(0, this.match.length - 1);
	                this.matched = this.matched.substr(0, this.matched.length - 1);

	                if (lines.length - 1) this.yylineno -= lines.length - 1;
	                var r = this.yylloc.range;

	                this.yylloc = { first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                };

	                if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                }
	                return this;
	            },
	            more: function more() {
	                this._more = true;
	                return this;
	            },
	            less: function less(n) {
	                this.unput(this.match.slice(n));
	            },
	            pastInput: function pastInput() {
	                var past = this.matched.substr(0, this.matched.length - this.match.length);
	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	            },
	            upcomingInput: function upcomingInput() {
	                var next = this.match;
	                if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                }
	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	            },
	            showPosition: function showPosition() {
	                var pre = this.pastInput();
	                var c = new Array(pre.length + 1).join("-");
	                return pre + this.upcomingInput() + "\n" + c + "^";
	            },
	            next: function next() {
	                if (this.done) {
	                    return this.EOF;
	                }
	                if (!this._input) this.done = true;

	                var token, match, tempMatch, index, col, lines;
	                if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                }
	                var rules = this._currentRules();
	                for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                        match = tempMatch;
	                        index = i;
	                        if (!this.options.flex) break;
	                    }
	                }
	                if (match) {
	                    lines = match[0].match(/(?:\r\n?|\n).*/g);
	                    if (lines) this.yylineno += lines.length;
	                    this.yylloc = { first_line: this.yylloc.last_line,
	                        last_line: this.yylineno + 1,
	                        first_column: this.yylloc.last_column,
	                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
	                    this.yytext += match[0];
	                    this.match += match[0];
	                    this.matches = match;
	                    this.yyleng = this.yytext.length;
	                    if (this.options.ranges) {
	                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                    }
	                    this._more = false;
	                    this._input = this._input.slice(match[0].length);
	                    this.matched += match[0];
	                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
	                    if (this.done && this._input) this.done = false;
	                    if (token) return token;else return;
	                }
	                if (this._input === "") {
	                    return this.EOF;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
	                }
	            },
	            lex: function lex() {
	                var r = this.next();
	                if (typeof r !== 'undefined') {
	                    return r;
	                } else {
	                    return this.lex();
	                }
	            },
	            begin: function begin(condition) {
	                this.conditionStack.push(condition);
	            },
	            popState: function popState() {
	                return this.conditionStack.pop();
	            },
	            _currentRules: function _currentRules() {
	                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	            },
	            topState: function topState() {
	                return this.conditionStack[this.conditionStack.length - 2];
	            },
	            pushState: function begin(condition) {
	                this.begin(condition);
	            } };
	        lexer.options = {};
	        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
	        /**/) {

	            function strip(start, end) {
	                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
	            }

	            var YYSTATE = YY_START;
	            switch ($avoiding_name_collisions) {
	                case 0:
	                    if (yy_.yytext.slice(-2) === "\\\\") {
	                        strip(0, 1);
	                        this.begin("mu");
	                    } else if (yy_.yytext.slice(-1) === "\\") {
	                        strip(0, 1);
	                        this.begin("emu");
	                    } else {
	                        this.begin("mu");
	                    }
	                    if (yy_.yytext) return 15;

	                    break;
	                case 1:
	                    return 15;
	                    break;
	                case 2:
	                    this.popState();
	                    return 15;

	                    break;
	                case 3:
	                    this.begin('raw');return 15;
	                    break;
	                case 4:
	                    this.popState();
	                    // Should be using `this.topState()` below, but it currently
	                    // returns the second top instead of the first top. Opened an
	                    // issue about it at https://github.com/zaach/jison/issues/291
	                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
	                        return 15;
	                    } else {
	                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
	                        return 'END_RAW_BLOCK';
	                    }

	                    break;
	                case 5:
	                    return 15;
	                    break;
	                case 6:
	                    this.popState();
	                    return 14;

	                    break;
	                case 7:
	                    return 65;
	                    break;
	                case 8:
	                    return 68;
	                    break;
	                case 9:
	                    return 19;
	                    break;
	                case 10:
	                    this.popState();
	                    this.begin('raw');
	                    return 23;

	                    break;
	                case 11:
	                    return 55;
	                    break;
	                case 12:
	                    return 60;
	                    break;
	                case 13:
	                    return 29;
	                    break;
	                case 14:
	                    return 47;
	                    break;
	                case 15:
	                    this.popState();return 44;
	                    break;
	                case 16:
	                    this.popState();return 44;
	                    break;
	                case 17:
	                    return 34;
	                    break;
	                case 18:
	                    return 39;
	                    break;
	                case 19:
	                    return 51;
	                    break;
	                case 20:
	                    return 48;
	                    break;
	                case 21:
	                    this.unput(yy_.yytext);
	                    this.popState();
	                    this.begin('com');

	                    break;
	                case 22:
	                    this.popState();
	                    return 14;

	                    break;
	                case 23:
	                    return 48;
	                    break;
	                case 24:
	                    return 73;
	                    break;
	                case 25:
	                    return 72;
	                    break;
	                case 26:
	                    return 72;
	                    break;
	                case 27:
	                    return 87;
	                    break;
	                case 28:
	                    // ignore whitespace
	                    break;
	                case 29:
	                    this.popState();return 54;
	                    break;
	                case 30:
	                    this.popState();return 33;
	                    break;
	                case 31:
	                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
	                    break;
	                case 32:
	                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
	                    break;
	                case 33:
	                    return 85;
	                    break;
	                case 34:
	                    return 82;
	                    break;
	                case 35:
	                    return 82;
	                    break;
	                case 36:
	                    return 83;
	                    break;
	                case 37:
	                    return 84;
	                    break;
	                case 38:
	                    return 81;
	                    break;
	                case 39:
	                    return 75;
	                    break;
	                case 40:
	                    return 77;
	                    break;
	                case 41:
	                    return 72;
	                    break;
	                case 42:
	                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
	                    break;
	                case 43:
	                    return 'INVALID';
	                    break;
	                case 44:
	                    return 5;
	                    break;
	            }
	        };
	        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
	        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
	        return lexer;
	    }();
	    parser.lexer = lexer;
	    function Parser() {
	        this.yy = {};
	    }Parser.prototype = parser;parser.Parser = Parser;
	    return new Parser();
	}();exports.__esModule = true;
	exports['default'] = handlebars;

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _visitor = __webpack_require__(414);

	var _visitor2 = _interopRequireDefault(_visitor);

	function WhitespaceControl() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  this.options = options;
	}
	WhitespaceControl.prototype = new _visitor2['default']();

	WhitespaceControl.prototype.Program = function (program) {
	  var doStandalone = !this.options.ignoreStandalone;

	  var isRoot = !this.isRootSeen;
	  this.isRootSeen = true;

	  var body = program.body;
	  for (var i = 0, l = body.length; i < l; i++) {
	    var current = body[i],
	        strip = this.accept(current);

	    if (!strip) {
	      continue;
	    }

	    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
	        openStandalone = strip.openStandalone && _isPrevWhitespace,
	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

	    if (strip.close) {
	      omitRight(body, i, true);
	    }
	    if (strip.open) {
	      omitLeft(body, i, true);
	    }

	    if (doStandalone && inlineStandalone) {
	      omitRight(body, i);

	      if (omitLeft(body, i)) {
	        // If we are on a standalone node, save the indent info for partials
	        if (current.type === 'PartialStatement') {
	          // Pull out the whitespace from the final line
	          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
	        }
	      }
	    }
	    if (doStandalone && openStandalone) {
	      omitRight((current.program || current.inverse).body);

	      // Strip out the previous content node if it's whitespace only
	      omitLeft(body, i);
	    }
	    if (doStandalone && closeStandalone) {
	      // Always strip the next node
	      omitRight(body, i);

	      omitLeft((current.inverse || current.program).body);
	    }
	  }

	  return program;
	};

	WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
	  this.accept(block.program);
	  this.accept(block.inverse);

	  // Find the inverse program that is involed with whitespace stripping.
	  var program = block.program || block.inverse,
	      inverse = block.program && block.inverse,
	      firstInverse = inverse,
	      lastInverse = inverse;

	  if (inverse && inverse.chained) {
	    firstInverse = inverse.body[0].program;

	    // Walk the inverse chain to find the last inverse that is actually in the chain.
	    while (lastInverse.chained) {
	      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
	    }
	  }

	  var strip = {
	    open: block.openStrip.open,
	    close: block.closeStrip.close,

	    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
	    // so our parent can determine if we actually are standalone
	    openStandalone: isNextWhitespace(program.body),
	    closeStandalone: isPrevWhitespace((firstInverse || program).body)
	  };

	  if (block.openStrip.close) {
	    omitRight(program.body, null, true);
	  }

	  if (inverse) {
	    var inverseStrip = block.inverseStrip;

	    if (inverseStrip.open) {
	      omitLeft(program.body, null, true);
	    }

	    if (inverseStrip.close) {
	      omitRight(firstInverse.body, null, true);
	    }
	    if (block.closeStrip.open) {
	      omitLeft(lastInverse.body, null, true);
	    }

	    // Find standalone else statments
	    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
	      omitLeft(program.body);
	      omitRight(firstInverse.body);
	    }
	  } else if (block.closeStrip.open) {
	    omitLeft(program.body, null, true);
	  }

	  return strip;
	};

	WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
	  return mustache.strip;
	};

	WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
	  /* istanbul ignore next */
	  var strip = node.strip || {};
	  return {
	    inlineStandalone: true,
	    open: strip.open,
	    close: strip.close
	  };
	};

	function isPrevWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = body.length;
	  }

	  // Nodes that end with newlines are considered whitespace (but are special
	  // cased for strip operations)
	  var prev = body[i - 1],
	      sibling = body[i - 2];
	  if (!prev) {
	    return isRoot;
	  }

	  if (prev.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
	  }
	}
	function isNextWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = -1;
	  }

	  var next = body[i + 1],
	      sibling = body[i + 2];
	  if (!next) {
	    return isRoot;
	  }

	  if (next.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
	  }
	}

	// Marks the node to the right of the position as omitted.
	// I.e. {{foo}}' ' will mark the ' ' node as omitted.
	//
	// If i is undefined, then the first child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitRight(body, i, multiple) {
	  var current = body[i == null ? 0 : i + 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
	    return;
	  }

	  var original = current.value;
	  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
	  current.rightStripped = current.value !== original;
	}

	// Marks the node to the left of the position as omitted.
	// I.e. ' '{{foo}} will mark the ' ' node as omitted.
	//
	// If i is undefined then the last child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitLeft(body, i, multiple) {
	  var current = body[i == null ? body.length - 1 : i - 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
	    return;
	  }

	  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
	  var original = current.value;
	  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
	  current.leftStripped = current.value !== original;
	  return current.leftStripped;
	}

	exports['default'] = WhitespaceControl;
	module.exports = exports['default'];

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	function Visitor() {
	  this.parents = [];
	}

	Visitor.prototype = {
	  constructor: Visitor,
	  mutating: false,

	  // Visits a given value. If mutating, will replace the value if necessary.
	  acceptKey: function acceptKey(node, name) {
	    var value = this.accept(node[name]);
	    if (this.mutating) {
	      // Hacky sanity check: This may have a few false positives for type for the helper
	      // methods but will generally do the right thing without a lot of overhead.
	      if (value && !Visitor.prototype[value.type]) {
	        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
	      }
	      node[name] = value;
	    }
	  },

	  // Performs an accept operation with added sanity check to ensure
	  // required keys are not removed.
	  acceptRequired: function acceptRequired(node, name) {
	    this.acceptKey(node, name);

	    if (!node[name]) {
	      throw new _exception2['default'](node.type + ' requires ' + name);
	    }
	  },

	  // Traverses a given array. If mutating, empty respnses will be removed
	  // for child elements.
	  acceptArray: function acceptArray(array) {
	    for (var i = 0, l = array.length; i < l; i++) {
	      this.acceptKey(array, i);

	      if (!array[i]) {
	        array.splice(i, 1);
	        i--;
	        l--;
	      }
	    }
	  },

	  accept: function accept(object) {
	    if (!object) {
	      return;
	    }

	    /* istanbul ignore next: Sanity code */
	    if (!this[object.type]) {
	      throw new _exception2['default']('Unknown type: ' + object.type, object);
	    }

	    if (this.current) {
	      this.parents.unshift(this.current);
	    }
	    this.current = object;

	    var ret = this[object.type](object);

	    this.current = this.parents.shift();

	    if (!this.mutating || ret) {
	      return ret;
	    } else if (ret !== false) {
	      return object;
	    }
	  },

	  Program: function Program(program) {
	    this.acceptArray(program.body);
	  },

	  MustacheStatement: visitSubExpression,
	  Decorator: visitSubExpression,

	  BlockStatement: visitBlock,
	  DecoratorBlock: visitBlock,

	  PartialStatement: visitPartial,
	  PartialBlockStatement: function PartialBlockStatement(partial) {
	    visitPartial.call(this, partial);

	    this.acceptKey(partial, 'program');
	  },

	  ContentStatement: function ContentStatement() /* content */{},
	  CommentStatement: function CommentStatement() /* comment */{},

	  SubExpression: visitSubExpression,

	  PathExpression: function PathExpression() /* path */{},

	  StringLiteral: function StringLiteral() /* string */{},
	  NumberLiteral: function NumberLiteral() /* number */{},
	  BooleanLiteral: function BooleanLiteral() /* bool */{},
	  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
	  NullLiteral: function NullLiteral() /* literal */{},

	  Hash: function Hash(hash) {
	    this.acceptArray(hash.pairs);
	  },
	  HashPair: function HashPair(pair) {
	    this.acceptRequired(pair, 'value');
	  }
	};

	function visitSubExpression(mustache) {
	  this.acceptRequired(mustache, 'path');
	  this.acceptArray(mustache.params);
	  this.acceptKey(mustache, 'hash');
	}
	function visitBlock(block) {
	  visitSubExpression.call(this, block);

	  this.acceptKey(block, 'program');
	  this.acceptKey(block, 'inverse');
	}
	function visitPartial(partial) {
	  this.acceptRequired(partial, 'name');
	  this.acceptArray(partial.params);
	  this.acceptKey(partial, 'hash');
	}

	exports['default'] = Visitor;
	module.exports = exports['default'];

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.SourceLocation = SourceLocation;
	exports.id = id;
	exports.stripFlags = stripFlags;
	exports.stripComment = stripComment;
	exports.preparePath = preparePath;
	exports.prepareMustache = prepareMustache;
	exports.prepareRawBlock = prepareRawBlock;
	exports.prepareBlock = prepareBlock;
	exports.prepareProgram = prepareProgram;
	exports.preparePartialBlock = preparePartialBlock;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;

	  if (open.path.original !== close) {
	    var errorNode = { loc: open.path.loc };

	    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}

	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}

	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substr(1, token.length - 2);
	  } else {
	    return token;
	  }
	}

	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}

	function stripComment(comment) {
	  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}

	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);

	  var original = data ? '@' : '',
	      dig = [],
	      depth = 0,
	      depthString = '';

	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,


	    // If we have [] syntax then we do not treat path references as operators,
	    // i.e. foo.[this] resolves to approximately context.foo['this']
	    isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;

	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
	      } else if (part === '..') {
	        depth++;
	        depthString += '../';
	      }
	    } else {
	      dig.push(part);
	    }
	  }

	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}

	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	      escaped = escapeFlag !== '{' && escapeFlag !== '&';

	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);

	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };

	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}

	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }

	  var decorator = /\*/.test(openBlock.open);

	  program.blockParams = openBlock.blockParams;

	  var inverse = undefined,
	      inverseStrip = undefined;

	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }

	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }

	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }

	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }

	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	        lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }

	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}

	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);

	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable new-cap */

	'use strict';

	exports.__esModule = true;
	exports.Compiler = Compiler;
	exports.precompile = precompile;
	exports.compile = compile;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(394);

	var _ast = __webpack_require__(410);

	var _ast2 = _interopRequireDefault(_ast);

	var slice = [].slice;

	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,

	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	          otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }

	    return true;
	  },

	  guid: 0,

	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;

	    options.blockParams = options.blockParams || [];

	    // These changes will propagate to the other compiler components
	    var knownHelpers = options.knownHelpers;
	    options.knownHelpers = {
	      'helperMissing': true,
	      'blockHelperMissing': true,
	      'each': true,
	      'if': true,
	      'unless': true,
	      'with': true,
	      'log': true,
	      'lookup': true
	    };
	    if (knownHelpers) {
	      for (var _name in knownHelpers) {
	        /* istanbul ignore else */
	        if (_name in knownHelpers) {
	          options.knownHelpers[_name] = knownHelpers[_name];
	        }
	      }
	    }

	    return this.accept(program);
	  },

	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),

	    // eslint-disable-line new-cap
	    result = childCompiler.compile(program, this.options),
	        guid = this.guid++;

	    this.usePartial = this.usePartial || result.usePartial;

	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;

	    return guid;
	  },

	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }

	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },

	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);

	    var body = program.body,
	        bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }

	    this.options.blockParams.shift();

	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;

	    return this;
	  },

	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);

	    var program = block.program,
	        inverse = block.inverse;

	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);

	    var type = this.classifySexpr(block);

	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }

	    this.opcode('append');
	  },

	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	        path = decorator.path;

	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },

	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;

	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }

	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({ type: 'PathExpression', parts: [], depth: 0 });
	      }
	    }

	    var partialName = partial.name.original,
	        isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }

	    this.setupFullMustacheParams(partial, program, undefined, true);

	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }

	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },

	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);

	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },

	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },

	  CommentStatement: function CommentStatement() {},

	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);

	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	        name = path.parts[0],
	        isBlock = program != null || inverse != null;

	    this.opcode('getContext', path.depth);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    path.strict = true;
	    this.accept(path);

	    this.opcode('invokeAmbiguous', name, isBlock);
	  },

	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },

	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	        path = sexpr.path,
	        name = path.parts[0];

	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;

	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },

	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);

	    var name = path.parts[0],
	        scoped = _ast2['default'].helpers.scopedId(path),
	        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },

	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },

	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },

	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },

	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },

	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },

	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	        i = 0,
	        l = pairs.length;

	    this.opcode('pushHash');

	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },

	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
	  },

	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }

	    this.useDepths = true;
	  },

	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name2 = sexpr.path.parts[0],
	          options = this.options;

	      if (options.knownHelpers[_name2]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }

	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },

	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },

	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';

	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }

	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);

	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }

	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },

	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }

	    return params;
	  },

	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	          param = blockParams && _utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};

	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }

	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}

	function compile(input, options, env) {
	  if (options === undefined) options = {};

	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }

	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var compiled = undefined;

	  function compileInput() {
	    var ast = env.parse(input, options),
	        environment = new env.Compiler().compile(ast, options),
	        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}

	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}

	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _base = __webpack_require__(393);

	var _exception = __webpack_require__(395);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(394);

	var _codeGen = __webpack_require__(418);

	var _codeGen2 = _interopRequireDefault(_codeGen);

	function Literal(value) {
	  this.value = value;
	}

	function JavaScriptCompiler() {}

	JavaScriptCompiler.prototype = {
	  // PUBLIC API: You can override these methods in a subclass to provide
	  // alternative compiled forms for name lookup and buffering semantics
	  nameLookup: function nameLookup(parent, name /* , type*/) {
	    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
	      return [parent, '.', name];
	    } else {
	      return [parent, '[', JSON.stringify(name), ']'];
	    }
	  },
	  depthedLookup: function depthedLookup(name) {
	    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
	  },

	  compilerInfo: function compilerInfo() {
	    var revision = _base.COMPILER_REVISION,
	        versions = _base.REVISION_CHANGES[revision];
	    return [revision, versions];
	  },

	  appendToBuffer: function appendToBuffer(source, location, explicit) {
	    // Force a source as this simplifies the merge logic.
	    if (!_utils.isArray(source)) {
	      source = [source];
	    }
	    source = this.source.wrap(source, location);

	    if (this.environment.isSimple) {
	      return ['return ', source, ';'];
	    } else if (explicit) {
	      // This is a case where the buffer operation occurs as a child of another
	      // construct, generally braces. We have to explicitly output these buffer
	      // operations to ensure that the emitted code goes in the correct location.
	      return ['buffer += ', source, ';'];
	    } else {
	      source.appendToBuffer = true;
	      return source;
	    }
	  },

	  initializeBuffer: function initializeBuffer() {
	    return this.quotedString('');
	  },
	  // END PUBLIC API

	  compile: function compile(environment, options, context, asObject) {
	    this.environment = environment;
	    this.options = options;
	    this.stringParams = this.options.stringParams;
	    this.trackIds = this.options.trackIds;
	    this.precompile = !asObject;

	    this.name = this.environment.name;
	    this.isChild = !!context;
	    this.context = context || {
	      decorators: [],
	      programs: [],
	      environments: []
	    };

	    this.preamble();

	    this.stackSlot = 0;
	    this.stackVars = [];
	    this.aliases = {};
	    this.registers = { list: [] };
	    this.hashes = [];
	    this.compileStack = [];
	    this.inlineStack = [];
	    this.blockParams = [];

	    this.compileChildren(environment, options);

	    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
	    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

	    var opcodes = environment.opcodes,
	        opcode = undefined,
	        firstLoc = undefined,
	        i = undefined,
	        l = undefined;

	    for (i = 0, l = opcodes.length; i < l; i++) {
	      opcode = opcodes[i];

	      this.source.currentLocation = opcode.loc;
	      firstLoc = firstLoc || opcode.loc;
	      this[opcode.opcode].apply(this, opcode.args);
	    }

	    // Flush any trailing content that might be pending.
	    this.source.currentLocation = firstLoc;
	    this.pushSource('');

	    /* istanbul ignore next */
	    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
	      throw new _exception2['default']('Compile completed with content left on stack');
	    }

	    if (!this.decorators.isEmpty()) {
	      this.useDecorators = true;

	      this.decorators.prepend('var decorators = container.decorators;\n');
	      this.decorators.push('return fn;');

	      if (asObject) {
	        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
	      } else {
	        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
	        this.decorators.push('}\n');
	        this.decorators = this.decorators.merge();
	      }
	    } else {
	      this.decorators = undefined;
	    }

	    var fn = this.createFunctionContext(asObject);
	    if (!this.isChild) {
	      var ret = {
	        compiler: this.compilerInfo(),
	        main: fn
	      };

	      if (this.decorators) {
	        ret.main_d = this.decorators; // eslint-disable-line camelcase
	        ret.useDecorators = true;
	      }

	      var _context = this.context;
	      var programs = _context.programs;
	      var decorators = _context.decorators;

	      for (i = 0, l = programs.length; i < l; i++) {
	        if (programs[i]) {
	          ret[i] = programs[i];
	          if (decorators[i]) {
	            ret[i + '_d'] = decorators[i];
	            ret.useDecorators = true;
	          }
	        }
	      }

	      if (this.environment.usePartial) {
	        ret.usePartial = true;
	      }
	      if (this.options.data) {
	        ret.useData = true;
	      }
	      if (this.useDepths) {
	        ret.useDepths = true;
	      }
	      if (this.useBlockParams) {
	        ret.useBlockParams = true;
	      }
	      if (this.options.compat) {
	        ret.compat = true;
	      }

	      if (!asObject) {
	        ret.compiler = JSON.stringify(ret.compiler);

	        this.source.currentLocation = { start: { line: 1, column: 0 } };
	        ret = this.objectLiteral(ret);

	        if (options.srcName) {
	          ret = ret.toStringWithSourceMap({ file: options.destName });
	          ret.map = ret.map && ret.map.toString();
	        } else {
	          ret = ret.toString();
	        }
	      } else {
	        ret.compilerOptions = this.options;
	      }

	      return ret;
	    } else {
	      return fn;
	    }
	  },

	  preamble: function preamble() {
	    // track the last context pushed into place to allow skipping the
	    // getContext opcode when it would be a noop
	    this.lastContext = 0;
	    this.source = new _codeGen2['default'](this.options.srcName);
	    this.decorators = new _codeGen2['default'](this.options.srcName);
	  },

	  createFunctionContext: function createFunctionContext(asObject) {
	    var varDeclarations = '';

	    var locals = this.stackVars.concat(this.registers.list);
	    if (locals.length > 0) {
	      varDeclarations += ', ' + locals.join(', ');
	    }

	    // Generate minimizer alias mappings
	    //
	    // When using true SourceNodes, this will update all references to the given alias
	    // as the source nodes are reused in situ. For the non-source node compilation mode,
	    // aliases will not be used, but this case is already being run on the client and
	    // we aren't concern about minimizing the template size.
	    var aliasCount = 0;
	    for (var alias in this.aliases) {
	      // eslint-disable-line guard-for-in
	      var node = this.aliases[alias];

	      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
	        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
	        node.children[0] = 'alias' + aliasCount;
	      }
	    }

	    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

	    if (this.useBlockParams || this.useDepths) {
	      params.push('blockParams');
	    }
	    if (this.useDepths) {
	      params.push('depths');
	    }

	    // Perform a second pass over the output to merge content when possible
	    var source = this.mergeSource(varDeclarations);

	    if (asObject) {
	      params.push(source);

	      return Function.apply(this, params);
	    } else {
	      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
	    }
	  },
	  mergeSource: function mergeSource(varDeclarations) {
	    var isSimple = this.environment.isSimple,
	        appendOnly = !this.forceBuffer,
	        appendFirst = undefined,
	        sourceSeen = undefined,
	        bufferStart = undefined,
	        bufferEnd = undefined;
	    this.source.each(function (line) {
	      if (line.appendToBuffer) {
	        if (bufferStart) {
	          line.prepend('  + ');
	        } else {
	          bufferStart = line;
	        }
	        bufferEnd = line;
	      } else {
	        if (bufferStart) {
	          if (!sourceSeen) {
	            appendFirst = true;
	          } else {
	            bufferStart.prepend('buffer += ');
	          }
	          bufferEnd.add(';');
	          bufferStart = bufferEnd = undefined;
	        }

	        sourceSeen = true;
	        if (!isSimple) {
	          appendOnly = false;
	        }
	      }
	    });

	    if (appendOnly) {
	      if (bufferStart) {
	        bufferStart.prepend('return ');
	        bufferEnd.add(';');
	      } else if (!sourceSeen) {
	        this.source.push('return "";');
	      }
	    } else {
	      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

	      if (bufferStart) {
	        bufferStart.prepend('return buffer + ');
	        bufferEnd.add(';');
	      } else {
	        this.source.push('return buffer;');
	      }
	    }

	    if (varDeclarations) {
	      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
	    }

	    return this.source.merge();
	  },

	  // [blockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // On stack, after: return value of blockHelperMissing
	  //
	  // The purpose of this opcode is to take a block of the form
	  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
	  // replace it on the stack with the result of properly
	  // invoking blockHelperMissing.
	  blockValue: function blockValue(name) {
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs(name, 0, params);

	    var blockName = this.popStack();
	    params.splice(1, 0, blockName);

	    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
	  },

	  // [ambiguousBlockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // Compiler value, before: lastHelper=value of last found helper, if any
	  // On stack, after, if no lastHelper: same as [blockValue]
	  // On stack, after, if lastHelper: value
	  ambiguousBlockValue: function ambiguousBlockValue() {
	    // We're being a bit cheeky and reusing the options value from the prior exec
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs('', 0, params, true);

	    this.flushInline();

	    var current = this.topStack();
	    params.splice(1, 0, current);

	    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
	  },

	  // [appendContent]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  //
	  // Appends the string value of `content` to the current buffer
	  appendContent: function appendContent(content) {
	    if (this.pendingContent) {
	      content = this.pendingContent + content;
	    } else {
	      this.pendingLocation = this.source.currentLocation;
	    }

	    this.pendingContent = content;
	  },

	  // [append]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Coerces `value` to a String and appends it to the current buffer.
	  //
	  // If `value` is truthy, or 0, it is coerced into a string and appended
	  // Otherwise, the empty string is appended
	  append: function append() {
	    if (this.isInline()) {
	      this.replaceStack(function (current) {
	        return [' != null ? ', current, ' : ""'];
	      });

	      this.pushSource(this.appendToBuffer(this.popStack()));
	    } else {
	      var local = this.popStack();
	      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
	      if (this.environment.isSimple) {
	        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
	      }
	    }
	  },

	  // [appendEscaped]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Escape `value` and append it to the buffer
	  appendEscaped: function appendEscaped() {
	    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
	  },

	  // [getContext]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  // Compiler value, after: lastContext=depth
	  //
	  // Set the value of the `lastContext` compiler value to the depth
	  getContext: function getContext(depth) {
	    this.lastContext = depth;
	  },

	  // [pushContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext, ...
	  //
	  // Pushes the value of the current context onto the stack.
	  pushContext: function pushContext() {
	    this.pushStackLiteral(this.contextName(this.lastContext));
	  },

	  // [lookupOnContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext[name], ...
	  //
	  // Looks up the value of `name` on the current context and pushes
	  // it onto the stack.
	  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
	    var i = 0;

	    if (!scoped && this.options.compat && !this.lastContext) {
	      // The depthed query is expected to handle the undefined logic for the root level that
	      // is implemented below, so we evaluate that directly in compat mode
	      this.push(this.depthedLookup(parts[i++]));
	    } else {
	      this.pushContext();
	    }

	    this.resolvePath('context', parts, i, falsy, strict);
	  },

	  // [lookupBlockParam]
	  //
	  // On stack, before: ...
	  // On stack, after: blockParam[name], ...
	  //
	  // Looks up the value of `parts` on the given block param and pushes
	  // it onto the stack.
	  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
	    this.useBlockParams = true;

	    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
	    this.resolvePath('context', parts, 1);
	  },

	  // [lookupData]
	  //
	  // On stack, before: ...
	  // On stack, after: data, ...
	  //
	  // Push the data lookup operator
	  lookupData: function lookupData(depth, parts, strict) {
	    if (!depth) {
	      this.pushStackLiteral('data');
	    } else {
	      this.pushStackLiteral('container.data(data, ' + depth + ')');
	    }

	    this.resolvePath('data', parts, 0, true, strict);
	  },

	  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
	    // istanbul ignore next

	    var _this = this;

	    if (this.options.strict || this.options.assumeObjects) {
	      this.push(strictLookup(this.options.strict && strict, this, parts, type));
	      return;
	    }

	    var len = parts.length;
	    for (; i < len; i++) {
	      /* eslint-disable no-loop-func */
	      this.replaceStack(function (current) {
	        var lookup = _this.nameLookup(current, parts[i], type);
	        // We want to ensure that zero and false are handled properly if the context (falsy flag)
	        // needs to have the special handling for these values.
	        if (!falsy) {
	          return [' != null ? ', lookup, ' : ', current];
	        } else {
	          // Otherwise we can use generic falsy handling
	          return [' && ', lookup];
	        }
	      });
	      /* eslint-enable no-loop-func */
	    }
	  },

	  // [resolvePossibleLambda]
	  //
	  // On stack, before: value, ...
	  // On stack, after: resolved value, ...
	  //
	  // If the `value` is a lambda, replace it on the stack by
	  // the return value of the lambda
	  resolvePossibleLambda: function resolvePossibleLambda() {
	    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
	  },

	  // [pushStringParam]
	  //
	  // On stack, before: ...
	  // On stack, after: string, currentContext, ...
	  //
	  // This opcode is designed for use in string mode, which
	  // provides the string value of a parameter along with its
	  // depth rather than resolving it immediately.
	  pushStringParam: function pushStringParam(string, type) {
	    this.pushContext();
	    this.pushString(type);

	    // If it's a subexpression, the string result
	    // will be pushed after this opcode.
	    if (type !== 'SubExpression') {
	      if (typeof string === 'string') {
	        this.pushString(string);
	      } else {
	        this.pushStackLiteral(string);
	      }
	    }
	  },

	  emptyHash: function emptyHash(omitEmpty) {
	    if (this.trackIds) {
	      this.push('{}'); // hashIds
	    }
	    if (this.stringParams) {
	      this.push('{}'); // hashContexts
	      this.push('{}'); // hashTypes
	    }
	    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
	  },
	  pushHash: function pushHash() {
	    if (this.hash) {
	      this.hashes.push(this.hash);
	    }
	    this.hash = { values: [], types: [], contexts: [], ids: [] };
	  },
	  popHash: function popHash() {
	    var hash = this.hash;
	    this.hash = this.hashes.pop();

	    if (this.trackIds) {
	      this.push(this.objectLiteral(hash.ids));
	    }
	    if (this.stringParams) {
	      this.push(this.objectLiteral(hash.contexts));
	      this.push(this.objectLiteral(hash.types));
	    }

	    this.push(this.objectLiteral(hash.values));
	  },

	  // [pushString]
	  //
	  // On stack, before: ...
	  // On stack, after: quotedString(string), ...
	  //
	  // Push a quoted version of `string` onto the stack
	  pushString: function pushString(string) {
	    this.pushStackLiteral(this.quotedString(string));
	  },

	  // [pushLiteral]
	  //
	  // On stack, before: ...
	  // On stack, after: value, ...
	  //
	  // Pushes a value onto the stack. This operation prevents
	  // the compiler from creating a temporary variable to hold
	  // it.
	  pushLiteral: function pushLiteral(value) {
	    this.pushStackLiteral(value);
	  },

	  // [pushProgram]
	  //
	  // On stack, before: ...
	  // On stack, after: program(guid), ...
	  //
	  // Push a program expression onto the stack. This takes
	  // a compile-time guid and converts it into a runtime-accessible
	  // expression.
	  pushProgram: function pushProgram(guid) {
	    if (guid != null) {
	      this.pushStackLiteral(this.programExpression(guid));
	    } else {
	      this.pushStackLiteral(null);
	    }
	  },

	  // [registerDecorator]
	  //
	  // On stack, before: hash, program, params..., ...
	  // On stack, after: ...
	  //
	  // Pops off the decorator's parameters, invokes the decorator,
	  // and inserts the decorator into the decorators list.
	  registerDecorator: function registerDecorator(paramSize, name) {
	    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
	        options = this.setupHelperArgs(name, paramSize);

	    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
	  },

	  // [invokeHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // Pops off the helper's parameters, invokes the helper,
	  // and pushes the helper's return value onto the stack.
	  //
	  // If the helper is not found, `helperMissing` is called.
	  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
	    var nonHelper = this.popStack(),
	        helper = this.setupHelper(paramSize, name),
	        simple = isSimple ? [helper.name, ' || '] : '';

	    var lookup = ['('].concat(simple, nonHelper);
	    if (!this.options.strict) {
	      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
	    }
	    lookup.push(')');

	    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
	  },

	  // [invokeKnownHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // This operation is used when the helper is known to exist,
	  // so a `helperMissing` fallback is not required.
	  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
	    var helper = this.setupHelper(paramSize, name);
	    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
	  },

	  // [invokeAmbiguous]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of disambiguation
	  //
	  // This operation is used when an expression like `{{foo}}`
	  // is provided, but we don't know at compile-time whether it
	  // is a helper or a path.
	  //
	  // This operation emits more code than the other options,
	  // and can be avoided by passing the `knownHelpers` and
	  // `knownHelpersOnly` flags at compile-time.
	  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
	    this.useRegister('helper');

	    var nonHelper = this.popStack();

	    this.emptyHash();
	    var helper = this.setupHelper(0, name, helperCall);

	    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

	    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
	    if (!this.options.strict) {
	      lookup[0] = '(helper = ';
	      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
	    }

	    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
	  },

	  // [invokePartial]
	  //
	  // On stack, before: context, ...
	  // On stack after: result of partial invocation
	  //
	  // This operation pops off a context, invokes a partial with that context,
	  // and pushes the result of the invocation back.
	  invokePartial: function invokePartial(isDynamic, name, indent) {
	    var params = [],
	        options = this.setupParams(name, 1, params);

	    if (isDynamic) {
	      name = this.popStack();
	      delete options.name;
	    }

	    if (indent) {
	      options.indent = JSON.stringify(indent);
	    }
	    options.helpers = 'helpers';
	    options.partials = 'partials';
	    options.decorators = 'container.decorators';

	    if (!isDynamic) {
	      params.unshift(this.nameLookup('partials', name, 'partial'));
	    } else {
	      params.unshift(name);
	    }

	    if (this.options.compat) {
	      options.depths = 'depths';
	    }
	    options = this.objectLiteral(options);
	    params.push(options);

	    this.push(this.source.functionCall('container.invokePartial', '', params));
	  },

	  // [assignToHash]
	  //
	  // On stack, before: value, ..., hash, ...
	  // On stack, after: ..., hash, ...
	  //
	  // Pops a value off the stack and assigns it to the current hash
	  assignToHash: function assignToHash(key) {
	    var value = this.popStack(),
	        context = undefined,
	        type = undefined,
	        id = undefined;

	    if (this.trackIds) {
	      id = this.popStack();
	    }
	    if (this.stringParams) {
	      type = this.popStack();
	      context = this.popStack();
	    }

	    var hash = this.hash;
	    if (context) {
	      hash.contexts[key] = context;
	    }
	    if (type) {
	      hash.types[key] = type;
	    }
	    if (id) {
	      hash.ids[key] = id;
	    }
	    hash.values[key] = value;
	  },

	  pushId: function pushId(type, name, child) {
	    if (type === 'BlockParam') {
	      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
	    } else if (type === 'PathExpression') {
	      this.pushString(name);
	    } else if (type === 'SubExpression') {
	      this.pushStackLiteral('true');
	    } else {
	      this.pushStackLiteral('null');
	    }
	  },

	  // HELPERS

	  compiler: JavaScriptCompiler,

	  compileChildren: function compileChildren(environment, options) {
	    var children = environment.children,
	        child = undefined,
	        compiler = undefined;

	    for (var i = 0, l = children.length; i < l; i++) {
	      child = children[i];
	      compiler = new this.compiler(); // eslint-disable-line new-cap

	      var index = this.matchExistingProgram(child);

	      if (index == null) {
	        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
	        index = this.context.programs.length;
	        child.index = index;
	        child.name = 'program' + index;
	        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
	        this.context.decorators[index] = compiler.decorators;
	        this.context.environments[index] = child;

	        this.useDepths = this.useDepths || compiler.useDepths;
	        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
	      } else {
	        child.index = index;
	        child.name = 'program' + index;

	        this.useDepths = this.useDepths || child.useDepths;
	        this.useBlockParams = this.useBlockParams || child.useBlockParams;
	      }
	    }
	  },
	  matchExistingProgram: function matchExistingProgram(child) {
	    for (var i = 0, len = this.context.environments.length; i < len; i++) {
	      var environment = this.context.environments[i];
	      if (environment && environment.equals(child)) {
	        return i;
	      }
	    }
	  },

	  programExpression: function programExpression(guid) {
	    var child = this.environment.children[guid],
	        programParams = [child.index, 'data', child.blockParams];

	    if (this.useBlockParams || this.useDepths) {
	      programParams.push('blockParams');
	    }
	    if (this.useDepths) {
	      programParams.push('depths');
	    }

	    return 'container.program(' + programParams.join(', ') + ')';
	  },

	  useRegister: function useRegister(name) {
	    if (!this.registers[name]) {
	      this.registers[name] = true;
	      this.registers.list.push(name);
	    }
	  },

	  push: function push(expr) {
	    if (!(expr instanceof Literal)) {
	      expr = this.source.wrap(expr);
	    }

	    this.inlineStack.push(expr);
	    return expr;
	  },

	  pushStackLiteral: function pushStackLiteral(item) {
	    this.push(new Literal(item));
	  },

	  pushSource: function pushSource(source) {
	    if (this.pendingContent) {
	      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
	      this.pendingContent = undefined;
	    }

	    if (source) {
	      this.source.push(source);
	    }
	  },

	  replaceStack: function replaceStack(callback) {
	    var prefix = ['('],
	        stack = undefined,
	        createdStack = undefined,
	        usedLiteral = undefined;

	    /* istanbul ignore next */
	    if (!this.isInline()) {
	      throw new _exception2['default']('replaceStack on non-inline');
	    }

	    // We want to merge the inline statement into the replacement statement via ','
	    var top = this.popStack(true);

	    if (top instanceof Literal) {
	      // Literals do not need to be inlined
	      stack = [top.value];
	      prefix = ['(', stack];
	      usedLiteral = true;
	    } else {
	      // Get or create the current stack name for use by the inline
	      createdStack = true;
	      var _name = this.incrStack();

	      prefix = ['((', this.push(_name), ' = ', top, ')'];
	      stack = this.topStack();
	    }

	    var item = callback.call(this, stack);

	    if (!usedLiteral) {
	      this.popStack();
	    }
	    if (createdStack) {
	      this.stackSlot--;
	    }
	    this.push(prefix.concat(item, ')'));
	  },

	  incrStack: function incrStack() {
	    this.stackSlot++;
	    if (this.stackSlot > this.stackVars.length) {
	      this.stackVars.push('stack' + this.stackSlot);
	    }
	    return this.topStackName();
	  },
	  topStackName: function topStackName() {
	    return 'stack' + this.stackSlot;
	  },
	  flushInline: function flushInline() {
	    var inlineStack = this.inlineStack;
	    this.inlineStack = [];
	    for (var i = 0, len = inlineStack.length; i < len; i++) {
	      var entry = inlineStack[i];
	      /* istanbul ignore if */
	      if (entry instanceof Literal) {
	        this.compileStack.push(entry);
	      } else {
	        var stack = this.incrStack();
	        this.pushSource([stack, ' = ', entry, ';']);
	        this.compileStack.push(stack);
	      }
	    }
	  },
	  isInline: function isInline() {
	    return this.inlineStack.length;
	  },

	  popStack: function popStack(wrapped) {
	    var inline = this.isInline(),
	        item = (inline ? this.inlineStack : this.compileStack).pop();

	    if (!wrapped && item instanceof Literal) {
	      return item.value;
	    } else {
	      if (!inline) {
	        /* istanbul ignore next */
	        if (!this.stackSlot) {
	          throw new _exception2['default']('Invalid stack pop');
	        }
	        this.stackSlot--;
	      }
	      return item;
	    }
	  },

	  topStack: function topStack() {
	    var stack = this.isInline() ? this.inlineStack : this.compileStack,
	        item = stack[stack.length - 1];

	    /* istanbul ignore if */
	    if (item instanceof Literal) {
	      return item.value;
	    } else {
	      return item;
	    }
	  },

	  contextName: function contextName(context) {
	    if (this.useDepths && context) {
	      return 'depths[' + context + ']';
	    } else {
	      return 'depth' + context;
	    }
	  },

	  quotedString: function quotedString(str) {
	    return this.source.quotedString(str);
	  },

	  objectLiteral: function objectLiteral(obj) {
	    return this.source.objectLiteral(obj);
	  },

	  aliasable: function aliasable(name) {
	    var ret = this.aliases[name];
	    if (ret) {
	      ret.referenceCount++;
	      return ret;
	    }

	    ret = this.aliases[name] = this.source.wrap(name);
	    ret.aliasable = true;
	    ret.referenceCount = 1;

	    return ret;
	  },

	  setupHelper: function setupHelper(paramSize, name, blockHelper) {
	    var params = [],
	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
	    var foundHelper = this.nameLookup('helpers', name, 'helper'),
	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');

	    return {
	      params: params,
	      paramsInit: paramsInit,
	      name: foundHelper,
	      callParams: [callContext].concat(params)
	    };
	  },

	  setupParams: function setupParams(helper, paramSize, params) {
	    var options = {},
	        contexts = [],
	        types = [],
	        ids = [],
	        objectArgs = !params,
	        param = undefined;

	    if (objectArgs) {
	      params = [];
	    }

	    options.name = this.quotedString(helper);
	    options.hash = this.popStack();

	    if (this.trackIds) {
	      options.hashIds = this.popStack();
	    }
	    if (this.stringParams) {
	      options.hashTypes = this.popStack();
	      options.hashContexts = this.popStack();
	    }

	    var inverse = this.popStack(),
	        program = this.popStack();

	    // Avoid setting fn and inverse if neither are set. This allows
	    // helpers to do a check for `if (options.fn)`
	    if (program || inverse) {
	      options.fn = program || 'container.noop';
	      options.inverse = inverse || 'container.noop';
	    }

	    // The parameters go on to the stack in order (making sure that they are evaluated in order)
	    // so we need to pop them off the stack in reverse order
	    var i = paramSize;
	    while (i--) {
	      param = this.popStack();
	      params[i] = param;

	      if (this.trackIds) {
	        ids[i] = this.popStack();
	      }
	      if (this.stringParams) {
	        types[i] = this.popStack();
	        contexts[i] = this.popStack();
	      }
	    }

	    if (objectArgs) {
	      options.args = this.source.generateArray(params);
	    }

	    if (this.trackIds) {
	      options.ids = this.source.generateArray(ids);
	    }
	    if (this.stringParams) {
	      options.types = this.source.generateArray(types);
	      options.contexts = this.source.generateArray(contexts);
	    }

	    if (this.options.data) {
	      options.data = 'data';
	    }
	    if (this.useBlockParams) {
	      options.blockParams = 'blockParams';
	    }
	    return options;
	  },

	  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
	    var options = this.setupParams(helper, paramSize, params);
	    options = this.objectLiteral(options);
	    if (useRegister) {
	      this.useRegister('options');
	      params.push('options');
	      return ['options=', options];
	    } else if (params) {
	      params.push(options);
	      return '';
	    } else {
	      return options;
	    }
	  }
	};

	(function () {
	  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

	  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

	  for (var i = 0, l = reservedWords.length; i < l; i++) {
	    compilerWords[reservedWords[i]] = true;
	  }
	})();

	JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
	  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
	};

	function strictLookup(requireTerminal, compiler, parts, type) {
	  var stack = compiler.popStack(),
	      i = 0,
	      len = parts.length;
	  if (requireTerminal) {
	    len--;
	  }

	  for (; i < len; i++) {
	    stack = compiler.nameLookup(stack, parts[i], type);
	  }

	  if (requireTerminal) {
	    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
	  } else {
	    return stack;
	  }
	}

	exports['default'] = JavaScriptCompiler;
	module.exports = exports['default'];

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	/* global define */
	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(394);

	var SourceNode = undefined;

	try {
	  /* istanbul ignore next */
	  if (false) {
	    // We don't support this in AMD environments. For these environments, we asusme that
	    // they are running on the browser and thus have no need for the source-map library.
	    var SourceMap = require('source-map');
	    SourceNode = SourceMap.SourceNode;
	  }
	} catch (err) {}
	/* NOP */

	/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
	if (!SourceNode) {
	  SourceNode = function SourceNode(line, column, srcFile, chunks) {
	    this.src = '';
	    if (chunks) {
	      this.add(chunks);
	    }
	  };
	  /* istanbul ignore next */
	  SourceNode.prototype = {
	    add: function add(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src += chunks;
	    },
	    prepend: function prepend(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src = chunks + this.src;
	    },
	    toStringWithSourceMap: function toStringWithSourceMap() {
	      return { code: this.toString() };
	    },
	    toString: function toString() {
	      return this.src;
	    }
	  };
	}

	function castChunk(chunk, codeGen, loc) {
	  if (_utils.isArray(chunk)) {
	    var ret = [];

	    for (var i = 0, len = chunk.length; i < len; i++) {
	      ret.push(codeGen.wrap(chunk[i], loc));
	    }
	    return ret;
	  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
	    // Handle primitives that the SourceNode will throw up on
	    return chunk + '';
	  }
	  return chunk;
	}

	function CodeGen(srcFile) {
	  this.srcFile = srcFile;
	  this.source = [];
	}

	CodeGen.prototype = {
	  isEmpty: function isEmpty() {
	    return !this.source.length;
	  },
	  prepend: function prepend(source, loc) {
	    this.source.unshift(this.wrap(source, loc));
	  },
	  push: function push(source, loc) {
	    this.source.push(this.wrap(source, loc));
	  },

	  merge: function merge() {
	    var source = this.empty();
	    this.each(function (line) {
	      source.add(['  ', line, '\n']);
	    });
	    return source;
	  },

	  each: function each(iter) {
	    for (var i = 0, len = this.source.length; i < len; i++) {
	      iter(this.source[i]);
	    }
	  },

	  empty: function empty() {
	    var loc = this.currentLocation || { start: {} };
	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
	  },
	  wrap: function wrap(chunk) {
	    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

	    if (chunk instanceof SourceNode) {
	      return chunk;
	    }

	    chunk = castChunk(chunk, this, loc);

	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
	  },

	  functionCall: function functionCall(fn, type, params) {
	    params = this.generateList(params);
	    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
	  },

	  quotedString: function quotedString(str) {
	    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
	    .replace(/\u2029/g, '\\u2029') + '"';
	  },

	  objectLiteral: function objectLiteral(obj) {
	    var pairs = [];

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        var value = castChunk(obj[key], this);
	        if (value !== 'undefined') {
	          pairs.push([this.quotedString(key), ':', value]);
	        }
	      }
	    }

	    var ret = this.generateList(pairs);
	    ret.prepend('{');
	    ret.add('}');
	    return ret;
	  },

	  generateList: function generateList(entries) {
	    var ret = this.empty();

	    for (var i = 0, len = entries.length; i < len; i++) {
	      if (i) {
	        ret.add(',');
	      }

	      ret.add(castChunk(entries[i], this));
	    }

	    return ret;
	  },

	  generateArray: function generateArray(entries) {
	    var ret = this.generateList(entries);
	    ret.prepend('[');
	    ret.add(']');

	    return ret;
	  }
	};

	exports['default'] = CodeGen;
	module.exports = exports['default'];

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable new-cap */
	'use strict';

	exports.__esModule = true;
	exports.print = print;
	exports.PrintVisitor = PrintVisitor;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _visitor = __webpack_require__(414);

	var _visitor2 = _interopRequireDefault(_visitor);

	function print(ast) {
	  return new PrintVisitor().accept(ast);
	}

	function PrintVisitor() {
	  this.padding = 0;
	}

	PrintVisitor.prototype = new _visitor2['default']();

	PrintVisitor.prototype.pad = function (string) {
	  var out = '';

	  for (var i = 0, l = this.padding; i < l; i++) {
	    out += '  ';
	  }

	  out += string + '\n';
	  return out;
	};

	PrintVisitor.prototype.Program = function (program) {
	  var out = '',
	      body = program.body,
	      i = undefined,
	      l = undefined;

	  if (program.blockParams) {
	    var blockParams = 'BLOCK PARAMS: [';
	    for (i = 0, l = program.blockParams.length; i < l; i++) {
	      blockParams += ' ' + program.blockParams[i];
	    }
	    blockParams += ' ]';
	    out += this.pad(blockParams);
	  }

	  for (i = 0, l = body.length; i < l; i++) {
	    out += this.accept(body[i]);
	  }

	  this.padding--;

	  return out;
	};

	PrintVisitor.prototype.MustacheStatement = function (mustache) {
	  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
	};
	PrintVisitor.prototype.Decorator = function (mustache) {
	  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
	};

	PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
	  var out = '';

	  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
	  this.padding++;
	  out += this.pad(this.SubExpression(block));
	  if (block.program) {
	    out += this.pad('PROGRAM:');
	    this.padding++;
	    out += this.accept(block.program);
	    this.padding--;
	  }
	  if (block.inverse) {
	    if (block.program) {
	      this.padding++;
	    }
	    out += this.pad('{{^}}');
	    this.padding++;
	    out += this.accept(block.inverse);
	    this.padding--;
	    if (block.program) {
	      this.padding--;
	    }
	  }
	  this.padding--;

	  return out;
	};

	PrintVisitor.prototype.PartialStatement = function (partial) {
	  var content = 'PARTIAL:' + partial.name.original;
	  if (partial.params[0]) {
	    content += ' ' + this.accept(partial.params[0]);
	  }
	  if (partial.hash) {
	    content += ' ' + this.accept(partial.hash);
	  }
	  return this.pad('{{> ' + content + ' }}');
	};
	PrintVisitor.prototype.PartialBlockStatement = function (partial) {
	  var content = 'PARTIAL BLOCK:' + partial.name.original;
	  if (partial.params[0]) {
	    content += ' ' + this.accept(partial.params[0]);
	  }
	  if (partial.hash) {
	    content += ' ' + this.accept(partial.hash);
	  }

	  content += ' ' + this.pad('PROGRAM:');
	  this.padding++;
	  content += this.accept(partial.program);
	  this.padding--;

	  return this.pad('{{> ' + content + ' }}');
	};

	PrintVisitor.prototype.ContentStatement = function (content) {
	  return this.pad("CONTENT[ '" + content.value + "' ]");
	};

	PrintVisitor.prototype.CommentStatement = function (comment) {
	  return this.pad("{{! '" + comment.value + "' }}");
	};

	PrintVisitor.prototype.SubExpression = function (sexpr) {
	  var params = sexpr.params,
	      paramStrings = [],
	      hash = undefined;

	  for (var i = 0, l = params.length; i < l; i++) {
	    paramStrings.push(this.accept(params[i]));
	  }

	  params = '[' + paramStrings.join(', ') + ']';

	  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';

	  return this.accept(sexpr.path) + ' ' + params + hash;
	};

	PrintVisitor.prototype.PathExpression = function (id) {
	  var path = id.parts.join('/');
	  return (id.data ? '@' : '') + 'PATH:' + path;
	};

	PrintVisitor.prototype.StringLiteral = function (string) {
	  return '"' + string.value + '"';
	};

	PrintVisitor.prototype.NumberLiteral = function (number) {
	  return 'NUMBER{' + number.value + '}';
	};

	PrintVisitor.prototype.BooleanLiteral = function (bool) {
	  return 'BOOLEAN{' + bool.value + '}';
	};

	PrintVisitor.prototype.UndefinedLiteral = function () {
	  return 'UNDEFINED';
	};

	PrintVisitor.prototype.NullLiteral = function () {
	  return 'NULL';
	};

	PrintVisitor.prototype.Hash = function (hash) {
	  var pairs = hash.pairs,
	      joinedPairs = [];

	  for (var i = 0, l = pairs.length; i < l; i++) {
	    joinedPairs.push(this.accept(pairs[i]));
	  }

	  return 'HASH{' + joinedPairs.join(', ') + '}';
	};
	PrintVisitor.prototype.HashPair = function (pair) {
	  return pair.key + '=' + this.accept(pair.value);
	};
	/* eslint-enable new-cap */

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var polyfills = __webpack_require__(421);
	var legacy = __webpack_require__(424);
	var queue = [];

	var util = __webpack_require__(263);

	function noop() {}

	var debug = noop;
	if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function debug() {
	  var m = util.format.apply(util, arguments);
	  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
	  console.error(m);
	};

	if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function () {
	    debug(queue);
	    __webpack_require__(342).equal(queue.length, 0);
	  });
	}

	module.exports = patch(__webpack_require__(422));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
	  module.exports = patch(fs);
	}

	// Always patch fs.close/closeSync, because we want to
	// retry() whenever a close happens *anywhere* in the program.
	// This is essential when multiple graceful-fs instances are
	// in play at the same time.
	module.exports.close = fs.close = function (fs$close) {
	  return function (fd, cb) {
	    return fs$close.call(fs, fd, function (err) {
	      if (!err) retry();

	      if (typeof cb === 'function') cb.apply(this, arguments);
	    });
	  };
	}(fs.close);

	module.exports.closeSync = fs.closeSync = function (fs$closeSync) {
	  return function (fd) {
	    // Note that graceful-fs also retries when fs.closeSync() fails.
	    // Looks like a bug to me, although it's probably a harmless one.
	    var rval = fs$closeSync.apply(fs, arguments);
	    retry();
	    return rval;
	  };
	}(fs.closeSync);

	function patch(fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs);
	  fs.gracefulify = patch;
	  fs.FileReadStream = ReadStream; // Legacy name.
	  fs.FileWriteStream = WriteStream; // Legacy name.
	  fs.createReadStream = createReadStream;
	  fs.createWriteStream = createWriteStream;
	  var fs$readFile = fs.readFile;
	  fs.readFile = readFile;
	  function readFile(path, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;

	    return go$readFile(path, options, cb);

	    function go$readFile(path, options, cb) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  var fs$writeFile = fs.writeFile;
	  fs.writeFile = writeFile;
	  function writeFile(path, data, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;

	    return go$writeFile(path, data, options, cb);

	    function go$writeFile(path, data, options, cb) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  var fs$appendFile = fs.appendFile;
	  if (fs$appendFile) fs.appendFile = appendFile;
	  function appendFile(path, data, options, cb) {
	    if (typeof options === 'function') cb = options, options = null;

	    return go$appendFile(path, data, options, cb);

	    function go$appendFile(path, data, options, cb) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  var fs$readdir = fs.readdir;
	  fs.readdir = readdir;
	  function readdir(path, cb) {
	    return go$readdir(path, cb);

	    function go$readdir() {
	      return fs$readdir(path, function (err, files) {
	        if (files && files.sort) files.sort(); // Backwards compatibility with graceful-fs.

	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [path, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs);
	    ReadStream = legStreams.ReadStream;
	    WriteStream = legStreams.WriteStream;
	  }

	  var fs$ReadStream = fs.ReadStream;
	  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
	  ReadStream.prototype.open = ReadStream$open;

	  var fs$WriteStream = fs.WriteStream;
	  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
	  WriteStream.prototype.open = WriteStream$open;

	  fs.ReadStream = ReadStream;
	  fs.WriteStream = WriteStream;

	  function ReadStream(path, options) {
	    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
	  }

	  function ReadStream$open() {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose) that.destroy();

	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	        that.read();
	      }
	    });
	  }

	  function WriteStream(path, options) {
	    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
	  }

	  function WriteStream$open() {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy();
	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	      }
	    });
	  }

	  function createReadStream(path, options) {
	    return new ReadStream(path, options);
	  }

	  function createWriteStream(path, options) {
	    return new WriteStream(path, options);
	  }

	  var fs$open = fs.open;
	  fs.open = open;
	  function open(path, flags, mode, cb) {
	    if (typeof mode === 'function') cb = mode, mode = null;

	    return go$open(path, flags, mode, cb);

	    function go$open(path, flags, mode, cb) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb]]);else {
	          if (typeof cb === 'function') cb.apply(this, arguments);
	          retry();
	        }
	      });
	    }
	  }

	  return fs;
	}

	function enqueue(elem) {
	  debug('ENQUEUE', elem[0].name, elem[1]);
	  queue.push(elem);
	}

	function retry() {
	  var elem = queue.shift();
	  if (elem) {
	    debug('RETRY', elem[0].name, elem[1]);
	    elem[0].apply(null, elem[1]);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var fs = __webpack_require__(422);
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	var origCwd = process.cwd;
	var cwd = null;
	process.cwd = function () {
	  if (!cwd) cwd = origCwd.call(process);
	  return cwd;
	};
	try {
	  process.cwd();
	} catch (er) {}

	var chdir = process.chdir;
	process.chdir = function (d) {
	  cwd = null;
	  chdir.call(process, d);
	};

	module.exports = patch;

	function patch(fs) {
	  // (re-)implement some things that are known busted or missing.

	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs);
	  }

	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs);
	  }

	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.

	  fs.chown = chownFix(fs.chown);
	  fs.fchown = chownFix(fs.fchown);
	  fs.lchown = chownFix(fs.lchown);

	  fs.chmod = chownFix(fs.chmod);
	  fs.fchmod = chownFix(fs.fchmod);
	  fs.lchmod = chownFix(fs.lchmod);

	  fs.chownSync = chownFixSync(fs.chownSync);
	  fs.fchownSync = chownFixSync(fs.fchownSync);
	  fs.lchownSync = chownFixSync(fs.lchownSync);

	  fs.chmodSync = chownFix(fs.chmodSync);
	  fs.fchmodSync = chownFix(fs.fchmodSync);
	  fs.lchmodSync = chownFix(fs.lchmodSync);

	  // if lchmod/lchown do not exist, then make them no-ops
	  if (!fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      process.nextTick(cb);
	    };
	    fs.lchmodSync = function () {};
	  }
	  if (!fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      process.nextTick(cb);
	    };
	    fs.lchownSync = function () {};
	  }

	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 1 second.
	  if (process.platform === "win32") {
	    fs.rename = function (fs$rename) {
	      return function (from, to, cb) {
	        var start = Date.now();
	        fs$rename(from, to, function CB(er) {
	          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 1000) {
	            return fs$rename(from, to, CB);
	          }
	          if (cb) cb(er);
	        });
	      };
	    }(fs.rename);
	  }

	  // if read() returns EAGAIN, then just try it again.
	  fs.read = function (fs$read) {
	    return function (fd, buffer, offset, length, position, callback_) {
	      var _callback;
	      if (callback_ && typeof callback_ === 'function') {
	        var eagCounter = 0;
	        _callback = function callback(er, _, __) {
	          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter++;
	            return fs$read.call(fs, fd, buffer, offset, length, position, _callback);
	          }
	          callback_.apply(this, arguments);
	        };
	      }
	      return fs$read.call(fs, fd, buffer, offset, length, position, _callback);
	    };
	  }(fs.read);

	  fs.readSync = function (fs$readSync) {
	    return function (fd, buffer, offset, length, position) {
	      var eagCounter = 0;
	      while (true) {
	        try {
	          return fs$readSync.call(fs, fd, buffer, offset, length, position);
	        } catch (er) {
	          if (er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter++;
	            continue;
	          }
	          throw er;
	        }
	      }
	    };
	  }(fs.readSync);
	}

	function patchLchmod(fs) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop;
	    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
	      if (err) {
	        callback(err);
	        return;
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function (err2) {
	          callback(err || err2);
	        });
	      });
	    });
	  };

	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var threw = true;
	    var ret;
	    try {
	      ret = fs.fchmodSync(fd, mode);
	      threw = false;
	    } finally {
	      if (threw) {
	        try {
	          fs.closeSync(fd);
	        } catch (er) {}
	      } else {
	        fs.closeSync(fd);
	      }
	    }
	    return ret;
	  };
	}

	function patchLutimes(fs) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop;
	        if (er) return cb(er);
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2);
	          });
	        });
	      });
	    };

	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK);
	      var ret;
	      var threw = true;
	      try {
	        ret = fs.futimesSync(fd, at, mt);
	        threw = false;
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd);
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd);
	        }
	      }
	      return ret;
	    };
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) {
	      process.nextTick(cb);
	    };
	    fs.lutimesSync = function () {};
	  }
	}

	function chownFix(orig) {
	  if (!orig) return orig;
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null;
	      cb(er, res);
	    });
	  };
	}

	function chownFixSync(orig) {
	  if (!orig) return orig;
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid);
	    } catch (er) {
	      if (!chownErOk(er)) throw er;
	    }
	  };
	}

	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk(er) {
	  if (!er) return true;

	  if (er.code === "ENOSYS") return true;

	  var nonroot = !process.getuid || process.getuid() !== 0;
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM") return true;
	  }

	  return false;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	module.exports = clone(fs);

	function clone(obj) {
	  if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return obj;

	  if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };else var copy = Object.create(null);

	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
	  });

	  return copy;
	}

/***/ },
/* 423 */,
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var Stream = __webpack_require__(239).Stream;

	module.exports = legacy;

	function legacy(fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  };

	  function ReadStream(path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

	    Stream.call(this);

	    var self = this;

	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;

	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.encoding) this.setEncoding(this.encoding);

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }

	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }

	      this.pos = this.start;
	    }

	    if (this.fd !== null) {
	      process.nextTick(function () {
	        self._read();
	      });
	      return;
	    }

	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }

	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    });
	  }

	  function WriteStream(path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

	    Stream.call(this);

	    this.path = path;
	    this.fd = null;
	    this.writable = true;

	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }

	      this.pos = this.start;
	    }

	    this.busy = false;
	    this._queue = [];

	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/*
	 * Copyright (c) 2014, Yahoo Inc. All rights reserved.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */

	'use strict';

	exports.assign = Object.assign || __webpack_require__(426);
	exports.passError = passError;
	exports.passValue = passValue;

	// -----------------------------------------------------------------------------

	function passError(callback) {
	    return function (reason) {
	        setImmediate(function () {
	            callback(reason);
	        });
	    };
	}

	function passValue(callback) {
	    return function (value) {
	        setImmediate(function () {
	            callback(null, value);
	        });
	    };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate))

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var defineProperties = __webpack_require__(427);

	var implementation = __webpack_require__(431);
	var getPolyfill = __webpack_require__(435);
	var shim = __webpack_require__(436);

	var polyfill = getPolyfill();

	defineProperties(polyfill, {
		implementation: implementation,
		getPolyfill: getPolyfill,
		shim: shim
	});

	module.exports = polyfill;

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var keys = __webpack_require__(428);
	var foreach = __webpack_require__(430);
	var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';

	var toStr = Object.prototype.toString;

	var isFunction = function isFunction(fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};

	var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
			/* eslint-disable no-unused-vars, no-restricted-syntax */
			for (var _ in obj) {
				return false;
			}
			/* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) {
			/* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

	var defineProperty = function defineProperty(object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};

	var defineProperties = function defineProperties(object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};

	defineProperties.supportsDescriptors = !!supportsDescriptors;

	module.exports = defineProperties;

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// modified from https://github.com/es-shims/es5-shim

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(429);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
	var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = function () {
		/* global window */
		if (typeof window === 'undefined') {
			return false;
		}
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}();
	var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	var keysShim = function keys(object) {
		var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};

	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2);
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};

	module.exports = keysShim;

/***/ },
/* 429 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var toStr = Object.prototype.toString;

	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};

/***/ },
/* 430 */
/***/ function(module, exports) {

	'use strict';

	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;

	module.exports = function forEach(obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// modified from https://github.com/es-shims/es6-shim

	var keys = __webpack_require__(428);
	var bind = __webpack_require__(432);
	var canBeObject = function canBeObject(obj) {
		return typeof obj !== 'undefined' && obj !== null;
	};
	var hasSymbols = __webpack_require__(434)();
	var toObject = Object;
	var push = bind.call(Function.call, Array.prototype.push);
	var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
	var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

	module.exports = function assign(target, source1) {
		if (!canBeObject(target)) {
			throw new TypeError('target must be an object');
		}
		var objTarget = toObject(target);
		var s, source, i, props, syms, value, key;
		for (s = 1; s < arguments.length; ++s) {
			source = toObject(arguments[s]);
			props = keys(source);
			var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
			if (getSymbols) {
				syms = getSymbols(source);
				for (i = 0; i < syms.length; ++i) {
					key = syms[i];
					if (propIsEnumerable(source, key)) {
						push(props, key);
					}
				}
			}
			for (i = 0; i < props.length; ++i) {
				key = props[i];
				value = source[key];
				if (propIsEnumerable(source, key)) {
					objTarget[key] = value;
				}
			}
		}
		return objTarget;
	};

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var implementation = __webpack_require__(433);

	module.exports = Function.prototype.bind || implementation;

/***/ },
/* 433 */
/***/ function(module, exports) {

	'use strict';

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function binder() {
	        if (this instanceof bound) {
	            var result = target.apply(this, args.concat(slice.call(arguments)));
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(that, args.concat(slice.call(arguments)));
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var keys = __webpack_require__(428);

	module.exports = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
			return false;
		}
		if (_typeof(Symbol.iterator) === 'symbol') {
			return true;
		}

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') {
			return false;
		}

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
			return false;
		}
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
			return false;
		}

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) {
			return false;
		}
		if (keys(obj).length !== 0) {
			return false;
		}
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
			return false;
		}

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
			return false;
		}

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) {
			return false;
		}

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
			return false;
		}

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) {
				return false;
			}
		}

		return true;
	};

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var implementation = __webpack_require__(431);

	var lacksProperEnumerationOrder = function lacksProperEnumerationOrder() {
		if (!Object.assign) {
			return false;
		}
		// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
		// note: this does not detect the bug unless there's 20 characters
		var str = 'abcdefghijklmnopqrst';
		var letters = str.split('');
		var map = {};
		for (var i = 0; i < letters.length; ++i) {
			map[letters[i]] = letters[i];
		}
		var obj = Object.assign({}, map);
		var actual = '';
		for (var k in obj) {
			actual += k;
		}
		return str !== actual;
	};

	var assignHasPendingExceptions = function assignHasPendingExceptions() {
		if (!Object.assign || !Object.preventExtensions) {
			return false;
		}
		// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
		// which is 72% slower than our shim, and Firefox 40's native implementation.
		var thrower = Object.preventExtensions({ 1: 2 });
		try {
			Object.assign(thrower, 'xy');
		} catch (e) {
			return thrower[1] === 'y';
		}
		return false;
	};

	module.exports = function getPolyfill() {
		if (!Object.assign) {
			return implementation;
		}
		if (lacksProperEnumerationOrder()) {
			return implementation;
		}
		if (assignHasPendingExceptions()) {
			return implementation;
		}
		return Object.assign;
	};

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var define = __webpack_require__(427);
	var getPolyfill = __webpack_require__(435);

	module.exports = function shimAssign() {
		var polyfill = getPolyfill();
		define(Object, { assign: polyfill }, { assign: function assign() {
				return Object.assign !== polyfill;
			} });
		return polyfill;
	};

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var Passport = __webpack_require__(438),
	    SessionStrategy = __webpack_require__(439);

	/**
	 * Export default singleton.
	 *
	 * @api public
	 */
	exports = module.exports = new Passport();

	/**
	 * Expose constructors.
	 */
	exports.Passport = exports.Authenticator = Passport;
	exports.Strategy = __webpack_require__(441);

	/**
	 * Expose strategies.
	 */
	exports.strategies = {};
	exports.strategies.SessionStrategy = SessionStrategy;

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var SessionStrategy = __webpack_require__(439);

	/**
	 * `Authenticator` constructor.
	 *
	 * @api public
	 */
	function Authenticator() {
	  this._key = 'passport';
	  this._strategies = {};
	  this._serializers = [];
	  this._deserializers = [];
	  this._infoTransformers = [];
	  this._framework = null;
	  this._userProperty = 'user';

	  this.init();
	}

	/**
	 * Initialize authenticator.
	 *
	 * @api protected
	 */
	Authenticator.prototype.init = function () {
	  this.framework(__webpack_require__(443)());
	  this.use(new SessionStrategy());
	};

	/**
	 * Utilize the given `strategy` with optional `name`, overridding the strategy's
	 * default name.
	 *
	 * Examples:
	 *
	 *     passport.use(new TwitterStrategy(...));
	 *
	 *     passport.use('api', new http.BasicStrategy(...));
	 *
	 * @param {String|Strategy} name
	 * @param {Strategy} strategy
	 * @return {Authenticator} for chaining
	 * @api public
	 */
	Authenticator.prototype.use = function (name, strategy) {
	  if (!strategy) {
	    strategy = name;
	    name = strategy.name;
	  }
	  if (!name) {
	    throw new Error('Authentication strategies must have a name');
	  }

	  this._strategies[name] = strategy;
	  return this;
	};

	/**
	 * Un-utilize the `strategy` with given `name`.
	 *
	 * In typical applications, the necessary authentication strategies are static,
	 * configured once and always available.  As such, there is often no need to
	 * invoke this function.
	 *
	 * However, in certain situations, applications may need dynamically configure
	 * and de-configure authentication strategies.  The `use()`/`unuse()`
	 * combination satisfies these scenarios.
	 *
	 * Examples:
	 *
	 *     passport.unuse('legacy-api');
	 *
	 * @param {String} name
	 * @return {Authenticator} for chaining
	 * @api public
	 */
	Authenticator.prototype.unuse = function (name) {
	  delete this._strategies[name];
	  return this;
	};

	/**
	 * Setup Passport to be used under framework.
	 *
	 * By default, Passport exposes middleware that operate using Connect-style
	 * middleware using a `fn(req, res, next)` signature.  Other popular frameworks
	 * have different expectations, and this function allows Passport to be adapted
	 * to operate within such environments.
	 *
	 * If you are using a Connect-compatible framework, including Express, there is
	 * no need to invoke this function.
	 *
	 * Examples:
	 *
	 *     passport.framework(require('hapi-passport')());
	 *
	 * @param {Object} name
	 * @return {Authenticator} for chaining
	 * @api public
	 */
	Authenticator.prototype.framework = function (fw) {
	  this._framework = fw;
	  return this;
	};

	/**
	 * Passport's primary initialization middleware.
	 *
	 * This middleware must be in use by the Connect/Express application for
	 * Passport to operate.
	 *
	 * Options:
	 *   - `userProperty`  Property to set on `req` upon login, defaults to _user_
	 *
	 * Examples:
	 *
	 *     app.use(passport.initialize());
	 *
	 *     app.use(passport.initialize({ userProperty: 'currentUser' }));
	 *
	 * @param {Object} options
	 * @return {Function} middleware
	 * @api public
	 */
	Authenticator.prototype.initialize = function (options) {
	  options = options || {};
	  this._userProperty = options.userProperty || 'user';

	  return this._framework.initialize(this, options);
	};

	/**
	 * Middleware that will authenticate a request using the given `strategy` name,
	 * with optional `options` and `callback`.
	 *
	 * Examples:
	 *
	 *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' })(req, res);
	 *
	 *     passport.authenticate('local', function(err, user) {
	 *       if (!user) { return res.redirect('/login'); }
	 *       res.end('Authenticated!');
	 *     })(req, res);
	 *
	 *     passport.authenticate('basic', { session: false })(req, res);
	 *
	 *     app.get('/auth/twitter', passport.authenticate('twitter'), function(req, res) {
	 *       // request will be redirected to Twitter
	 *     });
	 *     app.get('/auth/twitter/callback', passport.authenticate('twitter'), function(req, res) {
	 *       res.json(req.user);
	 *     });
	 *
	 * @param {String} strategy
	 * @param {Object} options
	 * @param {Function} callback
	 * @return {Function} middleware
	 * @api public
	 */
	Authenticator.prototype.authenticate = function (strategy, options, callback) {
	  return this._framework.authenticate(this, strategy, options, callback);
	};

	/**
	 * Middleware that will authorize a third-party account using the given
	 * `strategy` name, with optional `options`.
	 *
	 * If authorization is successful, the result provided by the strategy's verify
	 * callback will be assigned to `req.account`.  The existing login session and
	 * `req.user` will be unaffected.
	 *
	 * This function is particularly useful when connecting third-party accounts
	 * to the local account of a user that is currently authenticated.
	 *
	 * Examples:
	 *
	 *    passport.authorize('twitter-authz', { failureRedirect: '/account' });
	 *
	 * @param {String} strategy
	 * @param {Object} options
	 * @return {Function} middleware
	 * @api public
	 */
	Authenticator.prototype.authorize = function (strategy, options, callback) {
	  options = options || {};
	  options.assignProperty = 'account';

	  var fn = this._framework.authorize || this._framework.authenticate;
	  return fn(this, strategy, options, callback);
	};

	/**
	 * Middleware that will restore login state from a session.
	 *
	 * Web applications typically use sessions to maintain login state between
	 * requests.  For example, a user will authenticate by entering credentials into
	 * a form which is submitted to the server.  If the credentials are valid, a
	 * login session is established by setting a cookie containing a session
	 * identifier in the user's web browser.  The web browser will send this cookie
	 * in subsequent requests to the server, allowing a session to be maintained.
	 *
	 * If sessions are being utilized, and a login session has been established,
	 * this middleware will populate `req.user` with the current user.
	 *
	 * Note that sessions are not strictly required for Passport to operate.
	 * However, as a general rule, most web applications will make use of sessions.
	 * An exception to this rule would be an API server, which expects each HTTP
	 * request to provide credentials in an Authorization header.
	 *
	 * Examples:
	 *
	 *     app.use(connect.cookieParser());
	 *     app.use(connect.session({ secret: 'keyboard cat' }));
	 *     app.use(passport.initialize());
	 *     app.use(passport.session());
	 *
	 * Options:
	 *   - `pauseStream`      Pause the request stream before deserializing the user
	 *                        object from the session.  Defaults to _false_.  Should
	 *                        be set to true in cases where middleware consuming the
	 *                        request body is configured after passport and the
	 *                        deserializeUser method is asynchronous.
	 *
	 * @param {Object} options
	 * @return {Function} middleware
	 * @api public
	 */
	Authenticator.prototype.session = function (options) {
	  return this.authenticate('session', options);
	};

	/**
	 * Registers a function used to serialize user objects into the session.
	 *
	 * Examples:
	 *
	 *     passport.serializeUser(function(user, done) {
	 *       done(null, user.id);
	 *     });
	 *
	 * @api public
	 */
	Authenticator.prototype.serializeUser = function (fn, req, done) {
	  if (typeof fn === 'function') {
	    return this._serializers.push(fn);
	  }

	  // private implementation that traverses the chain of serializers, attempting
	  // to serialize a user
	  var user = fn;

	  // For backwards compatibility
	  if (typeof req === 'function') {
	    done = req;
	    req = undefined;
	  }

	  var stack = this._serializers;
	  (function pass(i, err, obj) {
	    // serializers use 'pass' as an error to skip processing
	    if ('pass' === err) {
	      err = undefined;
	    }
	    // an error or serialized object was obtained, done
	    if (err || obj || obj === 0) {
	      return done(err, obj);
	    }

	    var layer = stack[i];
	    if (!layer) {
	      return done(new Error('Failed to serialize user into session'));
	    }

	    function serialized(e, o) {
	      pass(i + 1, e, o);
	    }

	    try {
	      var arity = layer.length;
	      if (arity == 3) {
	        layer(req, user, serialized);
	      } else {
	        layer(user, serialized);
	      }
	    } catch (e) {
	      return done(e);
	    }
	  })(0);
	};

	/**
	 * Registers a function used to deserialize user objects out of the session.
	 *
	 * Examples:
	 *
	 *     passport.deserializeUser(function(id, done) {
	 *       User.findById(id, function (err, user) {
	 *         done(err, user);
	 *       });
	 *     });
	 *
	 * @api public
	 */
	Authenticator.prototype.deserializeUser = function (fn, req, done) {
	  if (typeof fn === 'function') {
	    return this._deserializers.push(fn);
	  }

	  // private implementation that traverses the chain of deserializers,
	  // attempting to deserialize a user
	  var obj = fn;

	  // For backwards compatibility
	  if (typeof req === 'function') {
	    done = req;
	    req = undefined;
	  }

	  var stack = this._deserializers;
	  (function pass(i, err, user) {
	    // deserializers use 'pass' as an error to skip processing
	    if ('pass' === err) {
	      err = undefined;
	    }
	    // an error or deserialized user was obtained, done
	    if (err || user) {
	      return done(err, user);
	    }
	    // a valid user existed when establishing the session, but that user has
	    // since been removed
	    if (user === null || user === false) {
	      return done(null, false);
	    }

	    var layer = stack[i];
	    if (!layer) {
	      return done(new Error('Failed to deserialize user out of session'));
	    }

	    function deserialized(e, u) {
	      pass(i + 1, e, u);
	    }

	    try {
	      var arity = layer.length;
	      if (arity == 3) {
	        layer(req, obj, deserialized);
	      } else {
	        layer(obj, deserialized);
	      }
	    } catch (e) {
	      return done(e);
	    }
	  })(0);
	};

	/**
	 * Registers a function used to transform auth info.
	 *
	 * In some circumstances authorization details are contained in authentication
	 * credentials or loaded as part of verification.
	 *
	 * For example, when using bearer tokens for API authentication, the tokens may
	 * encode (either directly or indirectly in a database), details such as scope
	 * of access or the client to which the token was issued.
	 *
	 * Such authorization details should be enforced separately from authentication.
	 * Because Passport deals only with the latter, this is the responsiblity of
	 * middleware or routes further along the chain.  However, it is not optimal to
	 * decode the same data or execute the same database query later.  To avoid
	 * this, Passport accepts optional `info` along with the authenticated `user`
	 * in a strategy's `success()` action.  This info is set at `req.authInfo`,
	 * where said later middlware or routes can access it.
	 *
	 * Optionally, applications can register transforms to proccess this info,
	 * which take effect prior to `req.authInfo` being set.  This is useful, for
	 * example, when the info contains a client ID.  The transform can load the
	 * client from the database and include the instance in the transformed info,
	 * allowing the full set of client properties to be convieniently accessed.
	 *
	 * If no transforms are registered, `info` supplied by the strategy will be left
	 * unmodified.
	 *
	 * Examples:
	 *
	 *     passport.transformAuthInfo(function(info, done) {
	 *       Client.findById(info.clientID, function (err, client) {
	 *         info.client = client;
	 *         done(err, info);
	 *       });
	 *     });
	 *
	 * @api public
	 */
	Authenticator.prototype.transformAuthInfo = function (fn, req, done) {
	  if (typeof fn === 'function') {
	    return this._infoTransformers.push(fn);
	  }

	  // private implementation that traverses the chain of transformers,
	  // attempting to transform auth info
	  var info = fn;

	  // For backwards compatibility
	  if (typeof req === 'function') {
	    done = req;
	    req = undefined;
	  }

	  var stack = this._infoTransformers;
	  (function pass(i, err, tinfo) {
	    // transformers use 'pass' as an error to skip processing
	    if ('pass' === err) {
	      err = undefined;
	    }
	    // an error or transformed info was obtained, done
	    if (err || tinfo) {
	      return done(err, tinfo);
	    }

	    var layer = stack[i];
	    if (!layer) {
	      // if no transformers are registered (or they all pass), the default
	      // behavior is to use the un-transformed info as-is
	      return done(null, info);
	    }

	    function transformed(e, t) {
	      pass(i + 1, e, t);
	    }

	    try {
	      var arity = layer.length;
	      if (arity == 1) {
	        // sync
	        var t = layer(info);
	        transformed(null, t);
	      } else if (arity == 3) {
	        layer(req, info, transformed);
	      } else {
	        layer(info, transformed);
	      }
	    } catch (e) {
	      return done(e);
	    }
	  })(0);
	};

	/**
	 * Return strategy with given `name`. 
	 *
	 * @param {String} name
	 * @return {Strategy}
	 * @api private
	 */
	Authenticator.prototype._strategy = function (name) {
	  return this._strategies[name];
	};

	/**
	 * Expose `Authenticator`.
	 */
	module.exports = Authenticator;

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var pause = __webpack_require__(440),
	    util = __webpack_require__(263),
	    Strategy = __webpack_require__(441);

	/**
	 * `SessionStrategy` constructor.
	 *
	 * @api public
	 */
	function SessionStrategy() {
	  Strategy.call(this);
	  this.name = 'session';
	}

	/**
	 * Inherit from `Strategy`.
	 */
	util.inherits(SessionStrategy, Strategy);

	/**
	 * Authenticate request based on the current session state.
	 *
	 * The session authentication strategy uses the session to restore any login
	 * state across requests.  If a login session has been established, `req.user`
	 * will be populated with the current user.
	 *
	 * This strategy is registered automatically by Passport.
	 *
	 * @param {Object} req
	 * @param {Object} options
	 * @api protected
	 */
	SessionStrategy.prototype.authenticate = function (req, options) {
	  if (!req._passport) {
	    return this.error(new Error('passport.initialize() middleware not in use'));
	  }
	  options = options || {};

	  var self = this,
	      su;
	  if (req._passport.session) {
	    su = req._passport.session.user;
	  }

	  if (su || su === 0) {
	    // NOTE: Stream pausing is desirable in the case where later middleware is
	    //       listening for events emitted from request.  For discussion on the
	    //       matter, refer to: https://github.com/jaredhanson/passport/pull/106

	    var paused = options.pauseStream ? pause(req) : null;
	    req._passport.instance.deserializeUser(su, req, function (err, user) {
	      if (err) {
	        return self.error(err);
	      }
	      if (!user) {
	        delete req._passport.session.user;
	        self.pass();
	        if (paused) {
	          paused.resume();
	        }
	        return;
	      }
	      var property = req._passport.instance._userProperty || 'user';
	      req[property] = user;
	      self.pass();
	      if (paused) {
	        paused.resume();
	      }
	    });
	  } else {
	    self.pass();
	  }
	};

	/**
	 * Expose `SessionStrategy`.
	 */
	module.exports = SessionStrategy;

/***/ },
/* 440 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (obj) {
	  var onData,
	      onEnd,
	      events = [];

	  // buffer data
	  obj.on('data', onData = function onData(data, encoding) {
	    events.push(['data', data, encoding]);
	  });

	  // buffer end
	  obj.on('end', onEnd = function onEnd(data, encoding) {
	    events.push(['end', data, encoding]);
	  });

	  return {
	    end: function end() {
	      obj.removeListener('data', onData);
	      obj.removeListener('end', onEnd);
	    },
	    resume: function resume() {
	      this.end();
	      for (var i = 0, len = events.length; i < len; ++i) {
	        obj.emit.apply(obj, events[i]);
	      }
	    }
	  };
	};

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var Strategy = __webpack_require__(442);

	/**
	 * Expose `Strategy` directly from package.
	 */
	exports = module.exports = Strategy;

	/**
	 * Export constructors.
	 */
	exports.Strategy = Strategy;

/***/ },
/* 442 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Creates an instance of `Strategy`.
	 *
	 * @constructor
	 * @api public
	 */
	function Strategy() {}

	/**
	 * Authenticate request.
	 *
	 * This function must be overridden by subclasses.  In abstract form, it always
	 * throws an exception.
	 *
	 * @param {Object} req The request to authenticate.
	 * @param {Object} [options] Strategy-specific options.
	 * @api public
	 */
	Strategy.prototype.authenticate = function (req, options) {
	  throw new Error('Strategy#authenticate must be overridden by subclass');
	};

	/**
	 * Expose `Strategy`.
	 */
	module.exports = Strategy;

/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var initialize = __webpack_require__(444),
	    authenticate = __webpack_require__(445);

	/**
	 * Framework support for Connect/Express.
	 *
	 * This module provides support for using Passport with Express.  It exposes
	 * middleware that conform to the `fn(req, res, next)` signature and extends
	 * Node's built-in HTTP request object with useful authentication-related
	 * functions.
	 *
	 * @return {Object}
	 * @api protected
	 */
	exports = module.exports = function () {

	  // HTTP extensions.
	  exports.__monkeypatchNode();

	  return {
	    initialize: initialize,
	    authenticate: authenticate
	  };
	};

	exports.__monkeypatchNode = function () {
	  var http = __webpack_require__(293);
	  var IncomingMessageExt = __webpack_require__(446);

	  http.IncomingMessage.prototype.login = http.IncomingMessage.prototype.logIn = IncomingMessageExt.logIn;
	  http.IncomingMessage.prototype.logout = http.IncomingMessage.prototype.logOut = IncomingMessageExt.logOut;
	  http.IncomingMessage.prototype.isAuthenticated = IncomingMessageExt.isAuthenticated;
	  http.IncomingMessage.prototype.isUnauthenticated = IncomingMessageExt.isUnauthenticated;
	};

/***/ },
/* 444 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Passport initialization.
	 *
	 * Intializes Passport for incoming requests, allowing authentication strategies
	 * to be applied.
	 *
	 * If sessions are being utilized, applications must set up Passport with
	 * functions to serialize a user into and out of a session.  For example, a
	 * common pattern is to serialize just the user ID into the session (due to the
	 * fact that it is desirable to store the minimum amount of data in a session).
	 * When a subsequent request arrives for the session, the full User object can
	 * be loaded from the database by ID.
	 *
	 * Note that additional middleware is required to persist login state, so we
	 * must use the `connect.session()` middleware _before_ `passport.initialize()`.
	 *
	 * If sessions are being used, this middleware must be in use by the
	 * Connect/Express application for Passport to operate.  If the application is
	 * entirely stateless (not using sessions), this middleware is not necessary,
	 * but its use will not have any adverse impact.
	 *
	 * Examples:
	 *
	 *     app.use(connect.cookieParser());
	 *     app.use(connect.session({ secret: 'keyboard cat' }));
	 *     app.use(passport.initialize());
	 *     app.use(passport.session());
	 *
	 *     passport.serializeUser(function(user, done) {
	 *       done(null, user.id);
	 *     });
	 *
	 *     passport.deserializeUser(function(id, done) {
	 *       User.findById(id, function (err, user) {
	 *         done(err, user);
	 *       });
	 *     });
	 *
	 * @return {Function}
	 * @api public
	 */
	module.exports = function initialize(passport) {

	  return function initialize(req, res, next) {
	    req._passport = {};
	    req._passport.instance = passport;

	    if (req.session && req.session[passport._key]) {
	      // load data from existing session
	      req._passport.session = req.session[passport._key];
	    }

	    next();
	  };
	};

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var http = __webpack_require__(293),
	    IncomingMessageExt = __webpack_require__(446),
	    AuthenticationError = __webpack_require__(447);

	/**
	 * Authenticates requests.
	 *
	 * Applies the `name`ed strategy (or strategies) to the incoming request, in
	 * order to authenticate the request.  If authentication is successful, the user
	 * will be logged in and populated at `req.user` and a session will be
	 * established by default.  If authentication fails, an unauthorized response
	 * will be sent.
	 *
	 * Options:
	 *   - `session`          Save login state in session, defaults to _true_
	 *   - `successRedirect`  After successful login, redirect to given URL
	 *   - `failureRedirect`  After failed login, redirect to given URL
	 *   - `assignProperty`   Assign the object provided by the verify callback to given property
	 *
	 * An optional `callback` can be supplied to allow the application to overrride
	 * the default manner in which authentication attempts are handled.  The
	 * callback has the following signature, where `user` will be set to the
	 * authenticated user on a successful authentication attempt, or `false`
	 * otherwise.  An optional `info` argument will be passed, containing additional
	 * details provided by the strategy's verify callback.
	 *
	 *     app.get('/protected', function(req, res, next) {
	 *       passport.authenticate('local', function(err, user, info) {
	 *         if (err) { return next(err) }
	 *         if (!user) { return res.redirect('/signin') }
	 *         res.redirect('/account');
	 *       })(req, res, next);
	 *     });
	 *
	 * Note that if a callback is supplied, it becomes the application's
	 * responsibility to log-in the user, establish a session, and otherwise perform
	 * the desired operations.
	 *
	 * Examples:
	 *
	 *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });
	 *
	 *     passport.authenticate('basic', { session: false });
	 *
	 *     passport.authenticate('twitter');
	 *
	 * @param {String|Array} name
	 * @param {Object} options
	 * @param {Function} callback
	 * @return {Function}
	 * @api public
	 */
	module.exports = function authenticate(passport, name, options, callback) {
	  if (typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	  options = options || {};

	  var multi = true;

	  // Cast `name` to an array, allowing authentication to pass through a chain of
	  // strategies.  The first strategy to succeed, redirect, or error will halt
	  // the chain.  Authentication failures will proceed through each strategy in
	  // series, ultimately failing if all strategies fail.
	  //
	  // This is typically used on API endpoints to allow clients to authenticate
	  // using their preferred choice of Basic, Digest, token-based schemes, etc.
	  // It is not feasible to construct a chain of multiple strategies that involve
	  // redirection (for example both Facebook and Twitter), since the first one to
	  // redirect will halt the chain.
	  if (!Array.isArray(name)) {
	    name = [name];
	    multi = false;
	  }

	  return function authenticate(req, res, next) {
	    if (http.IncomingMessage.prototype.logIn && http.IncomingMessage.prototype.logIn !== IncomingMessageExt.logIn) {
	      __webpack_require__(443).__monkeypatchNode();
	    }

	    // accumulator for failures from each strategy in the chain
	    var failures = [];

	    function allFailed() {
	      if (callback) {
	        if (!multi) {
	          return callback(null, false, failures[0].challenge, failures[0].status);
	        } else {
	          var challenges = failures.map(function (f) {
	            return f.challenge;
	          });
	          var statuses = failures.map(function (f) {
	            return f.status;
	          });
	          return callback(null, false, challenges, statuses);
	        }
	      }

	      // Strategies are ordered by priority.  For the purpose of flashing a
	      // message, the first failure will be displayed.
	      var failure = failures[0] || {},
	          challenge = failure.challenge || {},
	          msg;

	      if (options.failureFlash) {
	        var flash = options.failureFlash;
	        if (typeof flash == 'string') {
	          flash = { type: 'error', message: flash };
	        }
	        flash.type = flash.type || 'error';

	        var type = flash.type || challenge.type || 'error';
	        msg = flash.message || challenge.message || challenge;
	        if (typeof msg == 'string') {
	          req.flash(type, msg);
	        }
	      }
	      if (options.failureMessage) {
	        msg = options.failureMessage;
	        if (typeof msg == 'boolean') {
	          msg = challenge.message || challenge;
	        }
	        if (typeof msg == 'string') {
	          req.session.messages = req.session.messages || [];
	          req.session.messages.push(msg);
	        }
	      }
	      if (options.failureRedirect) {
	        return res.redirect(options.failureRedirect);
	      }

	      // When failure handling is not delegated to the application, the default
	      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate
	      // header will be set according to the strategies in use (see
	      // actions#fail).  If multiple strategies failed, each of their challenges
	      // will be included in the response.
	      var rchallenge = [],
	          rstatus,
	          status;

	      for (var j = 0, len = failures.length; j < len; j++) {
	        failure = failures[j];
	        challenge = failure.challenge;
	        status = failure.status;

	        rstatus = rstatus || status;
	        if (typeof challenge == 'string') {
	          rchallenge.push(challenge);
	        }
	      }

	      res.statusCode = rstatus || 401;
	      if (res.statusCode == 401 && rchallenge.length) {
	        res.setHeader('WWW-Authenticate', rchallenge);
	      }
	      if (options.failWithError) {
	        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));
	      }
	      res.end(http.STATUS_CODES[res.statusCode]);
	    }

	    (function attempt(i) {
	      var layer = name[i];
	      // If no more strategies exist in the chain, authentication has failed.
	      if (!layer) {
	        return allFailed();
	      }

	      // Get the strategy, which will be used as prototype from which to create
	      // a new instance.  Action functions will then be bound to the strategy
	      // within the context of the HTTP request/response pair.
	      var prototype = passport._strategy(layer);
	      if (!prototype) {
	        return next(new Error('Unknown authentication strategy "' + layer + '"'));
	      }

	      var strategy = Object.create(prototype);

	      // ----- BEGIN STRATEGY AUGMENTATION -----
	      // Augment the new strategy instance with action functions.  These action
	      // functions are bound via closure the the request/response pair.  The end
	      // goal of the strategy is to invoke *one* of these action methods, in
	      // order to indicate successful or failed authentication, redirect to a
	      // third-party identity provider, etc.

	      /**
	       * Authenticate `user`, with optional `info`.
	       *
	       * Strategies should call this function to successfully authenticate a
	       * user.  `user` should be an object supplied by the application after it
	       * has been given an opportunity to verify credentials.  `info` is an
	       * optional argument containing additional user information.  This is
	       * useful for third-party authentication strategies to pass profile
	       * details.
	       *
	       * @param {Object} user
	       * @param {Object} info
	       * @api public
	       */
	      strategy.success = function (user, info) {
	        if (callback) {
	          return callback(null, user, info);
	        }

	        info = info || {};
	        var msg;

	        if (options.successFlash) {
	          var flash = options.successFlash;
	          if (typeof flash == 'string') {
	            flash = { type: 'success', message: flash };
	          }
	          flash.type = flash.type || 'success';

	          var type = flash.type || info.type || 'success';
	          msg = flash.message || info.message || info;
	          if (typeof msg == 'string') {
	            req.flash(type, msg);
	          }
	        }
	        if (options.successMessage) {
	          msg = options.successMessage;
	          if (typeof msg == 'boolean') {
	            msg = info.message || info;
	          }
	          if (typeof msg == 'string') {
	            req.session.messages = req.session.messages || [];
	            req.session.messages.push(msg);
	          }
	        }
	        if (options.assignProperty) {
	          req[options.assignProperty] = user;
	          return next();
	        }

	        req.logIn(user, options, function (err) {
	          if (err) {
	            return next(err);
	          }

	          function complete() {
	            if (options.successReturnToOrRedirect) {
	              var url = options.successReturnToOrRedirect;
	              if (req.session && req.session.returnTo) {
	                url = req.session.returnTo;
	                delete req.session.returnTo;
	              }
	              return res.redirect(url);
	            }
	            if (options.successRedirect) {
	              return res.redirect(options.successRedirect);
	            }
	            next();
	          }

	          if (options.authInfo !== false) {
	            passport.transformAuthInfo(info, req, function (err, tinfo) {
	              if (err) {
	                return next(err);
	              }
	              req.authInfo = tinfo;
	              complete();
	            });
	          } else {
	            complete();
	          }
	        });
	      };

	      /**
	       * Fail authentication, with optional `challenge` and `status`, defaulting
	       * to 401.
	       *
	       * Strategies should call this function to fail an authentication attempt.
	       *
	       * @param {String} challenge
	       * @param {Number} status
	       * @api public
	       */
	      strategy.fail = function (challenge, status) {
	        if (typeof challenge == 'number') {
	          status = challenge;
	          challenge = undefined;
	        }

	        // push this failure into the accumulator and attempt authentication
	        // using the next strategy
	        failures.push({ challenge: challenge, status: status });
	        attempt(i + 1);
	      };

	      /**
	       * Redirect to `url` with optional `status`, defaulting to 302.
	       *
	       * Strategies should call this function to redirect the user (via their
	       * user agent) to a third-party website for authentication.
	       *
	       * @param {String} url
	       * @param {Number} status
	       * @api public
	       */
	      strategy.redirect = function (url, status) {
	        // NOTE: Do not use `res.redirect` from Express, because it can't decide
	        //       what it wants.
	        //
	        //       Express 2.x: res.redirect(url, status)
	        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)
	        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)
	        //           is used
	        //       Express 4.x: res.redirect(status, url)
	        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)
	        //           but issue deprecated versions

	        res.statusCode = status || 302;
	        res.setHeader('Location', url);
	        res.setHeader('Content-Length', '0');
	        res.end();
	      };

	      /**
	       * Pass without making a success or fail decision.
	       *
	       * Under most circumstances, Strategies should not need to call this
	       * function.  It exists primarily to allow previous authentication state
	       * to be restored, for example from an HTTP session.
	       *
	       * @api public
	       */
	      strategy.pass = function () {
	        next();
	      };

	      /**
	       * Internal error while performing authentication.
	       *
	       * Strategies should call this function when an internal error occurs
	       * during the process of performing authentication; for example, if the
	       * user directory is not available.
	       *
	       * @param {Error} err
	       * @api public
	       */
	      strategy.error = function (err) {
	        if (callback) {
	          return callback(err);
	        }

	        next(err);
	      };

	      // ----- END STRATEGY AUGMENTATION -----

	      strategy.authenticate(req, options);
	    })(0); // attempt
	  };
	};

/***/ },
/* 446 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	//var http = require('http')
	//  , req = http.IncomingMessage.prototype;


	var req = exports = module.exports = {};

	/**
	 * Intiate a login session for `user`.
	 *
	 * Options:
	 *   - `session`  Save login state in session, defaults to _true_
	 *
	 * Examples:
	 *
	 *     req.logIn(user, { session: false });
	 *
	 *     req.logIn(user, function(err) {
	 *       if (err) { throw err; }
	 *       // session saved
	 *     });
	 *
	 * @param {User} user
	 * @param {Object} options
	 * @param {Function} done
	 * @api public
	 */
	req.login = req.logIn = function (user, options, done) {
	  if (typeof options == 'function') {
	    done = options;
	    options = {};
	  }
	  options = options || {};

	  var property = 'user';
	  if (this._passport && this._passport.instance) {
	    property = this._passport.instance._userProperty || 'user';
	  }
	  var session = options.session === undefined ? true : options.session;

	  this[property] = user;
	  if (session) {
	    if (!this._passport) {
	      throw new Error('passport.initialize() middleware not in use');
	    }
	    if (typeof done != 'function') {
	      throw new Error('req#login requires a callback function');
	    }

	    var self = this;
	    this._passport.instance.serializeUser(user, this, function (err, obj) {
	      if (err) {
	        self[property] = null;return done(err);
	      }
	      if (!self._passport.session) {
	        self._passport.session = {};
	      }
	      self._passport.session.user = obj;
	      if (!self.session) {
	        self.session = {};
	      }
	      self.session[self._passport.instance._key] = self._passport.session;
	      done();
	    });
	  } else {
	    done && done();
	  }
	};

	/**
	 * Terminate an existing login session.
	 *
	 * @api public
	 */
	req.logout = req.logOut = function () {
	  var property = 'user';
	  if (this._passport && this._passport.instance) {
	    property = this._passport.instance._userProperty || 'user';
	  }

	  this[property] = null;
	  if (this._passport && this._passport.session) {
	    delete this._passport.session.user;
	  }
	};

	/**
	 * Test if request is authenticated.
	 *
	 * @return {Boolean}
	 * @api public
	 */
	req.isAuthenticated = function () {
	  var property = 'user';
	  if (this._passport && this._passport.instance) {
	    property = this._passport.instance._userProperty || 'user';
	  }

	  return this[property] ? true : false;
	};

	/**
	 * Test if request is unauthenticated.
	 *
	 * @return {Boolean}
	 * @api public
	 */
	req.isUnauthenticated = function () {
	  return !this.isAuthenticated();
	};

/***/ },
/* 447 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `AuthenticationError` error.
	 *
	 * @api private
	 */
	function AuthenticationError(message, status) {
	  Error.call(this);
	  Error.captureStackTrace(this, arguments.callee);
	  this.name = 'AuthenticationError';
	  this.message = message;
	  this.status = status || 401;
	}

	/**
	 * Inherit from `Error`.
	 */
	AuthenticationError.prototype.__proto__ = Error.prototype;

	/**
	 * Expose `AuthenticationError`.
	 */
	module.exports = AuthenticationError;

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _lodash = __webpack_require__(449);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _queries = __webpack_require__(450);

	var _queries2 = _interopRequireDefault(_queries);

	var _dbConnect = __webpack_require__(452);

	var _dbConnect2 = _interopRequireDefault(_dbConnect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var spotSchema = {
	  columns: {
	    name: 'string',
	    rating: 'number',
	    latitude: 'number',
	    longitude: 'number',
	    image: 'string',
	    yelp_id: 'string'
	  },
	  tableName: 'spots'
	};

	var Spot = new _queries2.default(_dbConnect2.default, spotSchema);

	exports.default = Spot;

/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;};/**
	 * @license
	 * lodash <https://lodash.com/>
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.13.1';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Used as the `TypeError` message for "Functions" methods. */var FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for wrapper metadata. */var BIND_FLAG=1,BIND_KEY_FLAG=2,CURRY_BOUND_FLAG=4,CURRY_FLAG=8,CURRY_RIGHT_FLAG=16,PARTIAL_FLAG=32,PARTIAL_RIGHT_FLAG=64,ARY_FLAG=128,REARG_FLAG=256,FLIP_FLAG=512;/** Used to compose bitmasks for comparison styles. */var UNORDERED_COMPARE_FLAG=1,PARTIAL_COMPARE_FLAG=2;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=150,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',promiseTag='[object Promise]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39|#96);/g,reUnescapedHtml=/[&<>"'`]/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;/**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match non-compound words composed of alphanumeric characters. */var reBasicWord=/[a-zA-Z0-9]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components).
	   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect hexadecimal string values. */var reHasHexPrefix=/^0x/i;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match latin-1 supplementary letters (excluding mathematical operators). */var reLatin1=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f\\ufe20-\\ufe23',rsComboSymbolsRange='\\u20d0-\\u20f0',rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos='[\']',rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboMarksRange+rsComboSymbolsRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsLowerMisc='(?:'+rsLower+'|'+rsMisc+')',rsUpperMisc='(?:'+rsUpper+'|'+rsMisc+')',rsOptLowerContr='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptUpperContr='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reComplexSymbol=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reComplexWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptLowerContr+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsUpperMisc+'+'+rsOptUpperContr+'(?='+[rsBreak,rsUpper+rsLowerMisc,'$'].join('|')+')',rsUpper+'?'+rsLowerMisc+'+'+rsOptLowerContr,rsUpper+'+'+rsOptUpperContr,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasComplexSymbol=RegExp('['+rsZWJ+rsAstralRange+rsComboMarksRange+rsComboSymbolsRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasComplexWord=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','Reflect','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map latin-1 supplementary letters to basic latin letters. */var deburredLetters={'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcC':'I','\xcd':'I','\xce':'I','\xcf':'I','\xeC':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','`':'&#96;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'",'&#96;':'`'};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `exports`. */var freeExports=( false?'undefined':_typeof(exports))=='object'&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&( false?'undefined':_typeof(module))=='object'&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `global` from Node.js. */var freeGlobal=checkGlobal((typeof global==='undefined'?'undefined':_typeof(global))=='object'&&global);/** Detect free variable `self`. */var freeSelf=checkGlobal((typeof self==='undefined'?'undefined':_typeof(self))=='object'&&self);/** Detect `this` as the global object. */var thisGlobal=checkGlobal(_typeof(this)=='object'&&this);/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||thisGlobal||Function('return this')();/*--------------------------------------------------------------------------*//**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */function addMapEntry(map,pair){// Don't return `Map#set` because it doesn't return the map instance in IE 11.
	map.set(pair[0],pair[1]);return map;}/**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */function addSetEntry(set,value){set.add(value);return set;}/**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */function apply(func,thisArg,args){var length=args.length;switch(length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array?array.length:0;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */function arrayEach(array,iteratee){var index=-1,length=array?array.length:0;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */function arrayEachRight(array,iteratee){var length=array?array.length:0;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */function arrayEvery(array,predicate){var index=-1,length=array?array.length:0;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */function arrayFilter(array,predicate){var index=-1,length=array?array.length:0,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to search.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */function arrayIncludes(array,value){var length=array?array.length:0;return!!length&&baseIndexOf(array,value,0)>-1;}/**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to search.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array?array.length:0;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */function arrayMap(array,iteratee){var index=-1,length=array?array.length:0,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array?array.length:0;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array?array.length:0;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */function arraySome(array,predicate){var index=-1,length=array?array.length:0;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function baseIndexOf(array,value,fromIndex){if(value!==value){return indexOfNaN(array,fromIndex);}var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */function baseMean(array,iteratee){var length=array?array.length:0;return length?baseSum(array,iteratee)/length:NAN;}/**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
	   * The base implementation of `_.unary` without support for storing wrapper metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */function baseUnary(func){return function(value){return func(value);};}/**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
	   * Checks if a cache value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */function cacheHas(cache,key){return cache.has(key);}/**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
	   * Checks if `value` is a global object.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	   */function checkGlobal(value){return value&&value.Object===Object?value:null;}/**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){result++;}}return result;}/**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */function deburrLetter(letter){return deburredLetters[letter];}/**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */function escapeHtmlChar(chr){return htmlEscapes[chr];}/**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */function getValue(object,key){return object==null?undefined:object[key];}/**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */function indexOfNaN(array,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){var other=array[index];if(other!==other){return index;}}return-1;}/**
	   * Checks if `value` is a host object in IE < 9.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	   */function isHostObject(value){// Many host objects are `Object` objects that can coerce to strings
	// despite having improperly defined `toString` methods.
	var result=false;if(value!=null&&typeof value.toString!='function'){try{result=!!(value+'');}catch(e){}}return result;}/**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */function stringSize(string){if(!(string&&reHasComplexSymbol.test(string))){return string.length;}var result=reComplexSymbol.lastIndex=0;while(reComplexSymbol.test(string)){result++;}return result;}/**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */function stringToArray(string){return string.match(reComplexSymbol);}/**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */function unescapeHtmlChar(chr){return htmlUnescapes[chr];}/*--------------------------------------------------------------------------*//**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Use `context` to stub `Date#getTime` use in `_.now`.
	   * var stubbed = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': stubGetTime };
	   *   }
	   * });
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */function runInContext(context){context=context?_.defaults({},context,_.pick(root,contextProps)):root;/** Built-in constructor references. */var Date=context.Date,Error=context.Error,Math=context.Math,RegExp=context.RegExp,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=context.Array.prototype,objectProto=context.Object.prototype,stringProto=context.String.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/** Used to resolve the decompiled source of functions. */var funcToString=context.Function.prototype.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */var objectToString=objectProto.toString;/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Reflect=context.Reflect,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,enumerate=Reflect?Reflect.enumerate:undefined,getOwnPropertySymbols=Object.getOwnPropertySymbols,iteratorSymbol=_typeof(iteratorSymbol=_Symbol&&_Symbol.iterator)=='symbol'?iteratorSymbol:undefined,objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice;/** Built-in method references that are mockable. */var setTimeout=function setTimeout(func,wait){return context.setTimeout.call(root,func,wait);};/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetPrototype=Object.getPrototypeOf,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=Object.keys,nativeMax=Math.max,nativeMin=Math.min,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReplace=stringProto.replace,nativeReverse=arrayProto.reverse,nativeSplit=stringProto.split;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */var nonEnumShadows=!propertyIsEnumerable.call({'valueOf':1},'valueOf');/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array of at least `200` elements
	     * and any iteratees accept only one argument. The heuristic for whether a
	     * section qualifies for shortcut fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
	     * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
	     * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
	     * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
	     * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
	     * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
	     * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
	     * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
	     * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
	     * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */function baseLodash(){}// No operation performed.
	/**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */lodash.templateSettings={/**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */'escape':reEscape,/**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */'evaluate':reEvaluate,/**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */'interpolate':reInterpolate,/**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */'variable':'',/**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */'imports':{/**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
	lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||arrLength<LARGE_ARRAY_SIZE||arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
	LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function Hash(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};}/**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function hashDelete(key){return this.has(key)&&delete this.__data__[key];}/**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */function hashSet(key,value){var data=this.__data__;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
	Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function ListCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */function listCacheClear(){this.__data__=[];}/**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}return true;}/**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
	ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function MapCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */function mapCacheClear(){this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function mapCacheDelete(key){return getMapData(this,key)['delete'](key);}/**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */function mapCacheSet(key,value){getMapData(this,key).set(key,value);return this;}// Add methods to `MapCache`.
	MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */function SetCache(values){var index=-1,length=values?values.length:0;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
	SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */function Stack(entries){this.__data__=new ListCache(entries);}/**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */function stackClear(){this.__data__=new ListCache();}/**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */function stackDelete(key){return this.__data__['delete'](key);}/**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */function stackGet(key){return this.__data__.get(key);}/**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */function stackHas(key){return this.__data__.has(key);}/**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */function stackSet(key,value){var cache=this.__data__;if(cache instanceof ListCache&&cache.__data__.length==LARGE_ARRAY_SIZE){cache=this.__data__=new MapCache(cache.__data__);}cache.set(key,value);return this;}// Add methods to `Stack`.
	Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**
	     * Used by `_.defaults` to customize its `_.assignIn` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */function assignInDefaults(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||typeof key=='number'&&value===undefined&&!(key in object)){object[key]=value;}}/**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){object[key]=value;}}/**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to search.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths of elements to pick.
	     * @returns {Array} Returns the picked elements.
	     */function baseAt(object,paths){var index=-1,isNil=object==null,length=paths.length,result=Array(length);while(++index<length){result[index]=isNil?undefined:get(object,paths[index]);}return result;}/**
	     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {boolean} [isFull] Specify a clone including symbols.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */function baseClone(value,isDeep,isFull,customizer,key,object,stack){var result;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){if(isHostObject(value)){return object?value:{};}result=initCloneObject(isFunc?{}:value);if(!isDeep){return copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.
	stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(!isArr){var props=isFull?getAllKeys(value):keys(value);}// Recursively populate clone (susceptible to call stack limits).
	arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}assignValue(result,key,baseClone(subValue,isDeep,isFull,customizer,key,value,stack));});return result;}/**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */function baseConforms(source){var props=keys(source),length=props.length;return function(object){if(object==null){return!length;}var index=length;while(index--){var key=props[index],predicate=source[key],value=object[key];if(value===undefined&&!(key in Object(object))||!predicate(value)){return false;}}return true;};}/**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */function baseCreate(proto){return isObject(proto)?objectCreate(proto):{};}/**
	     * The base implementation of `_.delay` and `_.defer` which accepts an array
	     * of `func` arguments.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments to provide to `func`.
	     * @returns {number} Returns the timer id.
	     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */var baseEach=createBaseEach(baseForOwn);/**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
	baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */var baseFor=createBaseFor();/**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */var baseForRight=createBaseFor(true);/**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */function baseGet(object,path){path=isKey(path,object)?[path]:castPath(path);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
	     * The base implementation of `_.gt` which doesn't coerce arguments to numbers.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */function baseGt(value,other){return value>other;}/**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */function baseHas(object,key){// Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
	// that are composed entirely of index properties, return `false` for
	// `hasOwnProperty` checks of them.
	return object!=null&&(hasOwnProperty.call(object,key)||(typeof object==='undefined'?'undefined':_typeof(object))=='object'&&key in object&&getPrototype(object)===null);}/**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
	     * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */function baseInvoke(object,path,args){if(!isKey(path,object)){path=castPath(path);object=parent(object,path);path=last(path);}var func=object==null?object:object[toKey(path)];return func==null?undefined:apply(func,object,args);}/**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {boolean} [bitmask] The bitmask of comparison flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - Unordered comparison
	     *     2 - Partial comparison
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */function baseIsEqual(value,other,customizer,bitmask,stack){if(value===other){return true;}if(value==null||other==null||!isObject(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,baseIsEqual,customizer,bitmask,stack);}/**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */function baseIsEqualDeep(object,other,equalFunc,customizer,bitmask,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=arrayTag,othTag=arrayTag;if(!objIsArr){objTag=getTag(object);objTag=objTag==argsTag?objectTag:objTag;}if(!othIsArr){othTag=getTag(other);othTag=othTag==argsTag?objectTag:othTag;}var objIsObj=objTag==objectTag&&!isHostObject(object),othIsObj=othTag==objectTag&&!isHostObject(other),isSameTag=objTag==othTag;if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,equalFunc,customizer,bitmask,stack):equalByTag(object,other,objTag,equalFunc,customizer,bitmask,stack);}if(!(bitmask&PARTIAL_COMPARE_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,customizer,bitmask,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,equalFunc,customizer,bitmask,stack);}/**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,customizer,UNORDERED_COMPARE_FLAG|PARTIAL_COMPARE_FLAG,stack):result)){return false;}}}return true;}/**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)||isHostObject(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	if(typeof value=='function'){return value;}if(value==null){return identity;}if((typeof value==='undefined'?'undefined':_typeof(value))=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
	     * The base implementation of `_.keys` which doesn't skip the constructor
	     * property of prototypes or treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */function baseKeys(object){return nativeKeys(Object(object));}/**
	     * The base implementation of `_.keysIn` which doesn't skip the constructor
	     * property of prototypes or treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */function baseKeysIn(object){object=object==null?object:Object(object);var result=[];for(var key in object){result.push(key);}return result;}// Fallback for IE < 9 with es6-shim.
	if(enumerate&&!propertyIsEnumerable.call({'valueOf':1},'valueOf')){baseKeysIn=function baseKeysIn(object){return iteratorToArray(enumerate(object));};}/**
	     * The base implementation of `_.lt` which doesn't coerce arguments to numbers.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */function baseLt(value,other){return value<other;}/**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,undefined,UNORDERED_COMPARE_FLAG|PARTIAL_COMPARE_FLAG);};}/**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}if(!(isArray(source)||isTypedArray(source))){var props=keysIn(source);}arrayEach(props||source,function(srcValue,key){if(props){key=srcValue;srcValue=source[key];}if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(object[key],srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}});}/**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=object[key],srcValue=source[key],stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){newValue=srcValue;if(isArray(srcValue)||isTypedArray(srcValue)){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else{isCommon=false;newValue=baseClone(srcValue,true);}}else if(isPlainObject(srcValue)||isArguments(srcValue)){if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||srcIndex&&isFunction(objValue)){isCommon=false;newValue=baseClone(srcValue,true);}else{newValue=objValue;}}else{isCommon=false;}}stack.set(srcValue,newValue);if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
	mergeFunc(newValue,srcValue,srcIndex,customizer,stack);}stack['delete'](srcValue);assignMergeValue(object,key,newValue);}/**
	     * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property identifiers to pick.
	     * @returns {Object} Returns the new object.
	     */function basePick(object,props){object=Object(object);return arrayReduce(props,function(result,key){if(key in object){result[key]=object[key];}return result;},{});}/**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */function basePickBy(object,predicate){var index=-1,props=getAllKeysIn(object),length=props.length,result={};while(++index<length){var key=props[index],value=object[key];if(predicate(value,key)){result[key]=value;}}return result;}/**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else if(!isKey(index,array)){var path=castPath(index),object=parent(array,path);if(object!=null){delete object[toKey(last(path))];}}else{delete array[toKey(index)];}}}return array;}/**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments to numbers.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
	// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */function baseSet(object,path,value,customizer){path=isKey(path,object)?[path]:castPath(path);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]);if(isObject(nested)){var newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=objValue==null?isIndex(path[index+1])?[]:{}:objValue;}}assignValue(nested,key,newValue);}nested=nested[key];}return object;}/**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */function baseSortedIndex(array,value,retHighest){var low=0,high=array?array.length:low;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array?array.length:0,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
	if(typeof value=='string'){return value;}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */function baseUnset(object,path){path=isKey(path,object)?[path]:castPath(path);object=parent(object,path);var key=toKey(last(path));return!(object!=null&&baseHas(object,key))||delete object[key];}/**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */function baseXor(arrays,iteratee,comparator){var index=-1,length=arrays.length;while(++index<length){var result=result?arrayPush(baseDifference(result,arrays[index],iteratee,comparator),baseDifference(arrays[index],result,iteratee,comparator)):arrays[index];}return result&&result.length?baseUniq(result,iteratee,comparator):[];}/**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */function castFunction(value){return typeof value=='function'?value:identity;}/**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast property path array.
	     */function castPath(value){return isArray(value)?value:stringToPath(value);}/**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var result=new buffer.constructor(buffer.length);buffer.copy(result);return result;}/**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),true):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),true):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	// that causes it, under certain circumstances, to provide the same value for
	// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	// for more details.
	//
	// This also ensures a stable sort in V8 and other engines.
	// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	return object.index-other.index;}/**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */function copyObject(source,props,object,customizer){object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):source[key];assignValue(object,key,newValue);}return object;}/**
	     * Copies own symbol properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee),accumulator);};}/**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */function createAssigner(assigner){return rest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
	     *  for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createBaseWrapper(func,bitmask,thisArg){var isBind=bitmask&BIND_FLAG,Ctor=createCtorWrapper(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=reHasComplexSymbol.test(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */function createCtorWrapper(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
	// http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	// for more details.
	var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
	// See https://es5.github.io/#x13.2.2 for more details.
	return isObject(result)?result:thisBinding;};}/**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
	     *  for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createCurryWrapper(func,bitmask,arity){var Ctor=createCtorWrapper(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurryWrapper(func,bitmask,createHybridWrapper,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);predicate=getIteratee(predicate,3);if(!isArrayLike(collection)){var props=keys(collection);}var index=findIndexFunc(props||collection,function(value,key){if(props){key=value;value=iterable[key];}return predicate(value,key,iterable);},fromIndex);return index>-1?collection[props?props[index]:index]:undefined;};}/**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */function createFlow(fromRight){return rest(function(funcs){funcs=baseFlatten(funcs,1);var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(ARY_FLAG|CURRY_FLAG|PARTIAL_FLAG|REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)&&value.length>=LARGE_ARRAY_SIZE){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
	     *  for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createHybridWrapper(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&ARY_FLAG,isBind=bitmask&BIND_FLAG,isBindKey=bitmask&BIND_KEY_FLAG,isCurried=bitmask&(CURRY_FLAG|CURRY_RIGHT_FLAG),isFlip=bitmask&FLIP_FLAG,Ctor=isBindKey?undefined:createCtorWrapper(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurryWrapper(func,bitmask,createHybridWrapper,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtorWrapper(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new mathematical operation function.
	     */function createMathOperation(operator){return function(value,other){var result;if(value===undefined&&other===undefined){return 0;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */function createOver(arrayFunc){return rest(function(iteratees){iteratees=iteratees.length==1&&isArray(iteratees[0])?arrayMap(iteratees[0],baseUnary(getIteratee())):arrayMap(baseFlatten(iteratees,1,isFlattenableIteratee),baseUnary(getIteratee()));return rest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return reHasComplexSymbol.test(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
	     *  for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */function createPartialWrapper(func,bitmask,thisArg,partials){var isBind=bitmask&BIND_FLAG,Ctor=createCtorWrapper(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
	start=toNumber(start);start=start===start?start:0;if(end===undefined){end=start;start=0;}else{end=toNumber(end)||0;}step=step===undefined?start<end?1:-1:toNumber(step)||0;return baseRange(start,end,step,fromRight);};}/**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
	     *  for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createRecurryWrapper(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?PARTIAL_FLAG:PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?PARTIAL_RIGHT_FLAG:PARTIAL_FLAG);if(!(bitmask&CURRY_BOUND_FLAG)){bitmask&=~(BIND_FLAG|BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return result;}/**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.
	// See [MDN](https://mdn.io/round#Examples) for more details.
	var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
	     * Creates a set of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     *   512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */function createWrapper(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(PARTIAL_FLAG|PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]==null?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(CURRY_FLAG|CURRY_RIGHT_FLAG)){bitmask&=~(CURRY_FLAG|CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==BIND_FLAG){var result=createBaseWrapper(func,bitmask,thisArg);}else if(bitmask==CURRY_FLAG||bitmask==CURRY_RIGHT_FLAG){result=createCurryWrapper(func,bitmask,arity);}else if((bitmask==PARTIAL_FLAG||bitmask==(BIND_FLAG|PARTIAL_FLAG))&&!holders.length){result=createPartialWrapper(func,bitmask,thisArg,partials);}else{result=createHybridWrapper.apply(undefined,newData);}var setter=data?baseSetData:setData;return setter(result,newData);}/**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */function equalArrays(array,other,equalFunc,customizer,bitmask,stack){var isPartial=bitmask&PARTIAL_COMPARE_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
	var stacked=stack.get(array);if(stacked){return stacked==other;}var index=-1,result=true,seen=bitmask&UNORDERED_COMPARE_FLAG?new SetCache():undefined;stack.set(array,other);// Ignore non-index properties.
	while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
	if(seen){if(!arraySome(other,function(othValue,othIndex){if(!seen.has(othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,customizer,bitmask,stack))){return seen.add(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,customizer,bitmask,stack))){result=false;break;}}stack['delete'](array);return result;}/**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */function equalByTag(object,other,tag,equalFunc,customizer,bitmask,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:// Coerce dates and booleans to numbers, dates to milliseconds and
	// booleans to `1` or `0` treating invalid dates coerced to `NaN` as
	// not equal.
	return+object==+other;case errorTag:return object.name==other.name&&object.message==other.message;case numberTag:// Treat `NaN` vs. `NaN` as equal.
	return object!=+object?other!=+other:object==+other;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
	// as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
	// for more details.
	return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&PARTIAL_COMPARE_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
	var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=UNORDERED_COMPARE_FLAG;stack.set(object,other);// Recursively compare objects (susceptible to call stack limits).
	return equalArrays(convert(object),convert(other),equalFunc,customizer,bitmask,stack);case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	     *  for more details.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */function equalObjects(object,other,equalFunc,customizer,bitmask,stack){var isPartial=bitmask&PARTIAL_COMPARE_FLAG,objProps=keys(object),objLength=objProps.length,othProps=keys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:baseHas(other,key))){return false;}}// Assume cyclic values are equal.
	var stacked=stack.get(object);if(stacked){return stacked==other;}var result=true;stack.set(object,other);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
	if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,customizer,bitmask,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
	if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);return result;}/**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a
	     * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
	     * Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */var getLength=baseProperty('length');/**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
	     * Gets the `[[Prototype]]` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {null|Object} Returns the `[[Prototype]]`.
	     */function getPrototype(value){return nativeGetPrototype(Object(value));}/**
	     * Creates an array of the own enumerable symbol properties of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */function getSymbols(object){// Coerce `object` to an object to avoid non-object errors in V8.
	// See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
	return getOwnPropertySymbols(Object(object));}// Fallback for IE < 11.
	if(!getOwnPropertySymbols){getSymbols=stubArray;}/**
	     * Creates an array of the own and inherited enumerable symbol properties
	     * of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */var getSymbolsIn=!getOwnPropertySymbols?getSymbols:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */function getTag(value){return objectToString.call(value);}// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge, and promises in Node.js.
	if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=objectToString.call(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):undefined;if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */function hasPath(object,path,hasFunc){path=isKey(path,object)?[path]:castPath(path);var result,index=-1,length=path.length;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result){return result;}var length=object?object.length:0;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isString(object)||isArguments(object));}/**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.
	if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**
	     * Creates an array of index keys for `object` values of arrays,
	     * `arguments` objects, and strings, otherwise `null` is returned.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array|null} Returns index keys, else `null`.
	     */function indexKeys(object){var length=object?object.length:undefined;if(isLength(length)&&(isArray(object)||isString(object)||isArguments(object))){return baseTimes(length,String);}return null;}/**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */function isFlattenable(value){return isArray(value)||isArguments(value);}/**
	     * Checks if `value` is a flattenable array and not a `_.matchesProperty`
	     * iteratee shorthand.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */function isFlattenableIteratee(value){return isArray(value)&&!(value.length==2&&!isFunction(value[0]));}/**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index==='undefined'?'undefined':_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value==='undefined'?'undefined':_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */function isKeyable(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */var isMaskable=coreJsData?isFunction:stubFalse;/**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(BIND_FLAG|BIND_KEY_FLAG|ARY_FLAG);var isCombo=srcBitmask==ARY_FLAG&&bitmask==CURRY_FLAG||srcBitmask==ARY_FLAG&&bitmask==REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(ARY_FLAG|REARG_FLAG)&&source[7].length<=source[8]&&bitmask==CURRY_FLAG;// Exit early if metadata can't be merged.
	if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
	if(srcBitmask&BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
	newBitmask|=bitmask&BIND_FLAG?0:CURRY_BOUND_FLAG;}// Compose partial arguments.
	var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
	value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
	value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
	if(srcBitmask&ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
	if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
	data[0]=source[0];data[1]=newBitmask;return data;}/**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */function mergeDefaults(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){baseMerge(objValue,srcValue,undefined,mergeDefaults,stack.set(srcValue,objValue));}return objValue;}/**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */function parent(object,path){return path.length==1?object:baseGet(object,baseSlice(path,0,-1));}/**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */var setData=function(){var count=0,lastCalled=0;return function(key,value){var stamp=now(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return key;}}else{count=0;}return baseSetData(key,value);};}();/**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */var stringToPath=memoize(function(string){var result=[];toString(string).replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});/**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to process.
	     * @returns {string} Returns the source code.
	     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array?array.length:0;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */function compact(array){var index=-1,length=array?array.length:0,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */function concat(){var length=arguments.length,args=Array(length?length-1:0),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return length?arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1)):[];}/**
	     * Creates an array of unique `array` values not included in the other given
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. The order of result values is determined by the
	     * order they occur in the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */var difference=rest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. Result values are chosen from the first array.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */var differenceBy=rest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee)):[];});/**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. Result values
	     * are chosen from the first array. The comparator is invoked with two arguments:
	     * (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */var differenceWith=rest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */function drop(array,n,guard){var length=array?array.length:0;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */function dropRight(array,n,guard){var length=array?array.length:0;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */function fill(array,value,start,end){var length=array?array.length:0;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */function findIndex(array,predicate,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */function findLastIndex(array,predicate,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */function flatten(array){var length=array?array.length:0;return length?baseFlatten(array,1):[];}/**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */function flattenDeep(array){var length=array?array.length:0;return length?baseFlatten(array,INFINITY):[];}/**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */function flattenDepth(array,depth){var length=array?array.length:0;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */function fromPairs(pairs){var index=-1,length=pairs?pairs.length:0,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */function head(array){return array&&array.length?array[0]:undefined;}/**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */function indexOf(array,value,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */function initial(array){return dropRight(array,1);}/**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. The order of result values is determined by the
	     * order they occur in the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */var intersection=rest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. Result values are chosen from the first array.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */var intersectionBy=rest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee)):[];});/**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. Result values are chosen
	     * from the first array. The comparator is invoked with two arguments:
	     * (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */var intersectionWith=rest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(comparator===last(mapped)){comparator=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */function join(array,separator){return array?nativeJoin.call(array,separator):'';}/**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */function last(array){var length=array?array.length:0;return length?array[length-1]:undefined;}/**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */function lastIndexOf(array,value,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=(index<0?nativeMax(length+index,0):nativeMin(index,length-1))+1;}if(value!==value){return indexOfNaN(array,index-1,true);}while(index--){if(array[index]===value){return index;}}return-1;}/**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */var pull=rest(pullAll);/**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee)):array;}/**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */var pullAt=rest(function(array,indexes){indexes=baseFlatten(indexes,1);var length=array?array.length:0,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */function reverse(array){return array?nativeReverse.call(array):array;}/**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */function slice(array,start,end){var length=array?array.length:0;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee));}/**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */function sortedIndexOf(array,value){var length=array?array.length:0;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee),true);}/**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */function sortedLastIndexOf(array,value){var length=array?array.length:0;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee)):[];}/**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */function tail(array){return drop(array,1);}/**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */function takeRight(array,n,guard){var length=array?array.length:0;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */var union=rest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */var unionBy=rest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee));});/**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */var unionWith=rest(function(arrays){var comparator=last(arrays);if(isArrayLikeObject(comparator)){comparator=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each
	     * element is kept.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee)):[];}/**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The comparator is invoked with
	     * two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */function uniqWith(array,comparator){return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */var without=rest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */var xor=rest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */var xorBy=rest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee));});/**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The comparator is invoked with
	     * two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */var xorWith=rest(function(arrays){var comparator=last(arrays);if(isArrayLikeObject(comparator)){comparator=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */var zip=rest(unzip);/**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */var zipWith=rest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */function tap(value,interceptor){interceptor(value);return value;}/**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */function thru(value,interceptor){return interceptor(value);}/**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths of elements to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */var wrapperAt=rest(function(paths){paths=baseFlatten(paths,1);var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */function wrapperChain(){return chain(this);}/**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */function wrapperToIterator(){return this;}/**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */var countBy=createAggregator(function(result,value,key){hasOwnProperty.call(result,key)?++result[key]:result[key]=1;});/**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to search.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */var find=createFind(findIndex);/**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to search.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */var findLast=createFind(findLastIndex);/**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _([1, 2]).forEach(function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{result[key]=[value];}});/**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function, it's
	     * invoked for and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */var invokeMap=rest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',isProp=isKey(path),result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){var func=isFunc?path:isProp&&value!=null?value[path]:undefined;result[++index]=func?apply(func,value,args):baseInvoke(value,path,args);});return result;});/**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */var keyBy=createAggregator(function(result,value,key){result[key]=value;});/**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;predicate=getIteratee(predicate,3);return func(collection,function(value,index,collection){return!predicate(value,index,collection);});}/**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */function sample(collection){var array=isArrayLike(collection)?collection:values(collection),length=array.length;return length>0?array[baseRandom(0,length-1)]:undefined;}/**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */function sampleSize(collection,n,guard){var index=-1,result=toArray(collection),length=result.length,lastIndex=length-1;if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=baseClamp(toInteger(n),0,length);}while(++index<n){var rand=baseRandom(index,lastIndex),value=result[rand];result[rand]=result[index];result[index]=value;}result.length=n;return result;}/**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */function shuffle(collection){return sampleSize(collection,MAX_ARRAY_LENGTH);}/**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){var result=collection.length;return result&&isString(collection)?stringSize(collection):result;}if(isObjectLike(collection)){var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}}return keys(collection).length;}/**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
	     *  [iteratees=[_.identity]] The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, function(o) { return o.user; });
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     *
	     * _.sortBy(users, 'user', function(o) {
	     *   return Math.floor(o.age / 10);
	     * });
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */var sortBy=rest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}iteratees=iteratees.length==1&&isArray(iteratees[0])?iteratees[0]:baseFlatten(iteratees,1,isFlattenableIteratee);return baseOrderBy(collection,iteratees,[]);});/*------------------------------------------------------------------------*//**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */function now(){return Date.now();}/*------------------------------------------------------------------------*//**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrapper(func,ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */var bind=rest(function(func,thisArg,partials){var bitmask=BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=PARTIAL_FLAG;}return createWrapper(func,bitmask,thisArg,partials,holders);});/**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */var bindKey=rest(function(object,key,partials){var bitmask=BIND_FLAG|BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=PARTIAL_FLAG;}return createWrapper(key,bitmask,object,partials,holders);});/**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrapper(func,CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrapper(func,CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide an options object to indicate whether `func` should be invoked on
	     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent calls
	     * to the debounced function return the result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
	lastInvokeTime=time;// Start the timer for the trailing edge.
	timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
	return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
	// trailing edge, the system time has gone backwards and we're treating
	// it as the trailing edge, or we've hit the `maxWait` limit.
	return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
	timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
	// debounced at least once.
	if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
	timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one or more milliseconds.
	     */var defer=rest(function(func,args){return baseDelay(func,1,args);});/**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */var delay=rest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */function flip(func){return createWrapper(func,FLIP_FLAG);}/**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */function memoize(func,resolver){if(typeof func!='function'||resolver&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result);return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Assign cache to `_.memoize`.
	memoize.Cache=MapCache;/**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){return!predicate.apply(this,arguments);};}/**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */function once(func){return before(2,func);}/**
	     * Creates a function that invokes `func` with arguments transformed by
	     * corresponding `transforms`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
	     *  [transforms[_.identity]] The functions to transform.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */var overArgs=rest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1,isFlattenableIteratee),baseUnary(getIteratee()));var funcsLength=transforms.length;return rest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */var partial=rest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrapper(func,PARTIAL_FLAG,undefined,partials,holders);});/**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */var partialRight=rest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrapper(func,PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */var rearg=rest(function(func,indexes){return createWrapper(func,REARG_FLAG,undefined,undefined,undefined,baseFlatten(indexes,1));});/**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=nativeMax(start===undefined?func.length-1:toInteger(start),0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}switch(start){case 0:return func.call(this,array);case 1:return func.call(this,args[0],array);case 2:return func.call(this,args[0],args[1],array);}var otherArgs=Array(start+1);index=-1;while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=array;return apply(func,this,otherArgs);};}/**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?0:nativeMax(toInteger(start),0);return rest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide an options object to indicate whether
	     * `func` should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */function unary(func){return ary(func,1);}/**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */function wrap(value,wrapper){wrapper=wrapper==null?identity:wrapper;return partial(wrapper,value);}/*------------------------------------------------------------------------*//**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */function clone(value){return baseClone(value,false,true);}/**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */function cloneWith(value,customizer){return baseClone(value,false,true,customizer);}/**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */function cloneDeep(value){return baseClone(value,true,true);}/**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */function cloneDeepWith(value,customizer){return baseClone(value,true,true,customizer);}/**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */var gt=createRelationalOperation(baseGt);/**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */function isArguments(value){// Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	return isArrayLikeObject(value)&&hasOwnProperty.call(value,'callee')&&(!propertyIsEnumerable.call(value,'callee')||objectToString.call(value)==argsTag);}/**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @type {Function}
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */var isArray=Array.isArray;/**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */function isArrayBuffer(value){return isObjectLike(value)&&objectToString.call(value)==arrayBufferTag;}/**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */function isArrayLike(value){return value!=null&&isLength(getLength(value))&&!isFunction(value);}/**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&objectToString.call(value)==boolTag;}/**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */var isBuffer=!Buffer?stubFalse:function(value){return value instanceof Buffer;};/**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */function isDate(value){return isObjectLike(value)&&objectToString.call(value)==dateTag;}/**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element,
	     *  else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */function isElement(value){return!!value&&value.nodeType===1&&isObjectLike(value)&&!isPlainObject(value);}/**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */function isEmpty(value){if(isArrayLike(value)&&(isArray(value)||isString(value)||isFunction(value.splice)||isArguments(value)||isBuffer(value))){return!value.length;}if(isObjectLike(value)){var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return!(nonEnumShadows&&keys(value).length);}/**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are **not** supported.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent,
	     *  else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */function isEqual(value,other){return baseIsEqual(value,other);}/**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent,
	     *  else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,customizer):!!result;}/**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object,
	     *  else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */function isError(value){if(!isObjectLike(value)){return false;}return objectToString.call(value)==errorTag||typeof value.message=='string'&&typeof value.name=='string';}/**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number,
	     *  else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */function isFunction(value){// The use of `Object#toString` avoids issues with the `typeof` operator
	// in Safari 8 which returns 'object' for typed array and weak map constructors,
	// and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	var tag=isObject(value)?objectToString.call(value):'';return tag==funcTag||tag==genTag;}/**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length,
	     *  else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */function isObject(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return!!value&&(type=='object'||type=='function');}/**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */function isObjectLike(value){return!!value&&(typeof value==='undefined'?'undefined':_typeof(value))=='object';}/**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */function isMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values. This method is
	     * equivalent to a `_.matches` function when `source` is partially applied.
	     *
	     * **Note:** This method supports comparing the same values as `_.isEqual`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
	// Perform the `toStringTag` check first to avoid errors with some
	// ActiveX objects in IE.
	return isNumber(value)&&value!=+value;}/**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the
	     * presence of the `core-js` package because `core-js` circumvents this kind
	     * of detection. Despite multiple requests, the `core-js` maintainer has made
	     * it clear: any attempt to fix the detection will be obstructed. As a result,
	     * we're left with little choice but to throw an error. Unfortunately, this
	     * also affects packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on `core-js`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */function isNative(value){if(isMaskable(value)){throw new Error('This method is not supported with `core-js`. Try https://github.com/es-shims.');}return baseIsNative(value);}/**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */function isNull(value){return value===null;}/**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */function isNil(value){return value==null;}/**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&objectToString.call(value)==numberTag;}/**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object,
	     *  else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */function isPlainObject(value){if(!isObjectLike(value)||objectToString.call(value)!=objectTag||isHostObject(value)){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */function isRegExp(value){return isObject(value)&&objectToString.call(value)==regexpTag;}/**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer,
	     *  else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */function isSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&objectToString.call(value)==stringTag;}/**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */function isSymbol(value){return(typeof value==='undefined'?'undefined':_typeof(value))=='symbol'||isObjectLike(value)&&objectToString.call(value)==symbolTag;}/**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */function isTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[objectToString.call(value)];}/**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */function isUndefined(value){return value===undefined;}/**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified,
	     *  else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */function isWeakSet(value){return isObjectLike(value)&&objectToString.call(value)==weakSetTag;}/**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */var lt=createRelationalOperation(baseLt);/**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(iteratorSymbol&&value[iteratorSymbol]){return iteratorToArray(value[iteratorSymbol]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=isFunction(value.valueOf)?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */function toSafeInteger(value){return baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER);}/**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.c = 3;
	     * }
	     *
	     * function Bar() {
	     *   this.e = 5;
	     * }
	     *
	     * Foo.prototype.d = 4;
	     * Bar.prototype.f = 6;
	     *
	     * _.assign({ 'a': 1 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3, 'e': 5 }
	     */var assign=createAssigner(function(object,source){if(nonEnumShadows||isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * function Bar() {
	     *   this.d = 4;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     * Bar.prototype.e = 5;
	     *
	     * _.assignIn({ 'a': 1 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
	     */var assignIn=createAssigner(function(object,source){if(nonEnumShadows||isPrototype(source)||isArrayLike(source)){copyObject(source,keysIn(source),object);return;}for(var key in source){assignValue(object,key,source[key]);}});/**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths of elements to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */var at=rest(function(object,paths){return baseAt(object,baseFlatten(paths,1));});/**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */function create(prototype,properties){var result=baseCreate(prototype);return properties?baseAssign(result,properties):result;}/**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */var defaults=rest(function(args){args.push(undefined,assignInDefaults);return apply(assignInWith,undefined,args);});/**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */var defaultsDeep=rest(function(args){args.push(undefined,mergeDefaults);return apply(mergeWith,undefined,args);});/**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */var invert=createInverter(function(result,value,key){result[value]=key;},constant(identity));/**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */var invertBy=createInverter(function(result,value,key){if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */var invoke=rest(baseInvoke);/**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */function keys(object){var isProto=isPrototype(object);if(!(isProto||isArrayLike(object))){return baseKeys(object);}var indexes=indexKeys(object),skipIndexes=!!indexes,result=indexes||[],length=result.length;for(var key in object){if(baseHas(object,key)&&!(skipIndexes&&(key=='length'||isIndex(key,length)))&&!(isProto&&key=='constructor')){result.push(key);}}return result;}/**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */function keysIn(object){var index=-1,isProto=isPrototype(object),props=baseKeysIn(object),propsLength=props.length,indexes=indexKeys(object),skipIndexes=!!indexes,result=indexes||[],length=result.length;while(++index<propsLength){var key=props[index];if(!(skipIndexes&&(key=='length'||isIndex(key,length)))&&!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){result[iteratee(value,key,object)]=value;});return result;}/**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){result[key]=iteratee(value,key,object);});return result;}/**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with seven arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable string keyed properties of `object` that are
	     * not omitted.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [props] The property identifiers to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */var omit=rest(function(object,props){if(object==null){return{};}props=arrayMap(baseFlatten(props,1),toKey);return basePick(object,baseDifference(getAllKeysIn(object),props));});/**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */function omitBy(object,predicate){predicate=getIteratee(predicate);return basePickBy(object,function(value,key){return!predicate(value,key);});}/**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [props] The property identifiers to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */var pick=rest(function(object,props){return object==null?{}:basePick(object,arrayMap(baseFlatten(props,1),toKey));});/**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Array|Function|Object|string} [predicate=_.identity]
	     *  The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */function pickBy(object,predicate){return object==null?{}:basePickBy(object,getIteratee(predicate));}/**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */function result(object,path,defaultValue){path=isKey(path,object)?[path]:castPath(path);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
	if(!length){object=undefined;length=1;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */var toPairs=createToPairs(keys);/**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */var toPairsIn=createToPairs(keysIn);/**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */function transform(object,iteratee,accumulator){var isArr=isArray(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){if(isArr||isObject(object)){var Ctor=object.constructor;if(isArr){accumulator=isArray(object)?new Ctor():[];}else{accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}}else{accumulator={};}}(isArr?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */function values(object){return object?baseValues(object,keys(object)):[];}/**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */function inRange(number,start,end){start=toNumber(start)||0;if(end===undefined){end=start;start=0;}else{end=toNumber(end)||0;}number=toNumber(number);return baseInRange(number,start,end);}/**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toNumber(lower)||0;if(upper===undefined){upper=lower;lower=0;}else{upper=toNumber(upper)||0;}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
	     * Deburrs `string` by converting
	     * [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */function deburr(string){string=toString(string);return string&&string.replace(reLatin1,deburrLetter).replace(reComboMark,'');}/**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);position-=target.length;return position>=0&&string.indexOf(target,position)==position;}/**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in IE < 9, they can break out of
	     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the
	     * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */var lowerFirst=createCaseFirst('toLowerCase');/**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */function parseInt(string,radix,guard){// Chrome fails to trim leading <BOM> whitespace characters.
	// See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
	if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}string=toString(string).replace(reTrim,'');return nativeParseInt(string,radix||(reHasHexPrefix.test(string)?16:10));}/**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:nativeReplace.call(string,args[1],args[2]);}/**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(separator==''&&reHasComplexSymbol.test(string)){return castSlice(stringToArray(string),0,limit);}}return nativeSplit.call(string,separator,limit);}/**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */function startsWith(string,target,position){string=toString(string);position=baseClamp(toInteger(position),0,string.length);return string.lastIndexOf(baseToString(target),position)==position;}/**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
	// (http://ejohn.org/blog/javascript-micro-templating/)
	// and Laura Doktorova's doT.js (https://github.com/olado/doT).
	var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,assignInDefaults);var imports=assignInWith({},options.imports,settings.imports,assignInDefaults),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
	var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
	var sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
	source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
	if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
	// order to produce the correct `offset` value.
	return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
	// code to add the data object to the top of the scope chain.
	var variable=options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
	source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
	source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
	// the `source` property as a convenience for inlining compiled templates.
	result.source=source;if(isError(result)){throw result;}return result;}/**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */function toLower(value){return toString(value).toLowerCase();}/**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */function toUpper(value){return toString(value).toUpperCase();}/**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(reHasComplexSymbol.test(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */var upperFirst=createCaseFirst('toUpperCase');/**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){pattern=reHasComplexWord.test(string)?reComplexWord:reBasicWord;}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */var attempt=rest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['onClick']);
	     * jQuery(element).on('click', view.onClick);
	     * // => Logs 'clicked docs' when clicked.
	     */var bindAll=rest(function(object,methodNames){arrayEach(baseFlatten(methodNames,1),function(key){key=toKey(key);object[key]=bind(object[key],object);});return object;});/**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.constant(true),                _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */function cond(pairs){var length=pairs?pairs.length:0,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return rest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.filter(users, _.conforms({ 'age': function(n) { return n > 38; } }));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */function conforms(source){return baseConforms(baseClone(source,true));}/**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */function constant(value){return function(){return value;};}/**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */var flow=createFlow();/**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */var flowRight=createFlow(true);/**
	     * This method returns the first argument given to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */function identity(value){return value;}/**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,true));}/**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`. The created function is equivalent to
	     * `_.isMatch` with a `source` partially applied.
	     *
	     * **Note:** This method supports comparing the same values as `_.isEqual`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */function matches(source){return baseMatches(baseClone(source,true));}/**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** This method supports comparing the same values as `_.isEqual`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,true));}/**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */var method=rest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */var methodOf=rest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
	     * A method that returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */function noop(){}// No operation performed.
	/**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */function nthArg(n){n=toInteger(n);return rest(function(args){return baseNth(args,n);});}/**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
	     *  [iteratees=[_.identity]] The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */var over=createOver(arrayMap);/**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
	     *  [predicates=[_.identity]] The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */var overEvery=createOver(arrayEvery);/**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
	     *  [predicates=[_.identity]] The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */var overSome=createOver(arraySome);/**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */var range=createRange();/**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */var rangeRight=createRange(true);/**
	     * A method that returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */function stubArray(){return[];}/**
	     * A method that returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */function stubFalse(){return false;}/**
	     * A method that returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */function stubObject(){return{};}/**
	     * A method that returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */function stubString(){return'';}/**
	     * A method that returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */function stubTrue(){return true;}/**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(value));}/**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */var add=createMathOperation(function(augend,addend){return augend+addend;});/**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */var ceil=createRound('ceil');/**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;});/**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */var floor=createRound('floor');/**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee),baseGt):undefined;}/**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */function mean(array){return baseMean(array,identity);}/**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee));}/**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee),baseLt):undefined;}/**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;});/**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */var round=createRound('round');/**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;});/**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity]
	     *  The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.
	lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
	lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
	mixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.
	lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.deburr=deburr;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
	lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */lodash.VERSION=VERSION;// Assign default placeholders.
	arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){var filtered=this.__filtered__;if(filtered&&!index){return new LazyWrapper(this);}n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.clone();if(filtered){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
	arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
	arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=rest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){predicate=getIteratee(predicate,3);return this.filter(function(value){return!predicate(value);});};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
	baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
	isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
	arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
	baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybridWrapper(undefined,BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
	LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
	lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;if(iteratorSymbol){lodash.prototype[iteratorSymbol]=wrapperToIterator;}return lodash;}/*--------------------------------------------------------------------------*/// Export lodash.
	var _=runInContext();// Expose Lodash on the free variable `window` or `self` when available so it's
	// globally accessible, even when bundled with Browserify, Webpack, etc. This
	// also prevents errors in cases where Lodash is loaded by a script tag in the
	// presence of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch
	// for more details. Use `_.noConflict` to remove Lodash from the global object.
	(freeSelf||{})._=_;// Some AMD build optimizers like r.js check for condition patterns like the following:
	if("function"=='function'&&_typeof(__webpack_require__(219))=='object'&&__webpack_require__(219)){// Define as an anonymous module so, through path mapping, it can be
	// referenced as the "underscore" module.
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return _;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	else if(freeModule){// Export for Node.js.
	(freeModule.exports=_)._=_;// Export for CommonJS support.
	freeExports._=_;}else{// Export to the global object.
	root._=_;}}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(218)(module), (function() { return this; }())))

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _lodash = __webpack_require__(449);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _queryHelpers = __webpack_require__(451);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DB = function () {
	  function DB(pgConnection, schema) {
	    _classCallCheck(this, DB);

	    this.pg = pgConnection;
	    this.schema = schema;
	  }

	  _createClass(DB, [{
	    key: 'getAll',
	    value: function getAll() {
	      return this.pg.query('select * from ' + this.schema.tableName);
	    }
	  }, {
	    key: 'getOne',
	    value: function getOne(id) {
	      return this.pg.query('select * from ' + this.schema.tableName + ' where id = ' + id);
	    }
	  }, {
	    key: 'find',
	    value: function find(obj) {
	      return this.pg.query((0, _queryHelpers.createSelectQuery)(this.schema, obj));
	    }
	  }, {
	    key: 'create',
	    value: function create(obj) {
	      return this.pg.query((0, _queryHelpers.createInsertQuery)(this.schema, obj));
	    }
	    //TODO HERE I WAS

	  }, {
	    key: 'findOrCreate',
	    value: function findOrCreate(obj) {
	      var _this = this;

	      return this.find(obj).then(function (foundObj) {
	        if (foundObj.length > 0) {
	          return foundObj;
	        }
	        return _this.create(obj);
	      });
	    }
	  }, {
	    key: 'remove',
	    value: function remove(id) {
	      return this.pg.query('delete from ' + this.schema.tableName + ' where id = ' + id);
	    }
	  }]);

	  return DB;
	}();

	exports.default = DB;

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sendBackJSON = exports.createSelectQuery = exports.createUpdateQuery = exports.createInsertQuery = undefined;

	var _lodash = __webpack_require__(449);

	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var typeWrapper = function typeWrapper(thing, type) {
	  if (thing === null) return null;
	  if (type === 'string') return '\'' + thing + '\'';
	  return thing;
	};

	var createInsertQuery = exports.createInsertQuery = function createInsertQuery(schema, objToInsert) {
	  var query = 'insert into ' + schema.tableName;
	  var columns = '('.concat(_lodash2.default.reduce(Object.keys(schema.columns), function (columns, val) {
	    return columns + ', ' + val;
	  }), '').concat(')');
	  var initial = true;
	  var values = 'values ('.concat(_lodash2.default.reduce(schema.columns, function (values, val, key) {
	    if (initial) {
	      initial = false;
	      return '' + typeWrapper(objToInsert[key] || null, val);
	    }
	    return values + ', ' + typeWrapper(objToInsert[key] || null, val);
	  }, '')).concat(')');
	  return query + ' ' + columns + ' ' + values;
	};

	var createUpdateQuery = exports.createUpdateQuery = function createUpdateQuery(schema, updateObj, id) {
	  var query = 'update ' + schema.tableName + ' set';
	  var changes = _lodash2.default.reduce(updateObj, function (columnChanges, val, key) {
	    return columnChanges + ' ' + key + ' = ' + typeWrapper(val, schema.columns[val]) + ',';
	  }, '').concat('where id = ' + id);
	  return query + ' ' + changes + ';';
	};

	var createSelectQuery = exports.createSelectQuery = function createSelectQuery(schema, findObj) {
	  var query = 'select * from ' + schema.tableName + ' where';
	  var length = Object.keys(findObj).length;
	  var i = 0;
	  var params = _lodash2.default.reduce(findObj, function (params, val, key) {
	    if (i === length - 1) {
	      return params + ' ' + key + ' = ' + typeWrapper(val, schema.columns[key]);
	    }
	    i++;
	    return params + ' ' + key + ' = ' + typeWrapper(val, schema.columns[key]) + ' or';
	  }, '');
	  return query + ' ' + params;
	};

	var sendBackJSON = exports.sendBackJSON = function sendBackJSON(rest, data, message) {
	  return res.status(200).json({
	    data: data,
	    message: message
	  });
	};

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _bluebird = __webpack_require__(453);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// import spotQueries from './spotQueries';
	// import userQueries from './userQueries';
	var pgp = __webpack_require__(454)({
	  promiseLib: _bluebird2.default
	});

	var connectionString = 'postgres://localhost:5432/hotspots';
	var pg = pgp(connectionString);

	exports.default = pg;

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {"use strict";var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;};/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 *//**
	 * bluebird build version 3.4.1
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/!function(e){if("object"==( false?"undefined":_typeof(exports))&&"undefined"!=typeof module)module.exports=e();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e();}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f;}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e);},l,l.exports,e,t,n,r);}return n[o].exports;}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++){s(r[o]);}return s;}({1:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){var SomePromiseArray=Promise._SomePromiseArray;function any(promises){var ret=new SomePromiseArray(promises);var promise=ret.promise();ret.setHowMany(1);ret.setUnwrap();ret.init();return promise;}Promise.any=function(promises){return any(promises);};Promise.prototype.any=function(){return any(this);};};},{}],2:[function(_dereq_,module,exports){"use strict";var firstLineError;try{throw new Error();}catch(e){firstLineError=e;}var schedule=_dereq_("./schedule");var Queue=_dereq_("./queue");var util=_dereq_("./util");function Async(){this._customScheduler=false;this._isTickUsed=false;this._lateQueue=new Queue(16);this._normalQueue=new Queue(16);this._haveDrainedQueues=false;this._trampolineEnabled=true;var self=this;this.drainQueues=function(){self._drainQueues();};this._schedule=schedule;}Async.prototype.setScheduler=function(fn){var prev=this._schedule;this._schedule=fn;this._customScheduler=true;return prev;};Async.prototype.hasCustomScheduler=function(){return this._customScheduler;};Async.prototype.enableTrampoline=function(){this._trampolineEnabled=true;};Async.prototype.disableTrampolineIfNecessary=function(){if(util.hasDevTools){this._trampolineEnabled=false;}};Async.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues;};Async.prototype.fatalError=function(e,isNode){if(isNode){process.stderr.write("Fatal "+(e instanceof Error?e.stack:e)+"\n");process.exit(2);}else{this.throwLater(e);}};Async.prototype.throwLater=function(fn,arg){if(arguments.length===1){arg=fn;fn=function fn(){throw arg;};}if(typeof setTimeout!=="undefined"){setTimeout(function(){fn(arg);},0);}else try{this._schedule(function(){fn(arg);});}catch(e){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");}};function AsyncInvokeLater(fn,receiver,arg){this._lateQueue.push(fn,receiver,arg);this._queueTick();}function AsyncInvoke(fn,receiver,arg){this._normalQueue.push(fn,receiver,arg);this._queueTick();}function AsyncSettlePromises(promise){this._normalQueue._pushOne(promise);this._queueTick();}if(!util.hasDevTools){Async.prototype.invokeLater=AsyncInvokeLater;Async.prototype.invoke=AsyncInvoke;Async.prototype.settlePromises=AsyncSettlePromises;}else{Async.prototype.invokeLater=function(fn,receiver,arg){if(this._trampolineEnabled){AsyncInvokeLater.call(this,fn,receiver,arg);}else{this._schedule(function(){setTimeout(function(){fn.call(receiver,arg);},100);});}};Async.prototype.invoke=function(fn,receiver,arg){if(this._trampolineEnabled){AsyncInvoke.call(this,fn,receiver,arg);}else{this._schedule(function(){fn.call(receiver,arg);});}};Async.prototype.settlePromises=function(promise){if(this._trampolineEnabled){AsyncSettlePromises.call(this,promise);}else{this._schedule(function(){promise._settlePromises();});}};}Async.prototype.invokeFirst=function(fn,receiver,arg){this._normalQueue.unshift(fn,receiver,arg);this._queueTick();};Async.prototype._drainQueue=function(queue){while(queue.length()>0){var fn=queue.shift();if(typeof fn!=="function"){fn._settlePromises();continue;}var receiver=queue.shift();var arg=queue.shift();fn.call(receiver,arg);}};Async.prototype._drainQueues=function(){this._drainQueue(this._normalQueue);this._reset();this._haveDrainedQueues=true;this._drainQueue(this._lateQueue);};Async.prototype._queueTick=function(){if(!this._isTickUsed){this._isTickUsed=true;this._schedule(this.drainQueues);}};Async.prototype._reset=function(){this._isTickUsed=false;};module.exports=Async;module.exports.firstLineError=firstLineError;},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,debug){var calledBind=false;var rejectThis=function rejectThis(_,e){this._reject(e);};var targetRejected=function targetRejected(e,context){context.promiseRejectionQueued=true;context.bindingPromise._then(rejectThis,rejectThis,null,this,e);};var bindingResolved=function bindingResolved(thisArg,context){if((this._bitField&50397184)===0){this._resolveCallback(context.target);}};var bindingRejected=function bindingRejected(e,context){if(!context.promiseRejectionQueued)this._reject(e);};Promise.prototype.bind=function(thisArg){if(!calledBind){calledBind=true;Promise.prototype._propagateFrom=debug.propagateFromFunction();Promise.prototype._boundValue=debug.boundValueFunction();}var maybePromise=tryConvertToPromise(thisArg);var ret=new Promise(INTERNAL);ret._propagateFrom(this,1);var target=this._target();ret._setBoundTo(maybePromise);if(maybePromise instanceof Promise){var context={promiseRejectionQueued:false,promise:ret,target:target,bindingPromise:maybePromise};target._then(INTERNAL,targetRejected,undefined,ret,context);maybePromise._then(bindingResolved,bindingRejected,undefined,ret,context);ret._setOnCancel(maybePromise);}else{ret._resolveCallback(target);}return ret;};Promise.prototype._setBoundTo=function(obj){if(obj!==undefined){this._bitField=this._bitField|2097152;this._boundTo=obj;}else{this._bitField=this._bitField&~2097152;}};Promise.prototype._isBound=function(){return(this._bitField&2097152)===2097152;};Promise.bind=function(thisArg,value){return Promise.resolve(value).bind(thisArg);};};},{}],4:[function(_dereq_,module,exports){"use strict";var old;if(typeof Promise!=="undefined")old=Promise;function noConflict(){try{if(Promise===bluebird)Promise=old;}catch(e){}return bluebird;}var bluebird=_dereq_("./promise")();bluebird.noConflict=noConflict;module.exports=bluebird;},{"./promise":22}],5:[function(_dereq_,module,exports){"use strict";var cr=Object.create;if(cr){var callerCache=cr(null);var getterCache=cr(null);callerCache[" size"]=getterCache[" size"]=0;}module.exports=function(Promise){var util=_dereq_("./util");var canEvaluate=util.canEvaluate;var isIdentifier=util.isIdentifier;var getMethodCaller;var getGetter;if(false){var makeMethodCaller=function makeMethodCaller(methodName){return new Function("ensureMethod","                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g,methodName))(ensureMethod);};var makeGetter=function makeGetter(propertyName){return new Function("obj","                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName",propertyName));};var getCompiled=function getCompiled(name,compiler,cache){var ret=cache[name];if(typeof ret!=="function"){if(!isIdentifier(name)){return null;}ret=compiler(name);cache[name]=ret;cache[" size"]++;if(cache[" size"]>512){var keys=Object.keys(cache);for(var i=0;i<256;++i){delete cache[keys[i]];}cache[" size"]=keys.length-256;}}return ret;};getMethodCaller=function getMethodCaller(name){return getCompiled(name,makeMethodCaller,callerCache);};getGetter=function getGetter(name){return getCompiled(name,makeGetter,getterCache);};}function ensureMethod(obj,methodName){var fn;if(obj!=null)fn=obj[methodName];if(typeof fn!=="function"){var message="Object "+util.classString(obj)+" has no method '"+util.toString(methodName)+"'";throw new Promise.TypeError(message);}return fn;}function caller(obj){var methodName=this.pop();var fn=ensureMethod(obj,methodName);return fn.apply(obj,this);}Promise.prototype.call=function(methodName){var args=[].slice.call(arguments,1);;if(false){if(canEvaluate){var maybeCaller=getMethodCaller(methodName);if(maybeCaller!==null){return this._then(maybeCaller,undefined,undefined,args,undefined);}}}args.push(methodName);return this._then(caller,undefined,undefined,args,undefined);};function namedGetter(obj){return obj[this];}function indexedGetter(obj){var index=+this;if(index<0)index=Math.max(0,index+obj.length);return obj[index];}Promise.prototype.get=function(propertyName){var isIndex=typeof propertyName==="number";var getter;if(!isIndex){if(canEvaluate){var maybeGetter=getGetter(propertyName);getter=maybeGetter!==null?maybeGetter:namedGetter;}else{getter=namedGetter;}}else{getter=indexedGetter;}return this._then(getter,undefined,undefined,propertyName,undefined);};};},{"./util":36}],6:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection,debug){var util=_dereq_("./util");var tryCatch=util.tryCatch;var errorObj=util.errorObj;var async=Promise._async;Promise.prototype["break"]=Promise.prototype.cancel=function(){if(!debug.cancellation())return this._warn("cancellation is disabled");var promise=this;var child=promise;while(promise.isCancellable()){if(!promise._cancelBy(child)){if(child._isFollowing()){child._followee().cancel();}else{child._cancelBranched();}break;}var parent=promise._cancellationParent;if(parent==null||!parent.isCancellable()){if(promise._isFollowing()){promise._followee().cancel();}else{promise._cancelBranched();}break;}else{if(promise._isFollowing())promise._followee().cancel();child=promise;promise=parent;}}};Promise.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--;};Promise.prototype._enoughBranchesHaveCancelled=function(){return this._branchesRemainingToCancel===undefined||this._branchesRemainingToCancel<=0;};Promise.prototype._cancelBy=function(canceller){if(canceller===this){this._branchesRemainingToCancel=0;this._invokeOnCancel();return true;}else{this._branchHasCancelled();if(this._enoughBranchesHaveCancelled()){this._invokeOnCancel();return true;}}return false;};Promise.prototype._cancelBranched=function(){if(this._enoughBranchesHaveCancelled()){this._cancel();}};Promise.prototype._cancel=function(){if(!this.isCancellable())return;this._setCancelled();async.invoke(this._cancelPromises,this,undefined);};Promise.prototype._cancelPromises=function(){if(this._length()>0)this._settlePromises();};Promise.prototype._unsetOnCancel=function(){this._onCancelField=undefined;};Promise.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled();};Promise.prototype._doInvokeOnCancel=function(onCancelCallback,internalOnly){if(util.isArray(onCancelCallback)){for(var i=0;i<onCancelCallback.length;++i){this._doInvokeOnCancel(onCancelCallback[i],internalOnly);}}else if(onCancelCallback!==undefined){if(typeof onCancelCallback==="function"){if(!internalOnly){var e=tryCatch(onCancelCallback).call(this._boundValue());if(e===errorObj){this._attachExtraTrace(e.e);async.throwLater(e.e);}}}else{onCancelCallback._resultCancelled(this);}}};Promise.prototype._invokeOnCancel=function(){var onCancelCallback=this._onCancel();this._unsetOnCancel();async.invoke(this._doInvokeOnCancel,this,onCancelCallback);};Promise.prototype._invokeInternalOnCancel=function(){if(this.isCancellable()){this._doInvokeOnCancel(this._onCancel(),true);this._unsetOnCancel();}};Promise.prototype._resultCancelled=function(){this.cancel();};};},{"./util":36}],7:[function(_dereq_,module,exports){"use strict";module.exports=function(NEXT_FILTER){var util=_dereq_("./util");var getKeys=_dereq_("./es5").keys;var tryCatch=util.tryCatch;var errorObj=util.errorObj;function catchFilter(instances,cb,promise){return function(e){var boundTo=promise._boundValue();predicateLoop:for(var i=0;i<instances.length;++i){var item=instances[i];if(item===Error||item!=null&&item.prototype instanceof Error){if(e instanceof item){return tryCatch(cb).call(boundTo,e);}}else if(typeof item==="function"){var matchesPredicate=tryCatch(item).call(boundTo,e);if(matchesPredicate===errorObj){return matchesPredicate;}else if(matchesPredicate){return tryCatch(cb).call(boundTo,e);}}else if(util.isObject(e)){var keys=getKeys(item);for(var j=0;j<keys.length;++j){var key=keys[j];if(item[key]!=e[key]){continue predicateLoop;}}return tryCatch(cb).call(boundTo,e);}}return NEXT_FILTER;};}return catchFilter;};},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){var longStackTraces=false;var contextStack=[];Promise.prototype._promiseCreated=function(){};Promise.prototype._pushContext=function(){};Promise.prototype._popContext=function(){return null;};Promise._peekContext=Promise.prototype._peekContext=function(){};function Context(){this._trace=new Context.CapturedTrace(peekContext());}Context.prototype._pushContext=function(){if(this._trace!==undefined){this._trace._promiseCreated=null;contextStack.push(this._trace);}};Context.prototype._popContext=function(){if(this._trace!==undefined){var trace=contextStack.pop();var ret=trace._promiseCreated;trace._promiseCreated=null;return ret;}return null;};function createContext(){if(longStackTraces)return new Context();}function peekContext(){var lastIndex=contextStack.length-1;if(lastIndex>=0){return contextStack[lastIndex];}return undefined;}Context.CapturedTrace=null;Context.create=createContext;Context.deactivateLongStackTraces=function(){};Context.activateLongStackTraces=function(){var Promise_pushContext=Promise.prototype._pushContext;var Promise_popContext=Promise.prototype._popContext;var Promise_PeekContext=Promise._peekContext;var Promise_peekContext=Promise.prototype._peekContext;var Promise_promiseCreated=Promise.prototype._promiseCreated;Context.deactivateLongStackTraces=function(){Promise.prototype._pushContext=Promise_pushContext;Promise.prototype._popContext=Promise_popContext;Promise._peekContext=Promise_PeekContext;Promise.prototype._peekContext=Promise_peekContext;Promise.prototype._promiseCreated=Promise_promiseCreated;longStackTraces=false;};longStackTraces=true;Promise.prototype._pushContext=Context.prototype._pushContext;Promise.prototype._popContext=Context.prototype._popContext;Promise._peekContext=Promise.prototype._peekContext=peekContext;Promise.prototype._promiseCreated=function(){var ctx=this._peekContext();if(ctx&&ctx._promiseCreated==null)ctx._promiseCreated=this;};};return Context;};},{}],9:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,Context){var getDomain=Promise._getDomain;var async=Promise._async;var Warning=_dereq_("./errors").Warning;var util=_dereq_("./util");var canAttachTrace=util.canAttachTrace;var unhandledRejectionHandled;var possiblyUnhandledRejection;var bluebirdFramePattern=/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;var stackFramePattern=null;var formatStack=null;var indentStackFrames=false;var printWarning;var debugging=!!(util.env("BLUEBIRD_DEBUG")!=0&&(true||util.env("BLUEBIRD_DEBUG")||util.env("NODE_ENV")==="development"));var warnings=!!(util.env("BLUEBIRD_WARNINGS")!=0&&(debugging||util.env("BLUEBIRD_WARNINGS")));var longStackTraces=!!(util.env("BLUEBIRD_LONG_STACK_TRACES")!=0&&(debugging||util.env("BLUEBIRD_LONG_STACK_TRACES")));var wForgottenReturn=util.env("BLUEBIRD_W_FORGOTTEN_RETURN")!=0&&(warnings||!!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));Promise.prototype.suppressUnhandledRejections=function(){var target=this._target();target._bitField=target._bitField&~1048576|524288;};Promise.prototype._ensurePossibleRejectionHandled=function(){if((this._bitField&524288)!==0)return;this._setRejectionIsUnhandled();async.invokeLater(this._notifyUnhandledRejection,this,undefined);};Promise.prototype._notifyUnhandledRejectionIsHandled=function(){fireRejectionEvent("rejectionHandled",unhandledRejectionHandled,undefined,this);};Promise.prototype._setReturnedNonUndefined=function(){this._bitField=this._bitField|268435456;};Promise.prototype._returnedNonUndefined=function(){return(this._bitField&268435456)!==0;};Promise.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var reason=this._settledValue();this._setUnhandledRejectionIsNotified();fireRejectionEvent("unhandledRejection",possiblyUnhandledRejection,reason,this);}};Promise.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=this._bitField|262144;};Promise.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=this._bitField&~262144;};Promise.prototype._isUnhandledRejectionNotified=function(){return(this._bitField&262144)>0;};Promise.prototype._setRejectionIsUnhandled=function(){this._bitField=this._bitField|1048576;};Promise.prototype._unsetRejectionIsUnhandled=function(){this._bitField=this._bitField&~1048576;if(this._isUnhandledRejectionNotified()){this._unsetUnhandledRejectionIsNotified();this._notifyUnhandledRejectionIsHandled();}};Promise.prototype._isRejectionUnhandled=function(){return(this._bitField&1048576)>0;};Promise.prototype._warn=function(message,shouldUseOwnTrace,promise){return warn(message,shouldUseOwnTrace,promise||this);};Promise.onPossiblyUnhandledRejection=function(fn){var domain=getDomain();possiblyUnhandledRejection=typeof fn==="function"?domain===null?fn:domain.bind(fn):undefined;};Promise.onUnhandledRejectionHandled=function(fn){var domain=getDomain();unhandledRejectionHandled=typeof fn==="function"?domain===null?fn:domain.bind(fn):undefined;};var disableLongStackTraces=function disableLongStackTraces(){};Promise.longStackTraces=function(){if(async.haveItemsQueued()&&!config.longStackTraces){throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");}if(!config.longStackTraces&&longStackTracesIsSupported()){var Promise_captureStackTrace=Promise.prototype._captureStackTrace;var Promise_attachExtraTrace=Promise.prototype._attachExtraTrace;config.longStackTraces=true;disableLongStackTraces=function disableLongStackTraces(){if(async.haveItemsQueued()&&!config.longStackTraces){throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");}Promise.prototype._captureStackTrace=Promise_captureStackTrace;Promise.prototype._attachExtraTrace=Promise_attachExtraTrace;Context.deactivateLongStackTraces();async.enableTrampoline();config.longStackTraces=false;};Promise.prototype._captureStackTrace=longStackTracesCaptureStackTrace;Promise.prototype._attachExtraTrace=longStackTracesAttachExtraTrace;Context.activateLongStackTraces();async.disableTrampolineIfNecessary();}};Promise.hasLongStackTraces=function(){return config.longStackTraces&&longStackTracesIsSupported();};var fireDomEvent=function(){try{var event=document.createEvent("CustomEvent");event.initCustomEvent("testingtheevent",false,true,{});util.global.dispatchEvent(event);return function(name,event){var domEvent=document.createEvent("CustomEvent");domEvent.initCustomEvent(name.toLowerCase(),false,true,event);return!util.global.dispatchEvent(domEvent);};}catch(e){}return function(){return false;};}();var fireGlobalEvent=function(){if(util.isNode){return function(){return process.emit.apply(process,arguments);};}else{if(!util.global){return function(){return false;};}return function(name){var methodName="on"+name.toLowerCase();var method=util.global[methodName];if(!method)return false;method.apply(util.global,[].slice.call(arguments,1));return true;};}}();function generatePromiseLifecycleEventObject(name,promise){return{promise:promise};}var eventToObjectGenerator={promiseCreated:generatePromiseLifecycleEventObject,promiseFulfilled:generatePromiseLifecycleEventObject,promiseRejected:generatePromiseLifecycleEventObject,promiseResolved:generatePromiseLifecycleEventObject,promiseCancelled:generatePromiseLifecycleEventObject,promiseChained:function promiseChained(name,promise,child){return{promise:promise,child:child};},warning:function warning(name,_warning){return{warning:_warning};},unhandledRejection:function unhandledRejection(name,reason,promise){return{reason:reason,promise:promise};},rejectionHandled:generatePromiseLifecycleEventObject};var activeFireEvent=function activeFireEvent(name){var globalEventFired=false;try{globalEventFired=fireGlobalEvent.apply(null,arguments);}catch(e){async.throwLater(e);globalEventFired=true;}var domEventFired=false;try{domEventFired=fireDomEvent(name,eventToObjectGenerator[name].apply(null,arguments));}catch(e){async.throwLater(e);domEventFired=true;}return domEventFired||globalEventFired;};Promise.config=function(opts){opts=Object(opts);if("longStackTraces"in opts){if(opts.longStackTraces){Promise.longStackTraces();}else if(!opts.longStackTraces&&Promise.hasLongStackTraces()){disableLongStackTraces();}}if("warnings"in opts){var warningsOption=opts.warnings;config.warnings=!!warningsOption;wForgottenReturn=config.warnings;if(util.isObject(warningsOption)){if("wForgottenReturn"in warningsOption){wForgottenReturn=!!warningsOption.wForgottenReturn;}}}if("cancellation"in opts&&opts.cancellation&&!config.cancellation){if(async.haveItemsQueued()){throw new Error("cannot enable cancellation after promises are in use");}Promise.prototype._clearCancellationData=cancellationClearCancellationData;Promise.prototype._propagateFrom=cancellationPropagateFrom;Promise.prototype._onCancel=cancellationOnCancel;Promise.prototype._setOnCancel=cancellationSetOnCancel;Promise.prototype._attachCancellationCallback=cancellationAttachCancellationCallback;Promise.prototype._execute=cancellationExecute;_propagateFromFunction=cancellationPropagateFrom;config.cancellation=true;}if("monitoring"in opts){if(opts.monitoring&&!config.monitoring){config.monitoring=true;Promise.prototype._fireEvent=activeFireEvent;}else if(!opts.monitoring&&config.monitoring){config.monitoring=false;Promise.prototype._fireEvent=defaultFireEvent;}}};function defaultFireEvent(){return false;}Promise.prototype._fireEvent=defaultFireEvent;Promise.prototype._execute=function(executor,resolve,reject){try{executor(resolve,reject);}catch(e){return e;}};Promise.prototype._onCancel=function(){};Promise.prototype._setOnCancel=function(handler){;};Promise.prototype._attachCancellationCallback=function(onCancel){;};Promise.prototype._captureStackTrace=function(){};Promise.prototype._attachExtraTrace=function(){};Promise.prototype._clearCancellationData=function(){};Promise.prototype._propagateFrom=function(parent,flags){;;};function cancellationExecute(executor,resolve,reject){var promise=this;try{executor(resolve,reject,function(onCancel){if(typeof onCancel!=="function"){throw new TypeError("onCancel must be a function, got: "+util.toString(onCancel));}promise._attachCancellationCallback(onCancel);});}catch(e){return e;}}function cancellationAttachCancellationCallback(onCancel){if(!this.isCancellable())return this;var previousOnCancel=this._onCancel();if(previousOnCancel!==undefined){if(util.isArray(previousOnCancel)){previousOnCancel.push(onCancel);}else{this._setOnCancel([previousOnCancel,onCancel]);}}else{this._setOnCancel(onCancel);}}function cancellationOnCancel(){return this._onCancelField;}function cancellationSetOnCancel(onCancel){this._onCancelField=onCancel;}function cancellationClearCancellationData(){this._cancellationParent=undefined;this._onCancelField=undefined;}function cancellationPropagateFrom(parent,flags){if((flags&1)!==0){this._cancellationParent=parent;var branchesRemainingToCancel=parent._branchesRemainingToCancel;if(branchesRemainingToCancel===undefined){branchesRemainingToCancel=0;}parent._branchesRemainingToCancel=branchesRemainingToCancel+1;}if((flags&2)!==0&&parent._isBound()){this._setBoundTo(parent._boundTo);}}function bindingPropagateFrom(parent,flags){if((flags&2)!==0&&parent._isBound()){this._setBoundTo(parent._boundTo);}}var _propagateFromFunction=bindingPropagateFrom;function _boundValueFunction(){var ret=this._boundTo;if(ret!==undefined){if(ret instanceof Promise){if(ret.isFulfilled()){return ret.value();}else{return undefined;}}}return ret;}function longStackTracesCaptureStackTrace(){this._trace=new CapturedTrace(this._peekContext());}function longStackTracesAttachExtraTrace(error,ignoreSelf){if(canAttachTrace(error)){var trace=this._trace;if(trace!==undefined){if(ignoreSelf)trace=trace._parent;}if(trace!==undefined){trace.attachExtraTrace(error);}else if(!error.__stackCleaned__){var parsed=parseStackAndMessage(error);util.notEnumerableProp(error,"stack",parsed.message+"\n"+parsed.stack.join("\n"));util.notEnumerableProp(error,"__stackCleaned__",true);}}}function checkForgottenReturns(returnValue,promiseCreated,name,promise,parent){if(returnValue===undefined&&promiseCreated!==null&&wForgottenReturn){if(parent!==undefined&&parent._returnedNonUndefined())return;if((promise._bitField&65535)===0)return;if(name)name=name+" ";var msg="a promise was created in a "+name+"handler but was not returned from it";promise._warn(msg,true,promiseCreated);}}function deprecated(name,replacement){var message=name+" is deprecated and will be removed in a future version.";if(replacement)message+=" Use "+replacement+" instead.";return warn(message);}function warn(message,shouldUseOwnTrace,promise){if(!config.warnings)return;var warning=new Warning(message);var ctx;if(shouldUseOwnTrace){promise._attachExtraTrace(warning);}else if(config.longStackTraces&&(ctx=Promise._peekContext())){ctx.attachExtraTrace(warning);}else{var parsed=parseStackAndMessage(warning);warning.stack=parsed.message+"\n"+parsed.stack.join("\n");}if(!activeFireEvent("warning",warning)){formatAndLogError(warning,"",true);}}function reconstructStack(message,stacks){for(var i=0;i<stacks.length-1;++i){stacks[i].push("From previous event:");stacks[i]=stacks[i].join("\n");}if(i<stacks.length){stacks[i]=stacks[i].join("\n");}return message+"\n"+stacks.join("\n");}function removeDuplicateOrEmptyJumps(stacks){for(var i=0;i<stacks.length;++i){if(stacks[i].length===0||i+1<stacks.length&&stacks[i][0]===stacks[i+1][0]){stacks.splice(i,1);i--;}}}function removeCommonRoots(stacks){var current=stacks[0];for(var i=1;i<stacks.length;++i){var prev=stacks[i];var currentLastIndex=current.length-1;var currentLastLine=current[currentLastIndex];var commonRootMeetPoint=-1;for(var j=prev.length-1;j>=0;--j){if(prev[j]===currentLastLine){commonRootMeetPoint=j;break;}}for(var j=commonRootMeetPoint;j>=0;--j){var line=prev[j];if(current[currentLastIndex]===line){current.pop();currentLastIndex--;}else{break;}}current=prev;}}function cleanStack(stack){var ret=[];for(var i=0;i<stack.length;++i){var line=stack[i];var isTraceLine="    (No stack trace)"===line||stackFramePattern.test(line);var isInternalFrame=isTraceLine&&shouldIgnore(line);if(isTraceLine&&!isInternalFrame){if(indentStackFrames&&line.charAt(0)!==" "){line="    "+line;}ret.push(line);}}return ret;}function stackFramesAsArray(error){var stack=error.stack.replace(/\s+$/g,"").split("\n");for(var i=0;i<stack.length;++i){var line=stack[i];if("    (No stack trace)"===line||stackFramePattern.test(line)){break;}}if(i>0){stack=stack.slice(i);}return stack;}function parseStackAndMessage(error){var stack=error.stack;var message=error.toString();stack=typeof stack==="string"&&stack.length>0?stackFramesAsArray(error):["    (No stack trace)"];return{message:message,stack:cleanStack(stack)};}function formatAndLogError(error,title,isSoft){if(typeof console!=="undefined"){var message;if(util.isObject(error)){var stack=error.stack;message=title+formatStack(stack,error);}else{message=title+String(error);}if(typeof printWarning==="function"){printWarning(message,isSoft);}else if(typeof console.log==="function"||_typeof(console.log)==="object"){console.log(message);}}}function fireRejectionEvent(name,localHandler,reason,promise){var localEventFired=false;try{if(typeof localHandler==="function"){localEventFired=true;if(name==="rejectionHandled"){localHandler(promise);}else{localHandler(reason,promise);}}}catch(e){async.throwLater(e);}if(name==="unhandledRejection"){if(!activeFireEvent(name,reason,promise)&&!localEventFired){formatAndLogError(reason,"Unhandled rejection ");}}else{activeFireEvent(name,promise);}}function formatNonError(obj){var str;if(typeof obj==="function"){str="[function "+(obj.name||"anonymous")+"]";}else{str=obj&&typeof obj.toString==="function"?obj.toString():util.toString(obj);var ruselessToString=/\[object [a-zA-Z0-9$_]+\]/;if(ruselessToString.test(str)){try{var newStr=JSON.stringify(obj);str=newStr;}catch(e){}}if(str.length===0){str="(empty array)";}}return"(<"+snip(str)+">, no stack trace)";}function snip(str){var maxChars=41;if(str.length<maxChars){return str;}return str.substr(0,maxChars-3)+"...";}function longStackTracesIsSupported(){return typeof captureStackTrace==="function";}var shouldIgnore=function shouldIgnore(){return false;};var parseLineInfoRegex=/[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;function parseLineInfo(line){var matches=line.match(parseLineInfoRegex);if(matches){return{fileName:matches[1],line:parseInt(matches[2],10)};}}function setBounds(firstLineError,lastLineError){if(!longStackTracesIsSupported())return;var firstStackLines=firstLineError.stack.split("\n");var lastStackLines=lastLineError.stack.split("\n");var firstIndex=-1;var lastIndex=-1;var firstFileName;var lastFileName;for(var i=0;i<firstStackLines.length;++i){var result=parseLineInfo(firstStackLines[i]);if(result){firstFileName=result.fileName;firstIndex=result.line;break;}}for(var i=0;i<lastStackLines.length;++i){var result=parseLineInfo(lastStackLines[i]);if(result){lastFileName=result.fileName;lastIndex=result.line;break;}}if(firstIndex<0||lastIndex<0||!firstFileName||!lastFileName||firstFileName!==lastFileName||firstIndex>=lastIndex){return;}shouldIgnore=function shouldIgnore(line){if(bluebirdFramePattern.test(line))return true;var info=parseLineInfo(line);if(info){if(info.fileName===firstFileName&&firstIndex<=info.line&&info.line<=lastIndex){return true;}}return false;};}function CapturedTrace(parent){this._parent=parent;this._promisesCreated=0;var length=this._length=1+(parent===undefined?0:parent._length);captureStackTrace(this,CapturedTrace);if(length>32)this.uncycle();}util.inherits(CapturedTrace,Error);Context.CapturedTrace=CapturedTrace;CapturedTrace.prototype.uncycle=function(){var length=this._length;if(length<2)return;var nodes=[];var stackToIndex={};for(var i=0,node=this;node!==undefined;++i){nodes.push(node);node=node._parent;}length=this._length=i;for(var i=length-1;i>=0;--i){var stack=nodes[i].stack;if(stackToIndex[stack]===undefined){stackToIndex[stack]=i;}}for(var i=0;i<length;++i){var currentStack=nodes[i].stack;var index=stackToIndex[currentStack];if(index!==undefined&&index!==i){if(index>0){nodes[index-1]._parent=undefined;nodes[index-1]._length=1;}nodes[i]._parent=undefined;nodes[i]._length=1;var cycleEdgeNode=i>0?nodes[i-1]:this;if(index<length-1){cycleEdgeNode._parent=nodes[index+1];cycleEdgeNode._parent.uncycle();cycleEdgeNode._length=cycleEdgeNode._parent._length+1;}else{cycleEdgeNode._parent=undefined;cycleEdgeNode._length=1;}var currentChildLength=cycleEdgeNode._length+1;for(var j=i-2;j>=0;--j){nodes[j]._length=currentChildLength;currentChildLength++;}return;}}};CapturedTrace.prototype.attachExtraTrace=function(error){if(error.__stackCleaned__)return;this.uncycle();var parsed=parseStackAndMessage(error);var message=parsed.message;var stacks=[parsed.stack];var trace=this;while(trace!==undefined){stacks.push(cleanStack(trace.stack.split("\n")));trace=trace._parent;}removeCommonRoots(stacks);removeDuplicateOrEmptyJumps(stacks);util.notEnumerableProp(error,"stack",reconstructStack(message,stacks));util.notEnumerableProp(error,"__stackCleaned__",true);};var captureStackTrace=function stackDetection(){var v8stackFramePattern=/^\s*at\s*/;var v8stackFormatter=function v8stackFormatter(stack,error){if(typeof stack==="string")return stack;if(error.name!==undefined&&error.message!==undefined){return error.toString();}return formatNonError(error);};if(typeof Error.stackTraceLimit==="number"&&typeof Error.captureStackTrace==="function"){Error.stackTraceLimit+=6;stackFramePattern=v8stackFramePattern;formatStack=v8stackFormatter;var captureStackTrace=Error.captureStackTrace;shouldIgnore=function shouldIgnore(line){return bluebirdFramePattern.test(line);};return function(receiver,ignoreUntil){Error.stackTraceLimit+=6;captureStackTrace(receiver,ignoreUntil);Error.stackTraceLimit-=6;};}var err=new Error();if(typeof err.stack==="string"&&err.stack.split("\n")[0].indexOf("stackDetection@")>=0){stackFramePattern=/@/;formatStack=v8stackFormatter;indentStackFrames=true;return function captureStackTrace(o){o.stack=new Error().stack;};}var hasStackAfterThrow;try{throw new Error();}catch(e){hasStackAfterThrow="stack"in e;}if(!("stack"in err)&&hasStackAfterThrow&&typeof Error.stackTraceLimit==="number"){stackFramePattern=v8stackFramePattern;formatStack=v8stackFormatter;return function captureStackTrace(o){Error.stackTraceLimit+=6;try{throw new Error();}catch(e){o.stack=e.stack;}Error.stackTraceLimit-=6;};}formatStack=function formatStack(stack,error){if(typeof stack==="string")return stack;if(((typeof error==="undefined"?"undefined":_typeof(error))==="object"||typeof error==="function")&&error.name!==undefined&&error.message!==undefined){return error.toString();}return formatNonError(error);};return null;}([]);if(typeof console!=="undefined"&&typeof console.warn!=="undefined"){printWarning=function printWarning(message){console.warn(message);};if(util.isNode&&process.stderr.isTTY){printWarning=function printWarning(message,isSoft){var color=isSoft?"\u001b[33m":"\u001b[31m";console.warn(color+message+"\u001b[0m\n");};}else if(!util.isNode&&typeof new Error().stack==="string"){printWarning=function printWarning(message,isSoft){console.warn("%c"+message,isSoft?"color: darkorange":"color: red");};}}var config={warnings:warnings,longStackTraces:false,cancellation:false,monitoring:false};if(longStackTraces)Promise.longStackTraces();return{longStackTraces:function longStackTraces(){return config.longStackTraces;},warnings:function warnings(){return config.warnings;},cancellation:function cancellation(){return config.cancellation;},monitoring:function monitoring(){return config.monitoring;},propagateFromFunction:function propagateFromFunction(){return _propagateFromFunction;},boundValueFunction:function boundValueFunction(){return _boundValueFunction;},checkForgottenReturns:checkForgottenReturns,setBounds:setBounds,warn:warn,deprecated:deprecated,CapturedTrace:CapturedTrace,fireDomEvent:fireDomEvent,fireGlobalEvent:fireGlobalEvent};};},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){function returner(){return this.value;}function thrower(){throw this.reason;}Promise.prototype["return"]=Promise.prototype.thenReturn=function(value){if(value instanceof Promise)value.suppressUnhandledRejections();return this._then(returner,undefined,undefined,{value:value},undefined);};Promise.prototype["throw"]=Promise.prototype.thenThrow=function(reason){return this._then(thrower,undefined,undefined,{reason:reason},undefined);};Promise.prototype.catchThrow=function(reason){if(arguments.length<=1){return this._then(undefined,thrower,undefined,{reason:reason},undefined);}else{var _reason=arguments[1];var handler=function handler(){throw _reason;};return this.caught(reason,handler);}};Promise.prototype.catchReturn=function(value){if(arguments.length<=1){if(value instanceof Promise)value.suppressUnhandledRejections();return this._then(undefined,returner,undefined,{value:value},undefined);}else{var _value=arguments[1];if(_value instanceof Promise)_value.suppressUnhandledRejections();var handler=function handler(){return _value;};return this.caught(value,handler);}};};},{}],11:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var PromiseReduce=Promise.reduce;var PromiseAll=Promise.all;function promiseAllThis(){return PromiseAll(this);}function PromiseMapSeries(promises,fn){return PromiseReduce(promises,fn,INTERNAL,INTERNAL);}Promise.prototype.each=function(fn){return this.mapSeries(fn)._then(promiseAllThis,undefined,undefined,this,undefined);};Promise.prototype.mapSeries=function(fn){return PromiseReduce(this,fn,INTERNAL,INTERNAL);};Promise.each=function(promises,fn){return PromiseMapSeries(promises,fn)._then(promiseAllThis,undefined,undefined,promises,undefined);};Promise.mapSeries=PromiseMapSeries;};},{}],12:[function(_dereq_,module,exports){"use strict";var es5=_dereq_("./es5");var Objectfreeze=es5.freeze;var util=_dereq_("./util");var inherits=util.inherits;var notEnumerableProp=util.notEnumerableProp;function subError(nameProperty,defaultMessage){function SubError(message){if(!(this instanceof SubError))return new SubError(message);notEnumerableProp(this,"message",typeof message==="string"?message:defaultMessage);notEnumerableProp(this,"name",nameProperty);if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor);}else{Error.call(this);}}inherits(SubError,Error);return SubError;}var _TypeError,_RangeError;var Warning=subError("Warning","warning");var CancellationError=subError("CancellationError","cancellation error");var TimeoutError=subError("TimeoutError","timeout error");var AggregateError=subError("AggregateError","aggregate error");try{_TypeError=TypeError;_RangeError=RangeError;}catch(e){_TypeError=subError("TypeError","type error");_RangeError=subError("RangeError","range error");}var methods=("join pop push shift unshift slice filter forEach some "+"every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");for(var i=0;i<methods.length;++i){if(typeof Array.prototype[methods[i]]==="function"){AggregateError.prototype[methods[i]]=Array.prototype[methods[i]];}}es5.defineProperty(AggregateError.prototype,"length",{value:0,configurable:false,writable:true,enumerable:true});AggregateError.prototype["isOperational"]=true;var level=0;AggregateError.prototype.toString=function(){var indent=Array(level*4+1).join(" ");var ret="\n"+indent+"AggregateError of:"+"\n";level++;indent=Array(level*4+1).join(" ");for(var i=0;i<this.length;++i){var str=this[i]===this?"[Circular AggregateError]":this[i]+"";var lines=str.split("\n");for(var j=0;j<lines.length;++j){lines[j]=indent+lines[j];}str=lines.join("\n");ret+=str+"\n";}level--;return ret;};function OperationalError(message){if(!(this instanceof OperationalError))return new OperationalError(message);notEnumerableProp(this,"name","OperationalError");notEnumerableProp(this,"message",message);this.cause=message;this["isOperational"]=true;if(message instanceof Error){notEnumerableProp(this,"message",message.message);notEnumerableProp(this,"stack",message.stack);}else if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor);}}inherits(OperationalError,Error);var errorTypes=Error["__BluebirdErrorTypes__"];if(!errorTypes){errorTypes=Objectfreeze({CancellationError:CancellationError,TimeoutError:TimeoutError,OperationalError:OperationalError,RejectionError:OperationalError,AggregateError:AggregateError});es5.defineProperty(Error,"__BluebirdErrorTypes__",{value:errorTypes,writable:false,enumerable:false,configurable:false});}module.exports={Error:Error,TypeError:_TypeError,RangeError:_RangeError,CancellationError:errorTypes.CancellationError,OperationalError:errorTypes.OperationalError,TimeoutError:errorTypes.TimeoutError,AggregateError:errorTypes.AggregateError,Warning:Warning};},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){var isES5=function(){"use strict";return this===undefined;}();if(isES5){module.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:isES5,propertyIsWritable:function propertyIsWritable(obj,prop){var descriptor=Object.getOwnPropertyDescriptor(obj,prop);return!!(!descriptor||descriptor.writable||descriptor.set);}};}else{var has={}.hasOwnProperty;var str={}.toString;var proto={}.constructor.prototype;var ObjectKeys=function ObjectKeys(o){var ret=[];for(var key in o){if(has.call(o,key)){ret.push(key);}}return ret;};var ObjectGetDescriptor=function ObjectGetDescriptor(o,key){return{value:o[key]};};var ObjectDefineProperty=function ObjectDefineProperty(o,key,desc){o[key]=desc.value;return o;};var ObjectFreeze=function ObjectFreeze(obj){return obj;};var ObjectGetPrototypeOf=function ObjectGetPrototypeOf(obj){try{return Object(obj).constructor.prototype;}catch(e){return proto;}};var ArrayIsArray=function ArrayIsArray(obj){try{return str.call(obj)==="[object Array]";}catch(e){return false;}};module.exports={isArray:ArrayIsArray,keys:ObjectKeys,names:ObjectKeys,defineProperty:ObjectDefineProperty,getDescriptor:ObjectGetDescriptor,freeze:ObjectFreeze,getPrototypeOf:ObjectGetPrototypeOf,isES5:isES5,propertyIsWritable:function propertyIsWritable(){return true;}};}},{}],14:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var PromiseMap=Promise.map;Promise.prototype.filter=function(fn,options){return PromiseMap(this,fn,options,INTERNAL);};Promise.filter=function(promises,fn,options){return PromiseMap(promises,fn,options,INTERNAL);};};},{}],15:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,tryConvertToPromise){var util=_dereq_("./util");var CancellationError=Promise.CancellationError;var errorObj=util.errorObj;function PassThroughHandlerContext(promise,type,handler){this.promise=promise;this.type=type;this.handler=handler;this.called=false;this.cancelPromise=null;}PassThroughHandlerContext.prototype.isFinallyHandler=function(){return this.type===0;};function FinallyHandlerCancelReaction(finallyHandler){this.finallyHandler=finallyHandler;}FinallyHandlerCancelReaction.prototype._resultCancelled=function(){checkCancel(this.finallyHandler);};function checkCancel(ctx,reason){if(ctx.cancelPromise!=null){if(arguments.length>1){ctx.cancelPromise._reject(reason);}else{ctx.cancelPromise._cancel();}ctx.cancelPromise=null;return true;}return false;}function succeed(){return finallyHandler.call(this,this.promise._target()._settledValue());}function fail(reason){if(checkCancel(this,reason))return;errorObj.e=reason;return errorObj;}function finallyHandler(reasonOrValue){var promise=this.promise;var handler=this.handler;if(!this.called){this.called=true;var ret=this.isFinallyHandler()?handler.call(promise._boundValue()):handler.call(promise._boundValue(),reasonOrValue);if(ret!==undefined){promise._setReturnedNonUndefined();var maybePromise=tryConvertToPromise(ret,promise);if(maybePromise instanceof Promise){if(this.cancelPromise!=null){if(maybePromise.isCancelled()){var reason=new CancellationError("late cancellation observer");promise._attachExtraTrace(reason);errorObj.e=reason;return errorObj;}else if(maybePromise.isPending()){maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));}}return maybePromise._then(succeed,fail,undefined,this,undefined);}}}if(promise.isRejected()){checkCancel(this);errorObj.e=reasonOrValue;return errorObj;}else{checkCancel(this);return reasonOrValue;}}Promise.prototype._passThrough=function(handler,type,success,fail){if(typeof handler!=="function")return this.then();return this._then(success,fail,undefined,new PassThroughHandlerContext(this,type,handler),undefined);};Promise.prototype.lastly=Promise.prototype["finally"]=function(handler){return this._passThrough(handler,0,finallyHandler,finallyHandler);};Promise.prototype.tap=function(handler){return this._passThrough(handler,1,finallyHandler);};return PassThroughHandlerContext;};},{"./util":36}],16:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,apiRejection,INTERNAL,tryConvertToPromise,Proxyable,debug){var errors=_dereq_("./errors");var TypeError=errors.TypeError;var util=_dereq_("./util");var errorObj=util.errorObj;var tryCatch=util.tryCatch;var yieldHandlers=[];function promiseFromYieldHandler(value,yieldHandlers,traceParent){for(var i=0;i<yieldHandlers.length;++i){traceParent._pushContext();var result=tryCatch(yieldHandlers[i])(value);traceParent._popContext();if(result===errorObj){traceParent._pushContext();var ret=Promise.reject(errorObj.e);traceParent._popContext();return ret;}var maybePromise=tryConvertToPromise(result,traceParent);if(maybePromise instanceof Promise)return maybePromise;}return null;}function PromiseSpawn(generatorFunction,receiver,yieldHandler,stack){if(debug.cancellation()){var internal=new Promise(INTERNAL);var _finallyPromise=this._finallyPromise=new Promise(INTERNAL);this._promise=internal.lastly(function(){return _finallyPromise;});internal._captureStackTrace();internal._setOnCancel(this);}else{var promise=this._promise=new Promise(INTERNAL);promise._captureStackTrace();}this._stack=stack;this._generatorFunction=generatorFunction;this._receiver=receiver;this._generator=undefined;this._yieldHandlers=typeof yieldHandler==="function"?[yieldHandler].concat(yieldHandlers):yieldHandlers;this._yieldedPromise=null;this._cancellationPhase=false;}util.inherits(PromiseSpawn,Proxyable);PromiseSpawn.prototype._isResolved=function(){return this._promise===null;};PromiseSpawn.prototype._cleanup=function(){this._promise=this._generator=null;if(debug.cancellation()&&this._finallyPromise!==null){this._finallyPromise._fulfill();this._finallyPromise=null;}};PromiseSpawn.prototype._promiseCancelled=function(){if(this._isResolved())return;var implementsReturn=typeof this._generator["return"]!=="undefined";var result;if(!implementsReturn){var reason=new Promise.CancellationError("generator .return() sentinel");Promise.coroutine.returnSentinel=reason;this._promise._attachExtraTrace(reason);this._promise._pushContext();result=tryCatch(this._generator["throw"]).call(this._generator,reason);this._promise._popContext();}else{this._promise._pushContext();result=tryCatch(this._generator["return"]).call(this._generator,undefined);this._promise._popContext();}this._cancellationPhase=true;this._yieldedPromise=null;this._continue(result);};PromiseSpawn.prototype._promiseFulfilled=function(value){this._yieldedPromise=null;this._promise._pushContext();var result=tryCatch(this._generator.next).call(this._generator,value);this._promise._popContext();this._continue(result);};PromiseSpawn.prototype._promiseRejected=function(reason){this._yieldedPromise=null;this._promise._attachExtraTrace(reason);this._promise._pushContext();var result=tryCatch(this._generator["throw"]).call(this._generator,reason);this._promise._popContext();this._continue(result);};PromiseSpawn.prototype._resultCancelled=function(){if(this._yieldedPromise instanceof Promise){var promise=this._yieldedPromise;this._yieldedPromise=null;promise.cancel();}};PromiseSpawn.prototype.promise=function(){return this._promise;};PromiseSpawn.prototype._run=function(){this._generator=this._generatorFunction.call(this._receiver);this._receiver=this._generatorFunction=undefined;this._promiseFulfilled(undefined);};PromiseSpawn.prototype._continue=function(result){var promise=this._promise;if(result===errorObj){this._cleanup();if(this._cancellationPhase){return promise.cancel();}else{return promise._rejectCallback(result.e,false);}}var value=result.value;if(result.done===true){this._cleanup();if(this._cancellationPhase){return promise.cancel();}else{return promise._resolveCallback(value);}}else{var maybePromise=tryConvertToPromise(value,this._promise);if(!(maybePromise instanceof Promise)){maybePromise=promiseFromYieldHandler(maybePromise,this._yieldHandlers,this._promise);if(maybePromise===null){this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s",value)+"From coroutine:\n"+this._stack.split("\n").slice(1,-7).join("\n")));return;}}maybePromise=maybePromise._target();var bitField=maybePromise._bitField;;if((bitField&50397184)===0){this._yieldedPromise=maybePromise;maybePromise._proxy(this,null);}else if((bitField&33554432)!==0){this._promiseFulfilled(maybePromise._value());}else if((bitField&16777216)!==0){this._promiseRejected(maybePromise._reason());}else{this._promiseCancelled();}}};Promise.coroutine=function(generatorFunction,options){if(typeof generatorFunction!=="function"){throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");}var yieldHandler=Object(options).yieldHandler;var PromiseSpawn$=PromiseSpawn;var stack=new Error().stack;return function(){var generator=generatorFunction.apply(this,arguments);var spawn=new PromiseSpawn$(undefined,undefined,yieldHandler,stack);var ret=spawn.promise();spawn._generator=generator;spawn._promiseFulfilled(undefined);return ret;};};Promise.coroutine.addYieldHandler=function(fn){if(typeof fn!=="function"){throw new TypeError("expecting a function but got "+util.classString(fn));}yieldHandlers.push(fn);};Promise.spawn=function(generatorFunction){debug.deprecated("Promise.spawn()","Promise.coroutine()");if(typeof generatorFunction!=="function"){return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");}var spawn=new PromiseSpawn(generatorFunction,this);var ret=spawn.promise();spawn._run(Promise.spawn);return ret;};};},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,tryConvertToPromise,INTERNAL){var util=_dereq_("./util");var canEvaluate=util.canEvaluate;var tryCatch=util.tryCatch;var errorObj=util.errorObj;var reject;if(false){if(canEvaluate){var thenCallback=function thenCallback(i){return new Function("value","holder","                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g,i));};var promiseSetter=function promiseSetter(i){return new Function("promise","holder","                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g,i));};var generateHolderClass=function generateHolderClass(total){var props=new Array(total);for(var i=0;i<props.length;++i){props[i]="this.p"+(i+1);}var assignment=props.join(" = ")+" = null;";var cancellationCode="var promise;\n"+props.map(function(prop){return"                                                         \n\
	                promise = "+prop+";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";}).join("\n");var passedArguments=props.join(", ");var name="Holder$"+total;var code="return function(tryCatch, errorObj, Promise) {           \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    promise._pushContext();                                  \n\
	                    var callback = this.fn;                                  \n\
	                    var ret = tryCatch(callback)([ThePassedArguments]);      \n\
	                    promise._popContext();                                   \n\
	                    if (ret === errorObj) {                                  \n\
	                        promise._rejectCallback(ret.e, false);               \n\
	                    } else {                                                 \n\
	                        promise._resolveCallback(ret);                       \n\
	                    }                                                        \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise);                                      \n\
	        ";code=code.replace(/\[TheName\]/g,name).replace(/\[TheTotal\]/g,total).replace(/\[ThePassedArguments\]/g,passedArguments).replace(/\[TheProperties\]/g,assignment).replace(/\[CancellationCode\]/g,cancellationCode);return new Function("tryCatch","errorObj","Promise",code)(tryCatch,errorObj,Promise);};var holderClasses=[];var thenCallbacks=[];var promiseSetters=[];for(var i=0;i<8;++i){holderClasses.push(generateHolderClass(i+1));thenCallbacks.push(thenCallback(i+1));promiseSetters.push(promiseSetter(i+1));}reject=function reject(reason){this._reject(reason);};}}Promise.join=function(){var last=arguments.length-1;var fn;if(last>0&&typeof arguments[last]==="function"){fn=arguments[last];if(false){if(last<=8&&canEvaluate){var ret=new Promise(INTERNAL);ret._captureStackTrace();var HolderClass=holderClasses[last-1];var holder=new HolderClass(fn);var callbacks=thenCallbacks;for(var i=0;i<last;++i){var maybePromise=tryConvertToPromise(arguments[i],ret);if(maybePromise instanceof Promise){maybePromise=maybePromise._target();var bitField=maybePromise._bitField;;if((bitField&50397184)===0){maybePromise._then(callbacks[i],reject,undefined,ret,holder);promiseSetters[i](maybePromise,holder);}else if((bitField&33554432)!==0){callbacks[i].call(ret,maybePromise._value(),holder);}else if((bitField&16777216)!==0){ret._reject(maybePromise._reason());}else{ret._cancel();}}else{callbacks[i].call(ret,maybePromise,holder);}}if(!ret._isFateSealed()){ret._setAsyncGuaranteed();ret._setOnCancel(holder);}return ret;}}}var args=[].slice.call(arguments);;if(fn)args.pop();var ret=new PromiseArray(args).promise();return fn!==undefined?ret.spread(fn):ret;};};},{"./util":36}],18:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug){var getDomain=Promise._getDomain;var util=_dereq_("./util");var tryCatch=util.tryCatch;var errorObj=util.errorObj;var EMPTY_ARRAY=[];function MappingPromiseArray(promises,fn,limit,_filter){this.constructor$(promises);this._promise._captureStackTrace();var domain=getDomain();this._callback=domain===null?fn:domain.bind(fn);this._preservedValues=_filter===INTERNAL?new Array(this.length()):null;this._limit=limit;this._inFlight=0;this._queue=limit>=1?[]:EMPTY_ARRAY;this._init$(undefined,-2);}util.inherits(MappingPromiseArray,PromiseArray);MappingPromiseArray.prototype._init=function(){};MappingPromiseArray.prototype._promiseFulfilled=function(value,index){var values=this._values;var length=this.length();var preservedValues=this._preservedValues;var limit=this._limit;if(index<0){index=index*-1-1;values[index]=value;if(limit>=1){this._inFlight--;this._drainQueue();if(this._isResolved())return true;}}else{if(limit>=1&&this._inFlight>=limit){values[index]=value;this._queue.push(index);return false;}if(preservedValues!==null)preservedValues[index]=value;var promise=this._promise;var callback=this._callback;var receiver=promise._boundValue();promise._pushContext();var ret=tryCatch(callback).call(receiver,value,index,length);var promiseCreated=promise._popContext();debug.checkForgottenReturns(ret,promiseCreated,preservedValues!==null?"Promise.filter":"Promise.map",promise);if(ret===errorObj){this._reject(ret.e);return true;}var maybePromise=tryConvertToPromise(ret,this._promise);if(maybePromise instanceof Promise){maybePromise=maybePromise._target();var bitField=maybePromise._bitField;;if((bitField&50397184)===0){if(limit>=1)this._inFlight++;values[index]=maybePromise;maybePromise._proxy(this,(index+1)*-1);return false;}else if((bitField&33554432)!==0){ret=maybePromise._value();}else if((bitField&16777216)!==0){this._reject(maybePromise._reason());return true;}else{this._cancel();return true;}}values[index]=ret;}var totalResolved=++this._totalResolved;if(totalResolved>=length){if(preservedValues!==null){this._filter(values,preservedValues);}else{this._resolve(values);}return true;}return false;};MappingPromiseArray.prototype._drainQueue=function(){var queue=this._queue;var limit=this._limit;var values=this._values;while(queue.length>0&&this._inFlight<limit){if(this._isResolved())return;var index=queue.pop();this._promiseFulfilled(values[index],index);}};MappingPromiseArray.prototype._filter=function(booleans,values){var len=values.length;var ret=new Array(len);var j=0;for(var i=0;i<len;++i){if(booleans[i])ret[j++]=values[i];}ret.length=j;this._resolve(ret);};MappingPromiseArray.prototype.preservedValues=function(){return this._preservedValues;};function map(promises,fn,options,_filter){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var limit=0;if(options!==undefined){if((typeof options==="undefined"?"undefined":_typeof(options))==="object"&&options!==null){if(typeof options.concurrency!=="number"){return Promise.reject(new TypeError("'concurrency' must be a number but it is "+util.classString(options.concurrency)));}limit=options.concurrency;}else{return Promise.reject(new TypeError("options argument must be an object but it is "+util.classString(options)));}}limit=typeof limit==="number"&&isFinite(limit)&&limit>=1?limit:0;return new MappingPromiseArray(promises,fn,limit,_filter).promise();}Promise.prototype.map=function(fn,options){return map(this,fn,options,null);};Promise.map=function(promises,fn,options,_filter){return map(promises,fn,options,_filter);};};},{"./util":36}],19:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,apiRejection,debug){var util=_dereq_("./util");var tryCatch=util.tryCatch;Promise.method=function(fn){if(typeof fn!=="function"){throw new Promise.TypeError("expecting a function but got "+util.classString(fn));}return function(){var ret=new Promise(INTERNAL);ret._captureStackTrace();ret._pushContext();var value=tryCatch(fn).apply(this,arguments);var promiseCreated=ret._popContext();debug.checkForgottenReturns(value,promiseCreated,"Promise.method",ret);ret._resolveFromSyncValue(value);return ret;};};Promise.attempt=Promise["try"]=function(fn){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var ret=new Promise(INTERNAL);ret._captureStackTrace();ret._pushContext();var value;if(arguments.length>1){debug.deprecated("calling Promise.try with more than 1 argument");var arg=arguments[1];var ctx=arguments[2];value=util.isArray(arg)?tryCatch(fn).apply(ctx,arg):tryCatch(fn).call(ctx,arg);}else{value=tryCatch(fn)();}var promiseCreated=ret._popContext();debug.checkForgottenReturns(value,promiseCreated,"Promise.try",ret);ret._resolveFromSyncValue(value);return ret;};Promise.prototype._resolveFromSyncValue=function(value){if(value===util.errorObj){this._rejectCallback(value.e,false);}else{this._resolveCallback(value,true);}};};},{"./util":36}],20:[function(_dereq_,module,exports){"use strict";var util=_dereq_("./util");var maybeWrapAsError=util.maybeWrapAsError;var errors=_dereq_("./errors");var OperationalError=errors.OperationalError;var es5=_dereq_("./es5");function isUntypedError(obj){return obj instanceof Error&&es5.getPrototypeOf(obj)===Error.prototype;}var rErrorKey=/^(?:name|message|stack|cause)$/;function wrapAsOperationalError(obj){var ret;if(isUntypedError(obj)){ret=new OperationalError(obj);ret.name=obj.name;ret.message=obj.message;ret.stack=obj.stack;var keys=es5.keys(obj);for(var i=0;i<keys.length;++i){var key=keys[i];if(!rErrorKey.test(key)){ret[key]=obj[key];}}return ret;}util.markAsOriginatingFromRejection(obj);return obj;}function nodebackForPromise(promise,multiArgs){return function(err,value){if(promise===null)return;if(err){var wrapped=wrapAsOperationalError(maybeWrapAsError(err));promise._attachExtraTrace(wrapped);promise._reject(wrapped);}else if(!multiArgs){promise._fulfill(value);}else{var args=[].slice.call(arguments,1);;promise._fulfill(args);}promise=null;};}module.exports=nodebackForPromise;},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){var util=_dereq_("./util");var async=Promise._async;var tryCatch=util.tryCatch;var errorObj=util.errorObj;function spreadAdapter(val,nodeback){var promise=this;if(!util.isArray(val))return successAdapter.call(promise,val,nodeback);var ret=tryCatch(nodeback).apply(promise._boundValue(),[null].concat(val));if(ret===errorObj){async.throwLater(ret.e);}}function successAdapter(val,nodeback){var promise=this;var receiver=promise._boundValue();var ret=val===undefined?tryCatch(nodeback).call(receiver,null):tryCatch(nodeback).call(receiver,null,val);if(ret===errorObj){async.throwLater(ret.e);}}function errorAdapter(reason,nodeback){var promise=this;if(!reason){var newReason=new Error(reason+"");newReason.cause=reason;reason=newReason;}var ret=tryCatch(nodeback).call(promise._boundValue(),reason);if(ret===errorObj){async.throwLater(ret.e);}}Promise.prototype.asCallback=Promise.prototype.nodeify=function(nodeback,options){if(typeof nodeback=="function"){var adapter=successAdapter;if(options!==undefined&&Object(options).spread){adapter=spreadAdapter;}this._then(adapter,errorAdapter,undefined,this,nodeback);}return this;};};},{"./util":36}],22:[function(_dereq_,module,exports){"use strict";module.exports=function(){var makeSelfResolutionError=function makeSelfResolutionError(){return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");};var reflectHandler=function reflectHandler(){return new Promise.PromiseInspection(this._target());};var apiRejection=function apiRejection(msg){return Promise.reject(new TypeError(msg));};function Proxyable(){}var UNDEFINED_BINDING={};var util=_dereq_("./util");var getDomain;if(util.isNode){getDomain=function getDomain(){var ret=process.domain;if(ret===undefined)ret=null;return ret;};}else{getDomain=function getDomain(){return null;};}util.notEnumerableProp(Promise,"_getDomain",getDomain);var es5=_dereq_("./es5");var Async=_dereq_("./async");var async=new Async();es5.defineProperty(Promise,"_async",{value:async});var errors=_dereq_("./errors");var TypeError=Promise.TypeError=errors.TypeError;Promise.RangeError=errors.RangeError;var CancellationError=Promise.CancellationError=errors.CancellationError;Promise.TimeoutError=errors.TimeoutError;Promise.OperationalError=errors.OperationalError;Promise.RejectionError=errors.OperationalError;Promise.AggregateError=errors.AggregateError;var INTERNAL=function INTERNAL(){};var APPLY={};var NEXT_FILTER={};var tryConvertToPromise=_dereq_("./thenables")(Promise,INTERNAL);var PromiseArray=_dereq_("./promise_array")(Promise,INTERNAL,tryConvertToPromise,apiRejection,Proxyable);var Context=_dereq_("./context")(Promise);/*jshint unused:false*/var createContext=Context.create;var debug=_dereq_("./debuggability")(Promise,Context);var CapturedTrace=debug.CapturedTrace;var PassThroughHandlerContext=_dereq_("./finally")(Promise,tryConvertToPromise);var catchFilter=_dereq_("./catch_filter")(NEXT_FILTER);var nodebackForPromise=_dereq_("./nodeback");var errorObj=util.errorObj;var tryCatch=util.tryCatch;function check(self,executor){if(typeof executor!=="function"){throw new TypeError("expecting a function but got "+util.classString(executor));}if(self.constructor!==Promise){throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");}}function Promise(executor){this._bitField=0;this._fulfillmentHandler0=undefined;this._rejectionHandler0=undefined;this._promise0=undefined;this._receiver0=undefined;if(executor!==INTERNAL){check(this,executor);this._resolveFromExecutor(executor);}this._promiseCreated();this._fireEvent("promiseCreated",this);}Promise.prototype.toString=function(){return"[object Promise]";};Promise.prototype.caught=Promise.prototype["catch"]=function(fn){var len=arguments.length;if(len>1){var catchInstances=new Array(len-1),j=0,i;for(i=0;i<len-1;++i){var item=arguments[i];if(util.isObject(item)){catchInstances[j++]=item;}else{return apiRejection("expecting an object but got "+util.classString(item));}}catchInstances.length=j;fn=arguments[i];return this.then(undefined,catchFilter(catchInstances,fn,this));}return this.then(undefined,fn);};Promise.prototype.reflect=function(){return this._then(reflectHandler,reflectHandler,undefined,this,undefined);};Promise.prototype.then=function(didFulfill,didReject){if(debug.warnings()&&arguments.length>0&&typeof didFulfill!=="function"&&typeof didReject!=="function"){var msg=".then() only accepts functions but was passed: "+util.classString(didFulfill);if(arguments.length>1){msg+=", "+util.classString(didReject);}this._warn(msg);}return this._then(didFulfill,didReject,undefined,undefined,undefined);};Promise.prototype.done=function(didFulfill,didReject){var promise=this._then(didFulfill,didReject,undefined,undefined,undefined);promise._setIsFinal();};Promise.prototype.spread=function(fn){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}return this.all()._then(fn,undefined,undefined,APPLY,undefined);};Promise.prototype.toJSON=function(){var ret={isFulfilled:false,isRejected:false,fulfillmentValue:undefined,rejectionReason:undefined};if(this.isFulfilled()){ret.fulfillmentValue=this.value();ret.isFulfilled=true;}else if(this.isRejected()){ret.rejectionReason=this.reason();ret.isRejected=true;}return ret;};Promise.prototype.all=function(){if(arguments.length>0){this._warn(".all() was passed arguments but it does not take any");}return new PromiseArray(this).promise();};Promise.prototype.error=function(fn){return this.caught(util.originatesFromRejection,fn);};Promise.getNewLibraryCopy=module.exports;Promise.is=function(val){return val instanceof Promise;};Promise.fromNode=Promise.fromCallback=function(fn){var ret=new Promise(INTERNAL);ret._captureStackTrace();var multiArgs=arguments.length>1?!!Object(arguments[1]).multiArgs:false;var result=tryCatch(fn)(nodebackForPromise(ret,multiArgs));if(result===errorObj){ret._rejectCallback(result.e,true);}if(!ret._isFateSealed())ret._setAsyncGuaranteed();return ret;};Promise.all=function(promises){return new PromiseArray(promises).promise();};Promise.cast=function(obj){var ret=tryConvertToPromise(obj);if(!(ret instanceof Promise)){ret=new Promise(INTERNAL);ret._captureStackTrace();ret._setFulfilled();ret._rejectionHandler0=obj;}return ret;};Promise.resolve=Promise.fulfilled=Promise.cast;Promise.reject=Promise.rejected=function(reason){var ret=new Promise(INTERNAL);ret._captureStackTrace();ret._rejectCallback(reason,true);return ret;};Promise.setScheduler=function(fn){if(typeof fn!=="function"){throw new TypeError("expecting a function but got "+util.classString(fn));}return async.setScheduler(fn);};Promise.prototype._then=function(didFulfill,didReject,_,receiver,internalData){var haveInternalData=internalData!==undefined;var promise=haveInternalData?internalData:new Promise(INTERNAL);var target=this._target();var bitField=target._bitField;if(!haveInternalData){promise._propagateFrom(this,3);promise._captureStackTrace();if(receiver===undefined&&(this._bitField&2097152)!==0){if(!((bitField&50397184)===0)){receiver=this._boundValue();}else{receiver=target===this?undefined:this._boundTo;}}this._fireEvent("promiseChained",this,promise);}var domain=getDomain();if(!((bitField&50397184)===0)){var handler,value,settler=target._settlePromiseCtx;if((bitField&33554432)!==0){value=target._rejectionHandler0;handler=didFulfill;}else if((bitField&16777216)!==0){value=target._fulfillmentHandler0;handler=didReject;target._unsetRejectionIsUnhandled();}else{settler=target._settlePromiseLateCancellationObserver;value=new CancellationError("late cancellation observer");target._attachExtraTrace(value);handler=didReject;}async.invoke(settler,target,{handler:domain===null?handler:typeof handler==="function"&&domain.bind(handler),promise:promise,receiver:receiver,value:value});}else{target._addCallbacks(didFulfill,didReject,promise,receiver,domain);}return promise;};Promise.prototype._length=function(){return this._bitField&65535;};Promise.prototype._isFateSealed=function(){return(this._bitField&117506048)!==0;};Promise.prototype._isFollowing=function(){return(this._bitField&67108864)===67108864;};Promise.prototype._setLength=function(len){this._bitField=this._bitField&-65536|len&65535;};Promise.prototype._setFulfilled=function(){this._bitField=this._bitField|33554432;this._fireEvent("promiseFulfilled",this);};Promise.prototype._setRejected=function(){this._bitField=this._bitField|16777216;this._fireEvent("promiseRejected",this);};Promise.prototype._setFollowing=function(){this._bitField=this._bitField|67108864;this._fireEvent("promiseResolved",this);};Promise.prototype._setIsFinal=function(){this._bitField=this._bitField|4194304;};Promise.prototype._isFinal=function(){return(this._bitField&4194304)>0;};Promise.prototype._unsetCancelled=function(){this._bitField=this._bitField&~65536;};Promise.prototype._setCancelled=function(){this._bitField=this._bitField|65536;this._fireEvent("promiseCancelled",this);};Promise.prototype._setAsyncGuaranteed=function(){if(async.hasCustomScheduler())return;this._bitField=this._bitField|134217728;};Promise.prototype._receiverAt=function(index){var ret=index===0?this._receiver0:this[index*4-4+3];if(ret===UNDEFINED_BINDING){return undefined;}else if(ret===undefined&&this._isBound()){return this._boundValue();}return ret;};Promise.prototype._promiseAt=function(index){return this[index*4-4+2];};Promise.prototype._fulfillmentHandlerAt=function(index){return this[index*4-4+0];};Promise.prototype._rejectionHandlerAt=function(index){return this[index*4-4+1];};Promise.prototype._boundValue=function(){};Promise.prototype._migrateCallback0=function(follower){var bitField=follower._bitField;var fulfill=follower._fulfillmentHandler0;var reject=follower._rejectionHandler0;var promise=follower._promise0;var receiver=follower._receiverAt(0);if(receiver===undefined)receiver=UNDEFINED_BINDING;this._addCallbacks(fulfill,reject,promise,receiver,null);};Promise.prototype._migrateCallbackAt=function(follower,index){var fulfill=follower._fulfillmentHandlerAt(index);var reject=follower._rejectionHandlerAt(index);var promise=follower._promiseAt(index);var receiver=follower._receiverAt(index);if(receiver===undefined)receiver=UNDEFINED_BINDING;this._addCallbacks(fulfill,reject,promise,receiver,null);};Promise.prototype._addCallbacks=function(fulfill,reject,promise,receiver,domain){var index=this._length();if(index>=65535-4){index=0;this._setLength(0);}if(index===0){this._promise0=promise;this._receiver0=receiver;if(typeof fulfill==="function"){this._fulfillmentHandler0=domain===null?fulfill:domain.bind(fulfill);}if(typeof reject==="function"){this._rejectionHandler0=domain===null?reject:domain.bind(reject);}}else{var base=index*4-4;this[base+2]=promise;this[base+3]=receiver;if(typeof fulfill==="function"){this[base+0]=domain===null?fulfill:domain.bind(fulfill);}if(typeof reject==="function"){this[base+1]=domain===null?reject:domain.bind(reject);}}this._setLength(index+1);return index;};Promise.prototype._proxy=function(proxyable,arg){this._addCallbacks(undefined,undefined,arg,proxyable,null);};Promise.prototype._resolveCallback=function(value,shouldBind){if((this._bitField&117506048)!==0)return;if(value===this)return this._rejectCallback(makeSelfResolutionError(),false);var maybePromise=tryConvertToPromise(value,this);if(!(maybePromise instanceof Promise))return this._fulfill(value);if(shouldBind)this._propagateFrom(maybePromise,2);var promise=maybePromise._target();if(promise===this){this._reject(makeSelfResolutionError());return;}var bitField=promise._bitField;if((bitField&50397184)===0){var len=this._length();if(len>0)promise._migrateCallback0(this);for(var i=1;i<len;++i){promise._migrateCallbackAt(this,i);}this._setFollowing();this._setLength(0);this._setFollowee(promise);}else if((bitField&33554432)!==0){this._fulfill(promise._value());}else if((bitField&16777216)!==0){this._reject(promise._reason());}else{var reason=new CancellationError("late cancellation observer");promise._attachExtraTrace(reason);this._reject(reason);}};Promise.prototype._rejectCallback=function(reason,synchronous,ignoreNonErrorWarnings){var trace=util.ensureErrorObject(reason);var hasStack=trace===reason;if(!hasStack&&!ignoreNonErrorWarnings&&debug.warnings()){var message="a promise was rejected with a non-error: "+util.classString(reason);this._warn(message,true);}this._attachExtraTrace(trace,synchronous?hasStack:false);this._reject(reason);};Promise.prototype._resolveFromExecutor=function(executor){var promise=this;this._captureStackTrace();this._pushContext();var synchronous=true;var r=this._execute(executor,function(value){promise._resolveCallback(value);},function(reason){promise._rejectCallback(reason,synchronous);});synchronous=false;this._popContext();if(r!==undefined){promise._rejectCallback(r,true);}};Promise.prototype._settlePromiseFromHandler=function(handler,receiver,value,promise){var bitField=promise._bitField;if((bitField&65536)!==0)return;promise._pushContext();var x;if(receiver===APPLY){if(!value||typeof value.length!=="number"){x=errorObj;x.e=new TypeError("cannot .spread() a non-array: "+util.classString(value));}else{x=tryCatch(handler).apply(this._boundValue(),value);}}else{x=tryCatch(handler).call(receiver,value);}var promiseCreated=promise._popContext();bitField=promise._bitField;if((bitField&65536)!==0)return;if(x===NEXT_FILTER){promise._reject(value);}else if(x===errorObj){promise._rejectCallback(x.e,false);}else{debug.checkForgottenReturns(x,promiseCreated,"",promise,this);promise._resolveCallback(x);}};Promise.prototype._target=function(){var ret=this;while(ret._isFollowing()){ret=ret._followee();}return ret;};Promise.prototype._followee=function(){return this._rejectionHandler0;};Promise.prototype._setFollowee=function(promise){this._rejectionHandler0=promise;};Promise.prototype._settlePromise=function(promise,handler,receiver,value){var isPromise=promise instanceof Promise;var bitField=this._bitField;var asyncGuaranteed=(bitField&134217728)!==0;if((bitField&65536)!==0){if(isPromise)promise._invokeInternalOnCancel();if(receiver instanceof PassThroughHandlerContext&&receiver.isFinallyHandler()){receiver.cancelPromise=promise;if(tryCatch(handler).call(receiver,value)===errorObj){promise._reject(errorObj.e);}}else if(handler===reflectHandler){promise._fulfill(reflectHandler.call(receiver));}else if(receiver instanceof Proxyable){receiver._promiseCancelled(promise);}else if(isPromise||promise instanceof PromiseArray){promise._cancel();}else{receiver.cancel();}}else if(typeof handler==="function"){if(!isPromise){handler.call(receiver,value,promise);}else{if(asyncGuaranteed)promise._setAsyncGuaranteed();this._settlePromiseFromHandler(handler,receiver,value,promise);}}else if(receiver instanceof Proxyable){if(!receiver._isResolved()){if((bitField&33554432)!==0){receiver._promiseFulfilled(value,promise);}else{receiver._promiseRejected(value,promise);}}}else if(isPromise){if(asyncGuaranteed)promise._setAsyncGuaranteed();if((bitField&33554432)!==0){promise._fulfill(value);}else{promise._reject(value);}}};Promise.prototype._settlePromiseLateCancellationObserver=function(ctx){var handler=ctx.handler;var promise=ctx.promise;var receiver=ctx.receiver;var value=ctx.value;if(typeof handler==="function"){if(!(promise instanceof Promise)){handler.call(receiver,value,promise);}else{this._settlePromiseFromHandler(handler,receiver,value,promise);}}else if(promise instanceof Promise){promise._reject(value);}};Promise.prototype._settlePromiseCtx=function(ctx){this._settlePromise(ctx.promise,ctx.handler,ctx.receiver,ctx.value);};Promise.prototype._settlePromise0=function(handler,value,bitField){var promise=this._promise0;var receiver=this._receiverAt(0);this._promise0=undefined;this._receiver0=undefined;this._settlePromise(promise,handler,receiver,value);};Promise.prototype._clearCallbackDataAtIndex=function(index){var base=index*4-4;this[base+2]=this[base+3]=this[base+0]=this[base+1]=undefined;};Promise.prototype._fulfill=function(value){var bitField=this._bitField;if((bitField&117506048)>>>16)return;if(value===this){var err=makeSelfResolutionError();this._attachExtraTrace(err);return this._reject(err);}this._setFulfilled();this._rejectionHandler0=value;if((bitField&65535)>0){if((bitField&134217728)!==0){this._settlePromises();}else{async.settlePromises(this);}}};Promise.prototype._reject=function(reason){var bitField=this._bitField;if((bitField&117506048)>>>16)return;this._setRejected();this._fulfillmentHandler0=reason;if(this._isFinal()){return async.fatalError(reason,util.isNode);}if((bitField&65535)>0){async.settlePromises(this);}else{this._ensurePossibleRejectionHandled();}};Promise.prototype._fulfillPromises=function(len,value){for(var i=1;i<len;i++){var handler=this._fulfillmentHandlerAt(i);var promise=this._promiseAt(i);var receiver=this._receiverAt(i);this._clearCallbackDataAtIndex(i);this._settlePromise(promise,handler,receiver,value);}};Promise.prototype._rejectPromises=function(len,reason){for(var i=1;i<len;i++){var handler=this._rejectionHandlerAt(i);var promise=this._promiseAt(i);var receiver=this._receiverAt(i);this._clearCallbackDataAtIndex(i);this._settlePromise(promise,handler,receiver,reason);}};Promise.prototype._settlePromises=function(){var bitField=this._bitField;var len=bitField&65535;if(len>0){if((bitField&16842752)!==0){var reason=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,reason,bitField);this._rejectPromises(len,reason);}else{var value=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,value,bitField);this._fulfillPromises(len,value);}this._setLength(0);}this._clearCancellationData();};Promise.prototype._settledValue=function(){var bitField=this._bitField;if((bitField&33554432)!==0){return this._rejectionHandler0;}else if((bitField&16777216)!==0){return this._fulfillmentHandler0;}};function deferResolve(v){this.promise._resolveCallback(v);}function deferReject(v){this.promise._rejectCallback(v,false);}Promise.defer=Promise.pending=function(){debug.deprecated("Promise.defer","new Promise");var promise=new Promise(INTERNAL);return{promise:promise,resolve:deferResolve,reject:deferReject};};util.notEnumerableProp(Promise,"_makeSelfResolutionError",makeSelfResolutionError);_dereq_("./method")(Promise,INTERNAL,tryConvertToPromise,apiRejection,debug);_dereq_("./bind")(Promise,INTERNAL,tryConvertToPromise,debug);_dereq_("./cancel")(Promise,PromiseArray,apiRejection,debug);_dereq_("./direct_resolve")(Promise);_dereq_("./synchronous_inspection")(Promise);_dereq_("./join")(Promise,PromiseArray,tryConvertToPromise,INTERNAL,debug);Promise.Promise=Promise;Promise.version="3.4.0";_dereq_('./map.js')(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug);_dereq_('./call_get.js')(Promise);_dereq_('./using.js')(Promise,apiRejection,tryConvertToPromise,createContext,INTERNAL,debug);_dereq_('./timers.js')(Promise,INTERNAL,debug);_dereq_('./generators.js')(Promise,apiRejection,INTERNAL,tryConvertToPromise,Proxyable,debug);_dereq_('./nodeify.js')(Promise);_dereq_('./promisify.js')(Promise,INTERNAL);_dereq_('./props.js')(Promise,PromiseArray,tryConvertToPromise,apiRejection);_dereq_('./race.js')(Promise,INTERNAL,tryConvertToPromise,apiRejection);_dereq_('./reduce.js')(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug);_dereq_('./settle.js')(Promise,PromiseArray,debug);_dereq_('./some.js')(Promise,PromiseArray,apiRejection);_dereq_('./filter.js')(Promise,INTERNAL);_dereq_('./each.js')(Promise,INTERNAL);_dereq_('./any.js')(Promise);util.toFastProperties(Promise);util.toFastProperties(Promise.prototype);function fillTypes(value){var p=new Promise(INTERNAL);p._fulfillmentHandler0=value;p._rejectionHandler0=value;p._promise0=value;p._receiver0=value;}// Complete slack tracking, opt out of field-type tracking and           
	// stabilize map                                                         
	fillTypes({a:1});fillTypes({b:2});fillTypes({c:3});fillTypes(1);fillTypes(function(){});fillTypes(undefined);fillTypes(false);fillTypes(new Promise(INTERNAL));debug.setBounds(Async.firstLineError,util.lastLineError);return Promise;};},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,apiRejection,Proxyable){var util=_dereq_("./util");var isArray=util.isArray;function toResolutionValue(val){switch(val){case-2:return[];case-3:return{};}}function PromiseArray(values){var promise=this._promise=new Promise(INTERNAL);if(values instanceof Promise){promise._propagateFrom(values,3);}promise._setOnCancel(this);this._values=values;this._length=0;this._totalResolved=0;this._init(undefined,-2);}util.inherits(PromiseArray,Proxyable);PromiseArray.prototype.length=function(){return this._length;};PromiseArray.prototype.promise=function(){return this._promise;};PromiseArray.prototype._init=function init(_,resolveValueIfEmpty){var values=tryConvertToPromise(this._values,this._promise);if(values instanceof Promise){values=values._target();var bitField=values._bitField;;this._values=values;if((bitField&50397184)===0){this._promise._setAsyncGuaranteed();return values._then(init,this._reject,undefined,this,resolveValueIfEmpty);}else if((bitField&33554432)!==0){values=values._value();}else if((bitField&16777216)!==0){return this._reject(values._reason());}else{return this._cancel();}}values=util.asArray(values);if(values===null){var err=apiRejection("expecting an array or an iterable object but got "+util.classString(values)).reason();this._promise._rejectCallback(err,false);return;}if(values.length===0){if(resolveValueIfEmpty===-5){this._resolveEmptyArray();}else{this._resolve(toResolutionValue(resolveValueIfEmpty));}return;}this._iterate(values);};PromiseArray.prototype._iterate=function(values){var len=this.getActualLength(values.length);this._length=len;this._values=this.shouldCopyValues()?new Array(len):this._values;var result=this._promise;var isResolved=false;var bitField=null;for(var i=0;i<len;++i){var maybePromise=tryConvertToPromise(values[i],result);if(maybePromise instanceof Promise){maybePromise=maybePromise._target();bitField=maybePromise._bitField;}else{bitField=null;}if(isResolved){if(bitField!==null){maybePromise.suppressUnhandledRejections();}}else if(bitField!==null){if((bitField&50397184)===0){maybePromise._proxy(this,i);this._values[i]=maybePromise;}else if((bitField&33554432)!==0){isResolved=this._promiseFulfilled(maybePromise._value(),i);}else if((bitField&16777216)!==0){isResolved=this._promiseRejected(maybePromise._reason(),i);}else{isResolved=this._promiseCancelled(i);}}else{isResolved=this._promiseFulfilled(maybePromise,i);}}if(!isResolved)result._setAsyncGuaranteed();};PromiseArray.prototype._isResolved=function(){return this._values===null;};PromiseArray.prototype._resolve=function(value){this._values=null;this._promise._fulfill(value);};PromiseArray.prototype._cancel=function(){if(this._isResolved()||!this._promise.isCancellable())return;this._values=null;this._promise._cancel();};PromiseArray.prototype._reject=function(reason){this._values=null;this._promise._rejectCallback(reason,false);};PromiseArray.prototype._promiseFulfilled=function(value,index){this._values[index]=value;var totalResolved=++this._totalResolved;if(totalResolved>=this._length){this._resolve(this._values);return true;}return false;};PromiseArray.prototype._promiseCancelled=function(){this._cancel();return true;};PromiseArray.prototype._promiseRejected=function(reason){this._totalResolved++;this._reject(reason);return true;};PromiseArray.prototype._resultCancelled=function(){if(this._isResolved())return;var values=this._values;this._cancel();if(values instanceof Promise){values.cancel();}else{for(var i=0;i<values.length;++i){if(values[i]instanceof Promise){values[i].cancel();}}}};PromiseArray.prototype.shouldCopyValues=function(){return true;};PromiseArray.prototype.getActualLength=function(len){return len;};return PromiseArray;};},{"./util":36}],24:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var THIS={};var util=_dereq_("./util");var nodebackForPromise=_dereq_("./nodeback");var withAppended=util.withAppended;var maybeWrapAsError=util.maybeWrapAsError;var canEvaluate=util.canEvaluate;var TypeError=_dereq_("./errors").TypeError;var defaultSuffix="Async";var defaultPromisified={__isPromisified__:true};var noCopyProps=["arity","length","name","arguments","caller","callee","prototype","__isPromisified__"];var noCopyPropsPattern=new RegExp("^(?:"+noCopyProps.join("|")+")$");var defaultFilter=function defaultFilter(name){return util.isIdentifier(name)&&name.charAt(0)!=="_"&&name!=="constructor";};function propsFilter(key){return!noCopyPropsPattern.test(key);}function isPromisified(fn){try{return fn.__isPromisified__===true;}catch(e){return false;}}function hasPromisified(obj,key,suffix){var val=util.getDataPropertyOrDefault(obj,key+suffix,defaultPromisified);return val?isPromisified(val):false;}function checkValid(ret,suffix,suffixRegexp){for(var i=0;i<ret.length;i+=2){var key=ret[i];if(suffixRegexp.test(key)){var keyWithoutAsyncSuffix=key.replace(suffixRegexp,"");for(var j=0;j<ret.length;j+=2){if(ret[j]===keyWithoutAsyncSuffix){throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s",suffix));}}}}}function promisifiableMethods(obj,suffix,suffixRegexp,filter){var keys=util.inheritedDataKeys(obj);var ret=[];for(var i=0;i<keys.length;++i){var key=keys[i];var value=obj[key];var passesDefaultFilter=filter===defaultFilter?true:defaultFilter(key,value,obj);if(typeof value==="function"&&!isPromisified(value)&&!hasPromisified(obj,key,suffix)&&filter(key,value,obj,passesDefaultFilter)){ret.push(key,value);}}checkValid(ret,suffix,suffixRegexp);return ret;}var escapeIdentRegex=function escapeIdentRegex(str){return str.replace(/([$])/,"\\$");};var makeNodePromisifiedEval;if(false){var switchCaseArgumentOrder=function switchCaseArgumentOrder(likelyArgumentCount){var ret=[likelyArgumentCount];var min=Math.max(0,likelyArgumentCount-1-3);for(var i=likelyArgumentCount-1;i>=min;--i){ret.push(i);}for(var i=likelyArgumentCount+1;i<=3;++i){ret.push(i);}return ret;};var argumentSequence=function argumentSequence(argumentCount){return util.filledRange(argumentCount,"_arg","");};var parameterDeclaration=function parameterDeclaration(parameterCount){return util.filledRange(Math.max(parameterCount,3),"_arg","");};var parameterCount=function parameterCount(fn){if(typeof fn.length==="number"){return Math.max(Math.min(fn.length,1023+1),0);}return 0;};makeNodePromisifiedEval=function makeNodePromisifiedEval(callback,receiver,originalName,fn,_,multiArgs){var newParameterCount=Math.max(0,parameterCount(fn)-1);var argumentOrder=switchCaseArgumentOrder(newParameterCount);var shouldProxyThis=typeof callback==="string"||receiver===THIS;function generateCallForArgumentCount(count){var args=argumentSequence(count).join(", ");var comma=count>0?", ":"";var ret;if(shouldProxyThis){ret="ret = callback.call(this, {{args}}, nodeback); break;\n";}else{ret=receiver===undefined?"ret = callback({{args}}, nodeback); break;\n":"ret = callback.call(receiver, {{args}}, nodeback); break;\n";}return ret.replace("{{args}}",args).replace(", ",comma);}function generateArgumentSwitchCase(){var ret="";for(var i=0;i<argumentOrder.length;++i){ret+="case "+argumentOrder[i]+":"+generateCallForArgumentCount(argumentOrder[i]);}ret+="                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]",shouldProxyThis?"ret = callback.apply(this, args);\n":"ret = callback.apply(receiver, args);\n");return ret;}var getFunctionCode=typeof callback==="string"?"this != null ? this['"+callback+"'] : fn":"fn";var body="'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, "+multiArgs+");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]",generateArgumentSwitchCase()).replace("[GetFunctionCode]",getFunctionCode);body=body.replace("Parameters",parameterDeclaration(newParameterCount));return new Function("Promise","fn","receiver","withAppended","maybeWrapAsError","nodebackForPromise","tryCatch","errorObj","notEnumerableProp","INTERNAL",body)(Promise,fn,receiver,withAppended,maybeWrapAsError,nodebackForPromise,util.tryCatch,util.errorObj,util.notEnumerableProp,INTERNAL);};}function makeNodePromisifiedClosure(callback,receiver,_,fn,__,multiArgs){var defaultThis=function(){return this;}();var method=callback;if(typeof method==="string"){callback=fn;}function promisified(){var _receiver=receiver;if(receiver===THIS)_receiver=this;var promise=new Promise(INTERNAL);promise._captureStackTrace();var cb=typeof method==="string"&&this!==defaultThis?this[method]:callback;var fn=nodebackForPromise(promise,multiArgs);try{cb.apply(_receiver,withAppended(arguments,fn));}catch(e){promise._rejectCallback(maybeWrapAsError(e),true,true);}if(!promise._isFateSealed())promise._setAsyncGuaranteed();return promise;}util.notEnumerableProp(promisified,"__isPromisified__",true);return promisified;}var makeNodePromisified=canEvaluate?makeNodePromisifiedEval:makeNodePromisifiedClosure;function promisifyAll(obj,suffix,filter,promisifier,multiArgs){var suffixRegexp=new RegExp(escapeIdentRegex(suffix)+"$");var methods=promisifiableMethods(obj,suffix,suffixRegexp,filter);for(var i=0,len=methods.length;i<len;i+=2){var key=methods[i];var fn=methods[i+1];var promisifiedKey=key+suffix;if(promisifier===makeNodePromisified){obj[promisifiedKey]=makeNodePromisified(key,THIS,key,fn,suffix,multiArgs);}else{var promisified=promisifier(fn,function(){return makeNodePromisified(key,THIS,key,fn,suffix,multiArgs);});util.notEnumerableProp(promisified,"__isPromisified__",true);obj[promisifiedKey]=promisified;}}util.toFastProperties(obj);return obj;}function promisify(callback,receiver,multiArgs){return makeNodePromisified(callback,receiver,undefined,callback,null,multiArgs);}Promise.promisify=function(fn,options){if(typeof fn!=="function"){throw new TypeError("expecting a function but got "+util.classString(fn));}if(isPromisified(fn)){return fn;}options=Object(options);var receiver=options.context===undefined?THIS:options.context;var multiArgs=!!options.multiArgs;var ret=promisify(fn,receiver,multiArgs);util.copyDescriptors(fn,ret,propsFilter);return ret;};Promise.promisifyAll=function(target,options){if(typeof target!=="function"&&(typeof target==="undefined"?"undefined":_typeof(target))!=="object"){throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");}options=Object(options);var multiArgs=!!options.multiArgs;var suffix=options.suffix;if(typeof suffix!=="string")suffix=defaultSuffix;var filter=options.filter;if(typeof filter!=="function")filter=defaultFilter;var promisifier=options.promisifier;if(typeof promisifier!=="function")promisifier=makeNodePromisified;if(!util.isIdentifier(suffix)){throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");}var keys=util.inheritedDataKeys(target);for(var i=0;i<keys.length;++i){var value=target[keys[i]];if(keys[i]!=="constructor"&&util.isClass(value)){promisifyAll(value.prototype,suffix,filter,promisifier,multiArgs);promisifyAll(value,suffix,filter,promisifier,multiArgs);}}return promisifyAll(target,suffix,filter,promisifier,multiArgs);};};},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,tryConvertToPromise,apiRejection){var util=_dereq_("./util");var isObject=util.isObject;var es5=_dereq_("./es5");var Es6Map;if(typeof Map==="function")Es6Map=Map;var mapToEntries=function(){var index=0;var size=0;function extractEntry(value,key){this[index]=value;this[index+size]=key;index++;}return function mapToEntries(map){size=map.size;index=0;var ret=new Array(map.size*2);map.forEach(extractEntry,ret);return ret;};}();var entriesToMap=function entriesToMap(entries){var ret=new Es6Map();var length=entries.length/2|0;for(var i=0;i<length;++i){var key=entries[length+i];var value=entries[i];ret.set(key,value);}return ret;};function PropertiesPromiseArray(obj){var isMap=false;var entries;if(Es6Map!==undefined&&obj instanceof Es6Map){entries=mapToEntries(obj);isMap=true;}else{var keys=es5.keys(obj);var len=keys.length;entries=new Array(len*2);for(var i=0;i<len;++i){var key=keys[i];entries[i]=obj[key];entries[i+len]=key;}}this.constructor$(entries);this._isMap=isMap;this._init$(undefined,-3);}util.inherits(PropertiesPromiseArray,PromiseArray);PropertiesPromiseArray.prototype._init=function(){};PropertiesPromiseArray.prototype._promiseFulfilled=function(value,index){this._values[index]=value;var totalResolved=++this._totalResolved;if(totalResolved>=this._length){var val;if(this._isMap){val=entriesToMap(this._values);}else{val={};var keyOffset=this.length();for(var i=0,len=this.length();i<len;++i){val[this._values[i+keyOffset]]=this._values[i];}}this._resolve(val);return true;}return false;};PropertiesPromiseArray.prototype.shouldCopyValues=function(){return false;};PropertiesPromiseArray.prototype.getActualLength=function(len){return len>>1;};function props(promises){var ret;var castValue=tryConvertToPromise(promises);if(!isObject(castValue)){return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");}else if(castValue instanceof Promise){ret=castValue._then(Promise.props,undefined,undefined,undefined,undefined);}else{ret=new PropertiesPromiseArray(castValue).promise();}if(castValue instanceof Promise){ret._propagateFrom(castValue,2);}return ret;}Promise.prototype.props=function(){return props(this);};Promise.props=function(promises){return props(promises);};};},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){"use strict";function arrayMove(src,srcIndex,dst,dstIndex,len){for(var j=0;j<len;++j){dst[j+dstIndex]=src[j+srcIndex];src[j+srcIndex]=void 0;}}function Queue(capacity){this._capacity=capacity;this._length=0;this._front=0;}Queue.prototype._willBeOverCapacity=function(size){return this._capacity<size;};Queue.prototype._pushOne=function(arg){var length=this.length();this._checkCapacity(length+1);var i=this._front+length&this._capacity-1;this[i]=arg;this._length=length+1;};Queue.prototype._unshiftOne=function(value){var capacity=this._capacity;this._checkCapacity(this.length()+1);var front=this._front;var i=(front-1&capacity-1^capacity)-capacity;this[i]=value;this._front=i;this._length=this.length()+1;};Queue.prototype.unshift=function(fn,receiver,arg){this._unshiftOne(arg);this._unshiftOne(receiver);this._unshiftOne(fn);};Queue.prototype.push=function(fn,receiver,arg){var length=this.length()+3;if(this._willBeOverCapacity(length)){this._pushOne(fn);this._pushOne(receiver);this._pushOne(arg);return;}var j=this._front+length-3;this._checkCapacity(length);var wrapMask=this._capacity-1;this[j+0&wrapMask]=fn;this[j+1&wrapMask]=receiver;this[j+2&wrapMask]=arg;this._length=length;};Queue.prototype.shift=function(){var front=this._front,ret=this[front];this[front]=undefined;this._front=front+1&this._capacity-1;this._length--;return ret;};Queue.prototype.length=function(){return this._length;};Queue.prototype._checkCapacity=function(size){if(this._capacity<size){this._resizeTo(this._capacity<<1);}};Queue.prototype._resizeTo=function(capacity){var oldCapacity=this._capacity;this._capacity=capacity;var front=this._front;var length=this._length;var moveItemsCount=front+length&oldCapacity-1;arrayMove(this,0,this,oldCapacity,moveItemsCount);};module.exports=Queue;},{}],27:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,apiRejection){var util=_dereq_("./util");var raceLater=function raceLater(promise){return promise.then(function(array){return race(array,promise);});};function race(promises,parent){var maybePromise=tryConvertToPromise(promises);if(maybePromise instanceof Promise){return raceLater(maybePromise);}else{promises=util.asArray(promises);if(promises===null)return apiRejection("expecting an array or an iterable object but got "+util.classString(promises));}var ret=new Promise(INTERNAL);if(parent!==undefined){ret._propagateFrom(parent,3);}var fulfill=ret._fulfill;var reject=ret._reject;for(var i=0,len=promises.length;i<len;++i){var val=promises[i];if(val===undefined&&!(i in promises)){continue;}Promise.cast(val)._then(fulfill,reject,undefined,ret,null);}return ret;}Promise.race=function(promises){return race(promises,undefined);};Promise.prototype.race=function(){return race(this,undefined);};};},{"./util":36}],28:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug){var getDomain=Promise._getDomain;var util=_dereq_("./util");var tryCatch=util.tryCatch;function ReductionPromiseArray(promises,fn,initialValue,_each){this.constructor$(promises);var domain=getDomain();this._fn=domain===null?fn:domain.bind(fn);if(initialValue!==undefined){initialValue=Promise.resolve(initialValue);initialValue._attachCancellationCallback(this);}this._initialValue=initialValue;this._currentCancellable=null;this._eachValues=_each===INTERNAL?[]:undefined;this._promise._captureStackTrace();this._init$(undefined,-5);}util.inherits(ReductionPromiseArray,PromiseArray);ReductionPromiseArray.prototype._gotAccum=function(accum){if(this._eachValues!==undefined&&accum!==INTERNAL){this._eachValues.push(accum);}};ReductionPromiseArray.prototype._eachComplete=function(value){this._eachValues.push(value);return this._eachValues;};ReductionPromiseArray.prototype._init=function(){};ReductionPromiseArray.prototype._resolveEmptyArray=function(){this._resolve(this._eachValues!==undefined?this._eachValues:this._initialValue);};ReductionPromiseArray.prototype.shouldCopyValues=function(){return false;};ReductionPromiseArray.prototype._resolve=function(value){this._promise._resolveCallback(value);this._values=null;};ReductionPromiseArray.prototype._resultCancelled=function(sender){if(sender===this._initialValue)return this._cancel();if(this._isResolved())return;this._resultCancelled$();if(this._currentCancellable instanceof Promise){this._currentCancellable.cancel();}if(this._initialValue instanceof Promise){this._initialValue.cancel();}};ReductionPromiseArray.prototype._iterate=function(values){this._values=values;var value;var i;var length=values.length;if(this._initialValue!==undefined){value=this._initialValue;i=0;}else{value=Promise.resolve(values[0]);i=1;}this._currentCancellable=value;if(!value.isRejected()){for(;i<length;++i){var ctx={accum:null,value:values[i],index:i,length:length,array:this};value=value._then(gotAccum,undefined,undefined,ctx,undefined);}}if(this._eachValues!==undefined){value=value._then(this._eachComplete,undefined,undefined,this,undefined);}value._then(completed,completed,undefined,value,this);};Promise.prototype.reduce=function(fn,initialValue){return reduce(this,fn,initialValue,null);};Promise.reduce=function(promises,fn,initialValue,_each){return reduce(promises,fn,initialValue,_each);};function completed(valueOrReason,array){if(this.isFulfilled()){array._resolve(valueOrReason);}else{array._reject(valueOrReason);}}function reduce(promises,fn,initialValue,_each){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var array=new ReductionPromiseArray(promises,fn,initialValue,_each);return array.promise();}function gotAccum(accum){this.accum=accum;this.array._gotAccum(accum);var value=tryConvertToPromise(this.value,this.array._promise);if(value instanceof Promise){this.array._currentCancellable=value;return value._then(gotValue,undefined,undefined,this,undefined);}else{return gotValue.call(this,value);}}function gotValue(value){var array=this.array;var promise=array._promise;var fn=tryCatch(array._fn);promise._pushContext();var ret;if(array._eachValues!==undefined){ret=fn.call(promise._boundValue(),value,this.index,this.length);}else{ret=fn.call(promise._boundValue(),this.accum,value,this.index,this.length);}if(ret instanceof Promise){array._currentCancellable=ret;}var promiseCreated=promise._popContext();debug.checkForgottenReturns(ret,promiseCreated,array._eachValues!==undefined?"Promise.each":"Promise.reduce",promise);return ret;}};},{"./util":36}],29:[function(_dereq_,module,exports){"use strict";var util=_dereq_("./util");var schedule;var noAsyncScheduler=function noAsyncScheduler(){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");};var NativePromise=util.getNativePromise();if(util.isNode&&typeof MutationObserver==="undefined"){var GlobalSetImmediate=global.setImmediate;var ProcessNextTick=process.nextTick;schedule=util.isRecentNode?function(fn){GlobalSetImmediate.call(global,fn);}:function(fn){ProcessNextTick.call(process,fn);};}else if(typeof NativePromise==="function"){var nativePromise=NativePromise.resolve();schedule=function schedule(fn){nativePromise.then(fn);};}else if(typeof MutationObserver!=="undefined"&&!(typeof window!=="undefined"&&window.navigator&&window.navigator.standalone)){schedule=function(){var div=document.createElement("div");var opts={attributes:true};var toggleScheduled=false;var div2=document.createElement("div");var o2=new MutationObserver(function(){div.classList.toggle("foo");toggleScheduled=false;});o2.observe(div2,opts);var scheduleToggle=function scheduleToggle(){if(toggleScheduled)return;toggleScheduled=true;div2.classList.toggle("foo");};return function schedule(fn){var o=new MutationObserver(function(){o.disconnect();fn();});o.observe(div,opts);scheduleToggle();};}();}else if(typeof setImmediate!=="undefined"){schedule=function schedule(fn){setImmediate(fn);};}else if(typeof setTimeout!=="undefined"){schedule=function schedule(fn){setTimeout(fn,0);};}else{schedule=noAsyncScheduler;}module.exports=schedule;},{"./util":36}],30:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,debug){var PromiseInspection=Promise.PromiseInspection;var util=_dereq_("./util");function SettledPromiseArray(values){this.constructor$(values);}util.inherits(SettledPromiseArray,PromiseArray);SettledPromiseArray.prototype._promiseResolved=function(index,inspection){this._values[index]=inspection;var totalResolved=++this._totalResolved;if(totalResolved>=this._length){this._resolve(this._values);return true;}return false;};SettledPromiseArray.prototype._promiseFulfilled=function(value,index){var ret=new PromiseInspection();ret._bitField=33554432;ret._settledValueField=value;return this._promiseResolved(index,ret);};SettledPromiseArray.prototype._promiseRejected=function(reason,index){var ret=new PromiseInspection();ret._bitField=16777216;ret._settledValueField=reason;return this._promiseResolved(index,ret);};Promise.settle=function(promises){debug.deprecated(".settle()",".reflect()");return new SettledPromiseArray(promises).promise();};Promise.prototype.settle=function(){return Promise.settle(this);};};},{"./util":36}],31:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection){var util=_dereq_("./util");var RangeError=_dereq_("./errors").RangeError;var AggregateError=_dereq_("./errors").AggregateError;var isArray=util.isArray;var CANCELLATION={};function SomePromiseArray(values){this.constructor$(values);this._howMany=0;this._unwrap=false;this._initialized=false;}util.inherits(SomePromiseArray,PromiseArray);SomePromiseArray.prototype._init=function(){if(!this._initialized){return;}if(this._howMany===0){this._resolve([]);return;}this._init$(undefined,-5);var isArrayResolved=isArray(this._values);if(!this._isResolved()&&isArrayResolved&&this._howMany>this._canPossiblyFulfill()){this._reject(this._getRangeError(this.length()));}};SomePromiseArray.prototype.init=function(){this._initialized=true;this._init();};SomePromiseArray.prototype.setUnwrap=function(){this._unwrap=true;};SomePromiseArray.prototype.howMany=function(){return this._howMany;};SomePromiseArray.prototype.setHowMany=function(count){this._howMany=count;};SomePromiseArray.prototype._promiseFulfilled=function(value){this._addFulfilled(value);if(this._fulfilled()===this.howMany()){this._values.length=this.howMany();if(this.howMany()===1&&this._unwrap){this._resolve(this._values[0]);}else{this._resolve(this._values);}return true;}return false;};SomePromiseArray.prototype._promiseRejected=function(reason){this._addRejected(reason);return this._checkOutcome();};SomePromiseArray.prototype._promiseCancelled=function(){if(this._values instanceof Promise||this._values==null){return this._cancel();}this._addRejected(CANCELLATION);return this._checkOutcome();};SomePromiseArray.prototype._checkOutcome=function(){if(this.howMany()>this._canPossiblyFulfill()){var e=new AggregateError();for(var i=this.length();i<this._values.length;++i){if(this._values[i]!==CANCELLATION){e.push(this._values[i]);}}if(e.length>0){this._reject(e);}else{this._cancel();}return true;}return false;};SomePromiseArray.prototype._fulfilled=function(){return this._totalResolved;};SomePromiseArray.prototype._rejected=function(){return this._values.length-this.length();};SomePromiseArray.prototype._addRejected=function(reason){this._values.push(reason);};SomePromiseArray.prototype._addFulfilled=function(value){this._values[this._totalResolved++]=value;};SomePromiseArray.prototype._canPossiblyFulfill=function(){return this.length()-this._rejected();};SomePromiseArray.prototype._getRangeError=function(count){var message="Input array must contain at least "+this._howMany+" items but contains only "+count+" items";return new RangeError(message);};SomePromiseArray.prototype._resolveEmptyArray=function(){this._reject(this._getRangeError(0));};function some(promises,howMany){if((howMany|0)!==howMany||howMany<0){return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");}var ret=new SomePromiseArray(promises);var promise=ret.promise();ret.setHowMany(howMany);ret.init();return promise;}Promise.some=function(promises,howMany){return some(promises,howMany);};Promise.prototype.some=function(howMany){return some(this,howMany);};Promise._SomePromiseArray=SomePromiseArray;};},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){function PromiseInspection(promise){if(promise!==undefined){promise=promise._target();this._bitField=promise._bitField;this._settledValueField=promise._isFateSealed()?promise._settledValue():undefined;}else{this._bitField=0;this._settledValueField=undefined;}}PromiseInspection.prototype._settledValue=function(){return this._settledValueField;};var value=PromiseInspection.prototype.value=function(){if(!this.isFulfilled()){throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");}return this._settledValue();};var reason=PromiseInspection.prototype.error=PromiseInspection.prototype.reason=function(){if(!this.isRejected()){throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");}return this._settledValue();};var isFulfilled=PromiseInspection.prototype.isFulfilled=function(){return(this._bitField&33554432)!==0;};var isRejected=PromiseInspection.prototype.isRejected=function(){return(this._bitField&16777216)!==0;};var isPending=PromiseInspection.prototype.isPending=function(){return(this._bitField&50397184)===0;};var isResolved=PromiseInspection.prototype.isResolved=function(){return(this._bitField&50331648)!==0;};PromiseInspection.prototype.isCancelled=Promise.prototype._isCancelled=function(){return(this._bitField&65536)===65536;};Promise.prototype.isCancelled=function(){return this._target()._isCancelled();};Promise.prototype.isPending=function(){return isPending.call(this._target());};Promise.prototype.isRejected=function(){return isRejected.call(this._target());};Promise.prototype.isFulfilled=function(){return isFulfilled.call(this._target());};Promise.prototype.isResolved=function(){return isResolved.call(this._target());};Promise.prototype.value=function(){return value.call(this._target());};Promise.prototype.reason=function(){var target=this._target();target._unsetRejectionIsUnhandled();return reason.call(target);};Promise.prototype._value=function(){return this._settledValue();};Promise.prototype._reason=function(){this._unsetRejectionIsUnhandled();return this._settledValue();};Promise.PromiseInspection=PromiseInspection;};},{}],33:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var util=_dereq_("./util");var errorObj=util.errorObj;var isObject=util.isObject;function tryConvertToPromise(obj,context){if(isObject(obj)){if(obj instanceof Promise)return obj;var then=getThen(obj);if(then===errorObj){if(context)context._pushContext();var ret=Promise.reject(then.e);if(context)context._popContext();return ret;}else if(typeof then==="function"){if(isAnyBluebirdPromise(obj)){var ret=new Promise(INTERNAL);obj._then(ret._fulfill,ret._reject,undefined,ret,null);return ret;}return doThenable(obj,then,context);}}return obj;}function doGetThen(obj){return obj.then;}function getThen(obj){try{return doGetThen(obj);}catch(e){errorObj.e=e;return errorObj;}}var hasProp={}.hasOwnProperty;function isAnyBluebirdPromise(obj){try{return hasProp.call(obj,"_promise0");}catch(e){return false;}}function doThenable(x,then,context){var promise=new Promise(INTERNAL);var ret=promise;if(context)context._pushContext();promise._captureStackTrace();if(context)context._popContext();var synchronous=true;var result=util.tryCatch(then).call(x,resolve,reject);synchronous=false;if(promise&&result===errorObj){promise._rejectCallback(result.e,true,true);promise=null;}function resolve(value){if(!promise)return;promise._resolveCallback(value);promise=null;}function reject(reason){if(!promise)return;promise._rejectCallback(reason,synchronous,true);promise=null;}return ret;}return tryConvertToPromise;};},{"./util":36}],34:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,debug){var util=_dereq_("./util");var TimeoutError=Promise.TimeoutError;function HandleWrapper(handle){this.handle=handle;}HandleWrapper.prototype._resultCancelled=function(){clearTimeout(this.handle);};var afterValue=function afterValue(value){return delay(+this).thenReturn(value);};var delay=Promise.delay=function(ms,value){var ret;var handle;if(value!==undefined){ret=Promise.resolve(value)._then(afterValue,null,null,ms,undefined);if(debug.cancellation()&&value instanceof Promise){ret._setOnCancel(value);}}else{ret=new Promise(INTERNAL);handle=setTimeout(function(){ret._fulfill();},+ms);if(debug.cancellation()){ret._setOnCancel(new HandleWrapper(handle));}}ret._setAsyncGuaranteed();return ret;};Promise.prototype.delay=function(ms){return delay(ms,this);};var afterTimeout=function afterTimeout(promise,message,parent){var err;if(typeof message!=="string"){if(message instanceof Error){err=message;}else{err=new TimeoutError("operation timed out");}}else{err=new TimeoutError(message);}util.markAsOriginatingFromRejection(err);promise._attachExtraTrace(err);promise._reject(err);if(parent!=null){parent.cancel();}};function successClear(value){clearTimeout(this.handle);return value;}function failureClear(reason){clearTimeout(this.handle);throw reason;}Promise.prototype.timeout=function(ms,message){ms=+ms;var ret,parent;var handleWrapper=new HandleWrapper(setTimeout(function timeoutTimeout(){if(ret.isPending()){afterTimeout(ret,message,parent);}},ms));if(debug.cancellation()){parent=this.then();ret=parent._then(successClear,failureClear,undefined,handleWrapper,undefined);ret._setOnCancel(handleWrapper);}else{ret=this._then(successClear,failureClear,undefined,handleWrapper,undefined);}return ret;};};},{"./util":36}],35:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,apiRejection,tryConvertToPromise,createContext,INTERNAL,debug){var util=_dereq_("./util");var TypeError=_dereq_("./errors").TypeError;var inherits=_dereq_("./util").inherits;var errorObj=util.errorObj;var tryCatch=util.tryCatch;var NULL={};function thrower(e){setTimeout(function(){throw e;},0);}function castPreservingDisposable(thenable){var maybePromise=tryConvertToPromise(thenable);if(maybePromise!==thenable&&typeof thenable._isDisposable==="function"&&typeof thenable._getDisposer==="function"&&thenable._isDisposable()){maybePromise._setDisposable(thenable._getDisposer());}return maybePromise;}function dispose(resources,inspection){var i=0;var len=resources.length;var ret=new Promise(INTERNAL);function iterator(){if(i>=len)return ret._fulfill();var maybePromise=castPreservingDisposable(resources[i++]);if(maybePromise instanceof Promise&&maybePromise._isDisposable()){try{maybePromise=tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection),resources.promise);}catch(e){return thrower(e);}if(maybePromise instanceof Promise){return maybePromise._then(iterator,thrower,null,null,null);}}iterator();}iterator();return ret;}function Disposer(data,promise,context){this._data=data;this._promise=promise;this._context=context;}Disposer.prototype.data=function(){return this._data;};Disposer.prototype.promise=function(){return this._promise;};Disposer.prototype.resource=function(){if(this.promise().isFulfilled()){return this.promise().value();}return NULL;};Disposer.prototype.tryDispose=function(inspection){var resource=this.resource();var context=this._context;if(context!==undefined)context._pushContext();var ret=resource!==NULL?this.doDispose(resource,inspection):null;if(context!==undefined)context._popContext();this._promise._unsetDisposable();this._data=null;return ret;};Disposer.isDisposer=function(d){return d!=null&&typeof d.resource==="function"&&typeof d.tryDispose==="function";};function FunctionDisposer(fn,promise,context){this.constructor$(fn,promise,context);}inherits(FunctionDisposer,Disposer);FunctionDisposer.prototype.doDispose=function(resource,inspection){var fn=this.data();return fn.call(resource,resource,inspection);};function maybeUnwrapDisposer(value){if(Disposer.isDisposer(value)){this.resources[this.index]._setDisposable(value);return value.promise();}return value;}function ResourceList(length){this.length=length;this.promise=null;this[length-1]=null;}ResourceList.prototype._resultCancelled=function(){var len=this.length;for(var i=0;i<len;++i){var item=this[i];if(item instanceof Promise){item.cancel();}}};Promise.using=function(){var len=arguments.length;if(len<2)return apiRejection("you must pass at least 2 arguments to Promise.using");var fn=arguments[len-1];if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var input;var spreadArgs=true;if(len===2&&Array.isArray(arguments[0])){input=arguments[0];len=input.length;spreadArgs=false;}else{input=arguments;len--;}var resources=new ResourceList(len);for(var i=0;i<len;++i){var resource=input[i];if(Disposer.isDisposer(resource)){var disposer=resource;resource=resource.promise();resource._setDisposable(disposer);}else{var maybePromise=tryConvertToPromise(resource);if(maybePromise instanceof Promise){resource=maybePromise._then(maybeUnwrapDisposer,null,null,{resources:resources,index:i},undefined);}}resources[i]=resource;}var reflectedResources=new Array(resources.length);for(var i=0;i<reflectedResources.length;++i){reflectedResources[i]=Promise.resolve(resources[i]).reflect();}var resultPromise=Promise.all(reflectedResources).then(function(inspections){for(var i=0;i<inspections.length;++i){var inspection=inspections[i];if(inspection.isRejected()){errorObj.e=inspection.error();return errorObj;}else if(!inspection.isFulfilled()){resultPromise.cancel();return;}inspections[i]=inspection.value();}promise._pushContext();fn=tryCatch(fn);var ret=spreadArgs?fn.apply(undefined,inspections):fn(inspections);var promiseCreated=promise._popContext();debug.checkForgottenReturns(ret,promiseCreated,"Promise.using",promise);return ret;});var promise=resultPromise.lastly(function(){var inspection=new Promise.PromiseInspection(resultPromise);return dispose(resources,inspection);});resources.promise=promise;promise._setOnCancel(resources);return promise;};Promise.prototype._setDisposable=function(disposer){this._bitField=this._bitField|131072;this._disposer=disposer;};Promise.prototype._isDisposable=function(){return(this._bitField&131072)>0;};Promise.prototype._getDisposer=function(){return this._disposer;};Promise.prototype._unsetDisposable=function(){this._bitField=this._bitField&~131072;this._disposer=undefined;};Promise.prototype.disposer=function(fn){if(typeof fn==="function"){return new FunctionDisposer(fn,this,createContext());}throw new TypeError();};};},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){"use strict";var es5=_dereq_("./es5");var canEvaluate=typeof navigator=="undefined";var errorObj={e:{}};var tryCatchTarget;var globalObject=typeof self!=="undefined"?self:typeof window!=="undefined"?window:typeof global!=="undefined"?global:this!==undefined?this:null;function tryCatcher(){try{var target=tryCatchTarget;tryCatchTarget=null;return target.apply(this,arguments);}catch(e){errorObj.e=e;return errorObj;}}function tryCatch(fn){tryCatchTarget=fn;return tryCatcher;}var inherits=function inherits(Child,Parent){var hasProp={}.hasOwnProperty;function T(){this.constructor=Child;this.constructor$=Parent;for(var propertyName in Parent.prototype){if(hasProp.call(Parent.prototype,propertyName)&&propertyName.charAt(propertyName.length-1)!=="$"){this[propertyName+"$"]=Parent.prototype[propertyName];}}}T.prototype=Parent.prototype;Child.prototype=new T();return Child.prototype;};function isPrimitive(val){return val==null||val===true||val===false||typeof val==="string"||typeof val==="number";}function isObject(value){return typeof value==="function"||(typeof value==="undefined"?"undefined":_typeof(value))==="object"&&value!==null;}function maybeWrapAsError(maybeError){if(!isPrimitive(maybeError))return maybeError;return new Error(safeToString(maybeError));}function withAppended(target,appendee){var len=target.length;var ret=new Array(len+1);var i;for(i=0;i<len;++i){ret[i]=target[i];}ret[i]=appendee;return ret;}function getDataPropertyOrDefault(obj,key,defaultValue){if(es5.isES5){var desc=Object.getOwnPropertyDescriptor(obj,key);if(desc!=null){return desc.get==null&&desc.set==null?desc.value:defaultValue;}}else{return{}.hasOwnProperty.call(obj,key)?obj[key]:undefined;}}function notEnumerableProp(obj,name,value){if(isPrimitive(obj))return obj;var descriptor={value:value,configurable:true,enumerable:false,writable:true};es5.defineProperty(obj,name,descriptor);return obj;}function thrower(r){throw r;}var inheritedDataKeys=function(){var excludedPrototypes=[Array.prototype,Object.prototype,Function.prototype];var isExcludedProto=function isExcludedProto(val){for(var i=0;i<excludedPrototypes.length;++i){if(excludedPrototypes[i]===val){return true;}}return false;};if(es5.isES5){var getKeys=Object.getOwnPropertyNames;return function(obj){var ret=[];var visitedKeys=Object.create(null);while(obj!=null&&!isExcludedProto(obj)){var keys;try{keys=getKeys(obj);}catch(e){return ret;}for(var i=0;i<keys.length;++i){var key=keys[i];if(visitedKeys[key])continue;visitedKeys[key]=true;var desc=Object.getOwnPropertyDescriptor(obj,key);if(desc!=null&&desc.get==null&&desc.set==null){ret.push(key);}}obj=es5.getPrototypeOf(obj);}return ret;};}else{var hasProp={}.hasOwnProperty;return function(obj){if(isExcludedProto(obj))return[];var ret=[];/*jshint forin:false */enumeration:for(var key in obj){if(hasProp.call(obj,key)){ret.push(key);}else{for(var i=0;i<excludedPrototypes.length;++i){if(hasProp.call(excludedPrototypes[i],key)){continue enumeration;}}ret.push(key);}}return ret;};}}();var thisAssignmentPattern=/this\s*\.\s*\S+\s*=/;function isClass(fn){try{if(typeof fn==="function"){var keys=es5.names(fn.prototype);var hasMethods=es5.isES5&&keys.length>1;var hasMethodsOtherThanConstructor=keys.length>0&&!(keys.length===1&&keys[0]==="constructor");var hasThisAssignmentAndStaticMethods=thisAssignmentPattern.test(fn+"")&&es5.names(fn).length>0;if(hasMethods||hasMethodsOtherThanConstructor||hasThisAssignmentAndStaticMethods){return true;}}return false;}catch(e){return false;}}function toFastProperties(obj){/*jshint -W027,-W055,-W031*/function FakeConstructor(){}FakeConstructor.prototype=obj;var l=8;while(l--){new FakeConstructor();}return obj;eval(obj);}var rident=/^[a-z$_][a-z$_0-9]*$/i;function isIdentifier(str){return rident.test(str);}function filledRange(count,prefix,suffix){var ret=new Array(count);for(var i=0;i<count;++i){ret[i]=prefix+i+suffix;}return ret;}function safeToString(obj){try{return obj+"";}catch(e){return"[no string representation]";}}function isError(obj){return obj!==null&&(typeof obj==="undefined"?"undefined":_typeof(obj))==="object"&&typeof obj.message==="string"&&typeof obj.name==="string";}function markAsOriginatingFromRejection(e){try{notEnumerableProp(e,"isOperational",true);}catch(ignore){}}function originatesFromRejection(e){if(e==null)return false;return e instanceof Error["__BluebirdErrorTypes__"].OperationalError||e["isOperational"]===true;}function canAttachTrace(obj){return isError(obj)&&es5.propertyIsWritable(obj,"stack");}var ensureErrorObject=function(){if(!("stack"in new Error())){return function(value){if(canAttachTrace(value))return value;try{throw new Error(safeToString(value));}catch(err){return err;}};}else{return function(value){if(canAttachTrace(value))return value;return new Error(safeToString(value));};}}();function classString(obj){return{}.toString.call(obj);}function copyDescriptors(from,to,filter){var keys=es5.names(from);for(var i=0;i<keys.length;++i){var key=keys[i];if(filter(key)){try{es5.defineProperty(to,key,es5.getDescriptor(from,key));}catch(ignore){}}}}var asArray=function asArray(v){if(es5.isArray(v)){return v;}return null;};if(typeof Symbol!=="undefined"&&Symbol.iterator){var ArrayFrom=typeof Array.from==="function"?function(v){return Array.from(v);}:function(v){var ret=[];var it=v[Symbol.iterator]();var itResult;while(!(itResult=it.next()).done){ret.push(itResult.value);}return ret;};asArray=function asArray(v){if(es5.isArray(v)){return v;}else if(v!=null&&typeof v[Symbol.iterator]==="function"){return ArrayFrom(v);}return null;};}var isNode=typeof process!=="undefined"&&classString(process).toLowerCase()==="[object process]";function env(key,def){return isNode?process.env[key]:def;}function getNativePromise(){if(typeof Promise==="function"){try{var promise=new Promise(function(){});if({}.toString.call(promise)==="[object Promise]"){return Promise;}}catch(e){}}}var ret={isClass:isClass,isIdentifier:isIdentifier,inheritedDataKeys:inheritedDataKeys,getDataPropertyOrDefault:getDataPropertyOrDefault,thrower:thrower,isArray:es5.isArray,asArray:asArray,notEnumerableProp:notEnumerableProp,isPrimitive:isPrimitive,isObject:isObject,isError:isError,canEvaluate:canEvaluate,errorObj:errorObj,tryCatch:tryCatch,inherits:inherits,withAppended:withAppended,maybeWrapAsError:maybeWrapAsError,toFastProperties:toFastProperties,filledRange:filledRange,toString:safeToString,canAttachTrace:canAttachTrace,ensureErrorObject:ensureErrorObject,originatesFromRejection:originatesFromRejection,markAsOriginatingFromRejection:markAsOriginatingFromRejection,classString:classString,copyDescriptors:copyDescriptors,hasDevTools:typeof chrome!=="undefined"&&chrome&&typeof chrome.loadTimes==="function",isNode:isNode,env:env,global:globalObject,getNativePromise:getNativePromise};ret.isRecentNode=ret.isNode&&function(){var version=process.versions.node.split(".").map(Number);return version[0]===0&&version[1]>10||version[0]>0;}();if(ret.isNode)ret.toFastProperties(process);try{throw new Error();}catch(e){ret.lastLineError=e;}module.exports=ret;},{"./es5":13}]},{},[4])(4);});;if(typeof window!=='undefined'&&window!==null){window.P=window.Promise;}else if(typeof self!=='undefined'&&self!==null){self.P=self.Promise;}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }()), __webpack_require__(192).setImmediate))

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    path: __webpack_require__(230),
	    pg: __webpack_require__(455),
	    minify: __webpack_require__(488),
	    array: __webpack_require__(492),
	    adapter: __webpack_require__(493),
	    result: __webpack_require__(494),
	    promise: __webpack_require__(495),
	    formatting: __webpack_require__(496),
	    helpers: __webpack_require__(497),
	    queryFile: __webpack_require__(506),
	    errors: __webpack_require__(508),
	    utils: __webpack_require__(500),
	    pubUtils: __webpack_require__(512),
	    mode: __webpack_require__(516),
	    types: __webpack_require__(517),
	    package: __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	};

	/**
	 * @author Vitaly Tomilov
	 * @module pg-promise
	 *
	 * @description
	 * ### Initialization Options
	 *
	 * Below is the complete list of _Initialization Options_ for the library.
	 *
	 * @param {object} [options]
	 * Library Initialization Options.
	 *
	 * @param {boolean} [options.pgFormatting=false]
	 * Redirects query formatting to PG.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {boolean} [options.pgNative=false]
	 * Use $[Native Bindings]. Library $[pg-native] must be installed, or else it will throw an error.
	 *
	 * This is a static property (can only be set prior to initialization).
	 *
	 * @param {object|function} [options.promiseLib=Promise]
	 * Override for the default promise library.
	 *
	 * This is a static property (can only be set prior to initialization).
	 *
	 * @param {boolean} [options.noLocking=false]
	 * Prevents protocol locking.
	 *
	 * By default, the library locks its protocol to read-only access, as a fool-proof mechanism.
	 * Specifically for the {@link event:extend extend} event this serves as a protection against overriding existing
	 * properties or trying to set them at the wrong time.
	 *
	 * If this provision gets in the way of using a mock-up framework for your tests, you can force
	 * the library to deactivate most of the locks by setting `noLocking` = `true` within the options.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {boolean} [options.capSQL=false]
	 * Capitalize any SQL generated by the library.
	 *
	 * By default, all internal SQL within the library is generated using the low case.
	 * If, however, you want all SQL to be capitalized instead, set `capSQL` = `true`.
	 *
	 * This is purely a cosmetic feature.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {boolean} [options.noWarnings]
	 * **Added in v.4.7.0**
	 *
	 * Disables all diagnostic warnings in the library (which is ill-advised).
	 *
	 * If it is not set (missing or `undefined`), it will default to the following:
	 * - `true`, if `NODE_ENV` != `development`
	 * - `false`, if `NODE_ENV` = `development`
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.connect]
	 * Global event {@link event:connect connect} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.disconnect]
	 * Global event {@link event:disconnect disconnect} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.query]
	 * Global event {@link event:query query} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.receive]
	 * Global event {@link event:receive receive} handler.
	 *
	 * @param {function} [options.task]
	 * Global event {@link event:task task} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.transact]
	 * Global event {@link event:transact transact} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.error]
	 * Global event {@link event:error error} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @param {function} [options.extend]
	 * Global event {@link event:extend extend} handler.
	 *
	 * This property can be set dynamically (before or after initialization).
	 *
	 * @example
	 *
	 * var options = {
	 *   // Initialization Options
	 * };
	 *
	 * var pgp = require('pg-promise')(options);
	 *
	 */
	function $main(options) {

	    var invalidInit;
	    if ($npm.utils.isNull(options)) {
	        options = {};
	    } else {
	        if (typeof options === 'string') {
	            // Check for invalid initialization: it must not be a connection string.
	            var pgModule = __webpack_require__.c[/*require.resolve*/(455)];
	            var pgCS = pgModule.require('pg-connection-string');
	            var cn = pgCS.parse(options);
	            invalidInit = cn && cn.database !== options;
	        }
	        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	            // Check for invalid initialization: it must not be a connection object.
	            invalidInit = 'host' in options || 'database' in options;
	        } else {
	            if (!invalidInit) {
	                throw new TypeError("Invalid initialization options.");
	            }
	        }
	    }

	    if (invalidInit) {
	        // The most common mistake in using the library - trying to pass in a database
	        // connection object or string as the library's initialization object.
	        //
	        // Steps for using the library:
	        //
	        // 1. Initialize the library:
	        //     var pgp = require('pg-promise')(/*initialization options*/);
	        // 2. Create a database object:
	        //     var db = pgp(connection);
	        //
	        // If you skip the first step, you will get this error.
	        throw new TypeError("Invalid library initialization: must initialize the library before creating a database object.");
	    }

	    var pg = $npm.pg,
	        p = $npm.promise(options.promiseLib);

	    var config = {
	        version: $npm.package.version,
	        promiseLib: p.promiseLib,
	        promise: p.promise
	    };

	    $npm.utils.addReadProp(config, '$npm', {}, true);

	    // Locking properties that cannot be changed later:
	    $npm.utils.addReadProp(options, 'promiseLib', options.promiseLib);
	    $npm.utils.addReadProp(options, 'pgNative', !!options.pgNative);

	    config.options = options;

	    // istanbul ignore next:
	    // we do not cover code specific to Native Bindings
	    if (options.pgNative) {
	        pg = $npm.pg.native;
	        if ($npm.utils.isNull(pg)) {
	            throw new Error("Failed to initialize Native Bindings.");
	        }
	    }

	    if (!('noWarnings' in options) || options.noWarnings === undefined) {
	        options.noWarnings = process.env.NODE_ENV !== 'development';
	    }

	    var Database = __webpack_require__(520)(config);

	    var inst = function inst(cn, dc) {
	        var t = typeof cn === 'undefined' ? 'undefined' : _typeof(cn);
	        if (cn && (t === 'string' || t === 'object')) {
	            return new Database(cn, dc, config);
	        }
	        throw new TypeError("Invalid connection details.");
	    };

	    $npm.utils.addReadProperties(inst, rootNameSpace);

	    /**
	     * @member {external:PG} pg
	     * @readonly
	     * @description
	     * Instance of the $[PG] library that's being used, depending on initialization option `pgNative`:
	     *  - regular `pg` module instance, without option `pgNative`, or equal to `false` (default)
	     *  - `pg` module instance with $[Native Bindings], if option `pgNative` was set.
	     *
	     * Available as `pgp.pg`, after initializing the library.
	     */
	    $npm.utils.addReadProp(inst, 'pg', pg);

	    /**
	     * @member {function} end
	     * @readonly
	     * @description
	     * Terminates pg library (call it when exiting the application).
	     *
	     * Available as `pgp.end`, after initializing the library.
	     */
	    $npm.utils.addReadProp(inst, 'end', function () {
	        pg.end();
	    });

	    /**
	     * @member {helpers} helpers
	     * @readonly
	     * @description
	     * Namespace for {@link helpers all query-formatting helper functions}.
	     *
	     * Available as `pgp.helpers`, after initializing the library.
	     *
	     * @see {@link helpers}.
	     */
	    $npm.utils.addReadProp(inst, 'helpers', $npm.helpers(config));

	    /**
	     * @member {external:spex} spex
	     * @readonly
	     * @description
	     * Initialized instance of the $[spex] module, used by the library within tasks and transactions.
	     *
	     * Available as `pgp.spex`, after initializing the library.
	     *
	     * @see
	     * {@link Task.batch},
	     * {@link Task.page},
	     * {@link Task.sequence}
	     */
	    $npm.utils.addReadProp(inst, 'spex', config.$npm.spex);

	    config.pgp = inst;
	    Object.freeze(config);

	    return inst;
	}

	var rootNameSpace = {

	    /**
	     * @member {formatting} as
	     * @readonly
	     * @description
	     * Namespace for {@link formatting all query-formatting functions}.
	     *
	     * Available as `pgp.as`, before and after initializing the library.
	     *
	     * @see {@link formatting}.
	     */
	    as: $npm.formatting.as,

	    /**
	     * @member {external:pg-minify} minify
	     * @readonly
	     * @description
	     * Instance of the $[pg-minify] library that's used.
	     *
	     * Available as `pgp.minify`, before and after initializing the library.
	     */
	    minify: $npm.minify,

	    /**
	     * @member {queryResult} queryResult
	     * @readonly
	     * @description
	     * Query Result Mask enumerator.
	     *
	     * Available as `pgp.queryResult`, before and after initializing the library.
	     */
	    queryResult: $npm.result,

	    /**
	     * @member {PromiseAdapter} PromiseAdapter
	     * @readonly
	     * @description
	     * {@link PromiseAdapter} class.
	     *
	     * Available as `pgp.PromiseAdapter`, before and after initializing the library.
	     */
	    PromiseAdapter: $npm.adapter,

	    /**
	     * @member {ParameterizedQuery} ParameterizedQuery
	     * @readonly
	     * @description
	     * {@link ParameterizedQuery} class.
	     *
	     * Available as `pgp.ParameterizedQuery`, before and after initializing the library.
	     */
	    ParameterizedQuery: $npm.types.ParameterizedQuery,

	    /**
	     * @member {PreparedStatement} PreparedStatement
	     * @readonly
	     * @description
	     * {@link PreparedStatement} class.
	     *
	     * Available as `pgp.PreparedStatement`, before and after initializing the library.
	     */
	    PreparedStatement: $npm.types.PreparedStatement,

	    /**
	     * @member {QueryFile} QueryFile
	     * @readonly
	     * @description
	     * {@link QueryFile} class.
	     *
	     * Available as `pgp.QueryFile`, before and after initializing the library.
	     */
	    QueryFile: $npm.queryFile,

	    /**
	     * @member {errors} errors
	     * @readonly
	     * @description
	     * {@link errors} - namespace for all error types.
	     *
	     * Available as `pgp.errors`, before and after initializing the library.
	     */
	    errors: $npm.errors,

	    /**
	     * @member {utils} utils
	     * @readonly
	     * @description
	     * {@link utils} - namespace for utility functions.
	     *
	     * Available as `pgp.utils`, before and after initializing the library.
	     */
	    utils: $npm.pubUtils,

	    /**
	     * @member {txMode} txMode
	     * @readonly
	     * @description
	     * {@link txMode Transaction Mode} namespace.
	     *
	     * Available as `pgp.txMode`, before and after initializing the library.
	     */
	    txMode: $npm.mode
	};

	$npm.utils.addReadProperties($main, rootNameSpace);

	module.exports = $main;

	/**
	 * @external Promise
	 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
	 */

	/**
	 * @external PG
	 * @see https://github.com/brianc/node-postgres/blob/master/lib/index.js#L8
	 */

	/**
	 * @external Client
	 * @see https://github.com/brianc/node-postgres/blob/master/lib/client.js#L12
	 */

	/**
	 * @external pg-minify
	 * @see https://github.com/vitaly-t/pg-minify
	 */

	/**
	 * @external spex
	 * @see https://github.com/vitaly-t/spex
	 */
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var EventEmitter = __webpack_require__(188).EventEmitter;
	var util = __webpack_require__(263);
	var Client = __webpack_require__(456);
	var defaults = __webpack_require__(473);
	var pool = __webpack_require__(481);
	var Connection = __webpack_require__(478);

	var PG = function PG(clientConstructor) {
	  EventEmitter.call(this);
	  this.defaults = defaults;
	  this.Client = clientConstructor;
	  this.Query = this.Client.Query;
	  this.pools = pool(clientConstructor);
	  this.Connection = Connection;
	  this.types = __webpack_require__(462);
	};

	util.inherits(PG, EventEmitter);

	PG.prototype.end = function () {
	  var self = this;
	  var keys = Object.keys(self.pools.all);
	  var count = keys.length;
	  if (count === 0) {
	    self.emit('end');
	  } else {
	    keys.forEach(function (key) {
	      var pool = self.pools.all[key];
	      delete self.pools.all[key];
	      pool.drain(function () {
	        pool.destroyAllNow(function () {
	          count--;
	          if (count === 0) {
	            self.emit('end');
	          }
	        });
	      });
	    });
	  }
	};

	PG.prototype.connect = function (config, callback) {
	  if (typeof config == "function") {
	    callback = config;
	    config = null;
	  }
	  var pool = this.pools.getOrCreate(config);
	  pool.connect(callback);
	  if (!pool.listeners('error').length) {
	    //propagate errors up to pg object
	    pool.on('error', this.emit.bind(this, 'error'));
	  }
	};

	// cancel the query runned by the given client
	PG.prototype.cancel = function (config, client, query) {
	  if (client.native) {
	    return client.cancel(query);
	  }
	  var c = config;
	  //allow for no config to be passed
	  if (typeof c === 'function') {
	    c = defaults;
	  }
	  var cancellingClient = new this.Client(c);
	  cancellingClient.cancel(client, query);
	};

	if (typeof process.env.NODE_PG_FORCE_NATIVE != 'undefined') {
	  module.exports = new PG(__webpack_require__(483));
	} else {
	  module.exports = new PG(Client);

	  //lazy require native module...the native module may not have installed
	  module.exports.__defineGetter__("native", function () {
	    delete module.exports.native;
	    var native = null;
	    try {
	      native = new PG(__webpack_require__(483));
	    } catch (err) {
	      if (err.code !== 'MODULE_NOT_FOUND') {
	        throw err;
	      }
	      console.error(err.message);
	    }
	    module.exports.native = native;
	    return native;
	  });
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var crypto = __webpack_require__(256);
	var EventEmitter = __webpack_require__(188).EventEmitter;
	var util = __webpack_require__(263);
	var pgPass = __webpack_require__(457);
	var TypeOverrides = __webpack_require__(461);

	var ConnectionParameters = __webpack_require__(472);
	var Query = __webpack_require__(475);
	var defaults = __webpack_require__(473);
	var Connection = __webpack_require__(478);

	var Client = function Client(config) {
	  EventEmitter.call(this);

	  this.connectionParameters = new ConnectionParameters(config);
	  this.user = this.connectionParameters.user;
	  this.database = this.connectionParameters.database;
	  this.port = this.connectionParameters.port;
	  this.host = this.connectionParameters.host;
	  this.password = this.connectionParameters.password;

	  var c = config || {};

	  this._types = new TypeOverrides(c.types);

	  this.connection = c.connection || new Connection({
	    stream: c.stream,
	    ssl: this.connectionParameters.ssl
	  });
	  this.queryQueue = [];
	  this.binary = c.binary || defaults.binary;
	  this.encoding = 'utf8';
	  this.processID = null;
	  this.secretKey = null;
	  this.ssl = this.connectionParameters.ssl || false;
	};

	util.inherits(Client, EventEmitter);

	Client.prototype.connect = function (callback) {
	  var self = this;
	  var con = this.connection;

	  if (this.host && this.host.indexOf('/') === 0) {
	    con.connect(this.host + '/.s.PGSQL.' + this.port);
	  } else {
	    con.connect(this.port, this.host);
	  }

	  //once connection is established send startup message
	  con.on('connect', function () {
	    if (self.ssl) {
	      con.requestSsl();
	    } else {
	      con.startup(self.getStartupConf());
	    }
	  });

	  con.on('sslconnect', function () {
	    con.startup(self.getStartupConf());
	  });

	  function checkPgPass(cb) {
	    return function (msg) {
	      if (null !== self.password) {
	        cb(msg);
	      } else {
	        pgPass(self.connectionParameters, function (pass) {
	          if (undefined !== pass) {
	            self.connectionParameters.password = self.password = pass;
	          }
	          cb(msg);
	        });
	      }
	    };
	  }

	  //password request handling
	  con.on('authenticationCleartextPassword', checkPgPass(function () {
	    con.password(self.password);
	  }));

	  //password request handling
	  con.on('authenticationMD5Password', checkPgPass(function (msg) {
	    var inner = Client.md5(self.password + self.user);
	    var outer = Client.md5(Buffer.concat([new Buffer(inner), msg.salt]));
	    var md5password = "md5" + outer;
	    con.password(md5password);
	  }));

	  con.once('backendKeyData', function (msg) {
	    self.processID = msg.processID;
	    self.secretKey = msg.secretKey;
	  });

	  //hook up query handling events to connection
	  //after the connection initially becomes ready for queries
	  con.once('readyForQuery', function () {

	    //delegate rowDescription to active query
	    con.on('rowDescription', function (msg) {
	      self.activeQuery.handleRowDescription(msg);
	    });

	    //delegate dataRow to active query
	    con.on('dataRow', function (msg) {
	      self.activeQuery.handleDataRow(msg);
	    });

	    //delegate portalSuspended to active query
	    con.on('portalSuspended', function (msg) {
	      self.activeQuery.handlePortalSuspended(con);
	    });

	    //deletagate emptyQuery to active query
	    con.on('emptyQuery', function (msg) {
	      self.activeQuery.handleEmptyQuery(con);
	    });

	    //delegate commandComplete to active query
	    con.on('commandComplete', function (msg) {
	      self.activeQuery.handleCommandComplete(msg, con);
	    });

	    //if a prepared statement has a name and properly parses
	    //we track that its already been executed so we don't parse
	    //it again on the same client
	    con.on('parseComplete', function (msg) {
	      if (self.activeQuery.name) {
	        con.parsedStatements[self.activeQuery.name] = true;
	      }
	    });

	    con.on('copyInResponse', function (msg) {
	      self.activeQuery.handleCopyInResponse(self.connection);
	    });

	    con.on('copyData', function (msg) {
	      self.activeQuery.handleCopyData(msg, self.connection);
	    });

	    con.on('notification', function (msg) {
	      self.emit('notification', msg);
	    });

	    //process possible callback argument to Client#connect
	    if (callback) {
	      callback(null, self);
	      //remove callback for proper error handling
	      //after the connect event
	      callback = null;
	    }
	    self.emit('connect');
	  });

	  con.on('readyForQuery', function () {
	    var activeQuery = self.activeQuery;
	    self.activeQuery = null;
	    self.readyForQuery = true;
	    self._pulseQueryQueue();
	    if (activeQuery) {
	      activeQuery.handleReadyForQuery();
	    }
	  });

	  con.on('error', function (error) {
	    if (self.activeQuery) {
	      var activeQuery = self.activeQuery;
	      self.activeQuery = null;
	      return activeQuery.handleError(error, con);
	    }
	    if (!callback) {
	      return self.emit('error', error);
	    }
	    callback(error);
	    callback = null;
	  });

	  con.once('end', function () {
	    if (callback) {
	      // haven't received a connection message yet !
	      var err = new Error('Connection terminated');
	      callback(err);
	      callback = null;
	      return;
	    }
	    if (self.activeQuery) {
	      var disconnectError = new Error('Connection terminated');
	      self.activeQuery.handleError(disconnectError, con);
	      self.activeQuery = null;
	    }
	    self.emit('end');
	  });

	  con.on('notice', function (msg) {
	    self.emit('notice', msg);
	  });
	};

	Client.prototype.getStartupConf = function () {
	  var params = this.connectionParameters;

	  var data = {
	    user: params.user,
	    database: params.database
	  };

	  var appName = params.application_name || params.fallback_application_name;
	  if (appName) {
	    data.application_name = appName;
	  }

	  return data;
	};

	Client.prototype.cancel = function (client, query) {
	  if (client.activeQuery == query) {
	    var con = this.connection;

	    if (this.host && this.host.indexOf('/') === 0) {
	      con.connect(this.host + '/.s.PGSQL.' + this.port);
	    } else {
	      con.connect(this.port, this.host);
	    }

	    //once connection is established send cancel message
	    con.on('connect', function () {
	      con.cancel(client.processID, client.secretKey);
	    });
	  } else if (client.queryQueue.indexOf(query) != -1) {
	    client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
	  }
	};

	Client.prototype.setTypeParser = function (oid, format, parseFn) {
	  return this._types.setTypeParser(oid, format, parseFn);
	};

	Client.prototype.getTypeParser = function (oid, format) {
	  return this._types.getTypeParser(oid, format);
	};

	// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
	Client.prototype.escapeIdentifier = function (str) {

	  var escaped = '"';

	  for (var i = 0; i < str.length; i++) {
	    var c = str[i];
	    if (c === '"') {
	      escaped += c + c;
	    } else {
	      escaped += c;
	    }
	  }

	  escaped += '"';

	  return escaped;
	};

	// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
	Client.prototype.escapeLiteral = function (str) {

	  var hasBackslash = false;
	  var escaped = '\'';

	  for (var i = 0; i < str.length; i++) {
	    var c = str[i];
	    if (c === '\'') {
	      escaped += c + c;
	    } else if (c === '\\') {
	      escaped += c + c;
	      hasBackslash = true;
	    } else {
	      escaped += c;
	    }
	  }

	  escaped += '\'';

	  if (hasBackslash === true) {
	    escaped = ' E' + escaped;
	  }

	  return escaped;
	};

	Client.prototype._pulseQueryQueue = function () {
	  if (this.readyForQuery === true) {
	    this.activeQuery = this.queryQueue.shift();
	    if (this.activeQuery) {
	      this.readyForQuery = false;
	      this.hasExecuted = true;
	      this.activeQuery.submit(this.connection);
	    } else if (this.hasExecuted) {
	      this.activeQuery = null;
	      this.emit('drain');
	    }
	  }
	};

	Client.prototype.copyFrom = function (text) {
	  throw new Error("For PostgreSQL COPY TO/COPY FROM support npm install pg-copy-streams");
	};

	Client.prototype.copyTo = function (text) {
	  throw new Error("For PostgreSQL COPY TO/COPY FROM support npm install pg-copy-streams");
	};

	Client.prototype.query = function (config, values, callback) {
	  //can take in strings, config object or query object
	  var query = typeof config.submit == 'function' ? config : new Query(config, values, callback);
	  if (this.binary && !query.binary) {
	    query.binary = true;
	  }
	  if (query._result) {
	    query._result._getTypeParser = this._types.getTypeParser.bind(this._types);
	  }

	  this.queryQueue.push(query);
	  this._pulseQueryQueue();
	  return query;
	};

	Client.prototype.end = function () {
	  this.connection.end();
	};

	Client.md5 = function (string) {
	  return crypto.createHash('md5').update(string).digest('hex');
	};

	// expose a Query constructor
	Client.Query = Query;

	module.exports = Client;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(230),
	    fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	    helper = __webpack_require__(458);

	module.exports.warnTo = helper.warnTo;

	module.exports = function (connInfo, cb) {
	    var file = helper.getFileName();

	    fs.stat(file, function (err, stat) {
	        if (err || !helper.usePgPass(stat, file)) {
	            return cb(undefined);
	        }

	        var st = fs.createReadStream(file);

	        helper.getPassword(connInfo, st, cb);
	    });
	};

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var path = __webpack_require__(230),
	    Stream = __webpack_require__(239).Stream,
	    Split = __webpack_require__(459),
	    util = __webpack_require__(263),
	    defaultPort = 5432,
	    isWin = process.platform === 'win32',
	    warnStream = process.stderr;

	var S_IRWXG = 56 //    00070(8)
	,
	    S_IRWXO = 7 //    00007(8)
	,
	    S_IFMT = 61440 // 00170000(8)
	,
	    S_IFREG = 32768 //  0100000(8)
	;
	function isRegFile(mode) {
	    return (mode & S_IFMT) == S_IFREG;
	}

	var fieldNames = ['host', 'port', 'database', 'user', 'password'];
	var nrOfFields = fieldNames.length;
	var passKey = fieldNames[nrOfFields - 1];

	function warn() {
	    var isWritable = warnStream instanceof Stream && true === warnStream.writable;

	    if (isWritable) {
	        var args = Array.prototype.slice.call(arguments).concat("\n");
	        warnStream.write(util.format.apply(util, args));
	    }
	}

	Object.defineProperty(module.exports, 'isWin', {
	    get: function get() {
	        return isWin;
	    },
	    set: function set(val) {
	        isWin = val;
	    }
	});

	module.exports.warnTo = function (stream) {
	    var old = warnStream;
	    warnStream = stream;
	    return old;
	};

	module.exports.getFileName = function (env) {
	    env = env || process.env;
	    var file = env.PGPASSFILE || (isWin ? path.join(env.APPDATA, 'postgresql', 'pgpass.conf') : path.join(env.HOME, '.pgpass'));
	    return file;
	};

	module.exports.usePgPass = function (stats, fname) {
	    if (Object.prototype.hasOwnProperty.call(process.env, 'PGPASSWORD')) {
	        return false;
	    }

	    if (isWin) {
	        return true;
	    }

	    fname = fname || '<unkn>';

	    if (!isRegFile(stats.mode)) {
	        warn('WARNING: password file "%s" is not a plain file', fname);
	        return false;
	    }

	    if (stats.mode & (S_IRWXG | S_IRWXO)) {
	        /* If password file is insecure, alert the user and ignore it. */
	        warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
	        return false;
	    }

	    return true;
	};

	var matcher = module.exports.match = function (connInfo, entry) {
	    return fieldNames.slice(0, -1).reduce(function (prev, field, idx) {
	        if (idx == 1) {
	            // the port
	            if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
	                return prev && true;
	            }
	        }
	        return prev && (entry[field] === '*' || entry[field] === connInfo[field]);
	    }, true);
	};

	module.exports.getPassword = function (connInfo, stream, cb) {
	    var pass;
	    var lineStream = stream.pipe(new Split());

	    function onLine(line) {
	        var entry = parseLine(line);
	        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
	            pass = entry[passKey];
	            lineStream.end(); // -> calls onEnd(), but pass is set now
	        }
	    }

	    var onEnd = function onEnd() {
	        cb(pass);
	    };

	    var onErr = function onErr(err) {
	        warn('WARNING: error on reading file: %s', err);
	        cb(undefined);
	    };

	    stream.on('error', onErr);
	    lineStream.on('data', onLine).on('end', onEnd).on('error', onErr);
	};

	var parseLine = module.exports.parseLine = function (line) {
	    if (line.length < 11 || line.match(/^\s+#/)) {
	        return null;
	    }

	    var curChar = '';
	    var prevChar = '';
	    var fieldIdx = 0;
	    var startIdx = 0;
	    var endIdx = 0;
	    var obj = {};
	    var isLastField = false;
	    var addToObj = function addToObj(idx, i0, i1) {
	        var field = line.substring(i0, i1);

	        if (!Object.hasOwnProperty.call(process.env, 'PGPASS_NO_DEESCAPE')) {
	            field = field.replace(/\\([:\\])/g, '$1');
	        }

	        obj[fieldNames[idx]] = field;
	    };

	    for (var i = 0; i < line.length - 1; i += 1) {
	        curChar = line.charAt(i + 1);
	        prevChar = line.charAt(i);

	        isLastField = fieldIdx == nrOfFields - 1;

	        if (isLastField) {
	            addToObj(fieldIdx, startIdx);
	            break;
	        }

	        if (i >= 0 && curChar == ':' && prevChar !== '\\') {
	            addToObj(fieldIdx, startIdx, i + 1);

	            startIdx = i + 2;
	            fieldIdx += 1;
	        }
	    }

	    obj = Object.keys(obj).length === nrOfFields ? obj : null;

	    return obj;
	};

	var isValidEntry = module.exports.isValidEntry = function (entry) {
	    var rules = {
	        // host
	        0: function _(x) {
	            return x.length > 0;
	        },
	        // port
	        1: function _(x) {
	            if (x === '*') {
	                return true;
	            }
	            x = Number(x);
	            return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
	        },
	        // database
	        2: function _(x) {
	            return x.length > 0;
	        },
	        // username
	        3: function _(x) {
	            return x.length > 0;
	        },
	        // password
	        4: function _(x) {
	            return x.length > 0;
	        }
	    };

	    for (var idx = 0; idx < fieldNames.length; idx += 1) {
	        var rule = rules[idx];
	        var value = entry[fieldNames[idx]] || '';

	        var res = rule(value);
	        if (!res) {
	            return false;
	        }
	    }

	    return true;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//filter will reemit the data if cb(err,pass) pass is truthy

	// reduce is more tricky
	// maybe we want to group the reductions or emit progress updates occasionally
	// the most basic reduce just emits one 'data' event after it has recieved 'end'


	var through = __webpack_require__(460);
	var Decoder = __webpack_require__(247).StringDecoder;

	module.exports = split;

	//TODO pass in a function to map across the lines.

	function split(matcher, mapper, options) {
	  var decoder = new Decoder();
	  var soFar = '';
	  var maxLength = options && options.maxLength;
	  var trailing = options && options.trailing === false ? false : true;
	  if ('function' === typeof matcher) mapper = matcher, matcher = null;
	  if (!matcher) matcher = /\r?\n/;

	  function emit(stream, piece) {
	    if (mapper) {
	      try {
	        piece = mapper(piece);
	      } catch (err) {
	        return stream.emit('error', err);
	      }
	      if ('undefined' !== typeof piece) stream.queue(piece);
	    } else stream.queue(piece);
	  }

	  function next(stream, buffer) {
	    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher);
	    soFar = pieces.pop();

	    if (maxLength && soFar.length > maxLength) stream.emit('error', new Error('maximum buffer reached'));

	    for (var i = 0; i < pieces.length; i++) {
	      var piece = pieces[i];
	      emit(stream, piece);
	    }
	  }

	  return through(function (b) {
	    next(this, decoder.write(b));
	  }, function () {
	    if (decoder.end) next(this, decoder.end());
	    if (trailing && soFar != null) emit(this, soFar);
	    this.queue(null);
	  });
	}

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var Stream = __webpack_require__(239);

	// through
	//
	// a stream that does nothing but re-emit the input.
	// useful for aggregating a series of changing but not ending streams into one stream)

	exports = module.exports = through;
	through.through = through;

	//create a readable writable stream.

	function through(write, end, opts) {
	  write = write || function (data) {
	    this.queue(data);
	  };
	  end = end || function () {
	    this.queue(null);
	  };

	  var ended = false,
	      destroyed = false,
	      buffer = [],
	      _ended = false;
	  var stream = new Stream();
	  stream.readable = stream.writable = true;
	  stream.paused = false;

	  //  stream.autoPause   = !(opts && opts.autoPause   === false)
	  stream.autoDestroy = !(opts && opts.autoDestroy === false);

	  stream.write = function (data) {
	    write.call(this, data);
	    return !stream.paused;
	  };

	  function drain() {
	    while (buffer.length && !stream.paused) {
	      var data = buffer.shift();
	      if (null === data) return stream.emit('end');else stream.emit('data', data);
	    }
	  }

	  stream.queue = stream.push = function (data) {
	    //    console.error(ended)
	    if (_ended) return stream;
	    if (data === null) _ended = true;
	    buffer.push(data);
	    drain();
	    return stream;
	  };

	  //this will be registered as the first 'end' listener
	  //must call destroy next tick, to make sure we're after any
	  //stream piped from here.
	  //this is only a problem if end is not emitted synchronously.
	  //a nicer way to do this is to make sure this is the last listener for 'end'

	  stream.on('end', function () {
	    stream.readable = false;
	    if (!stream.writable && stream.autoDestroy) process.nextTick(function () {
	      stream.destroy();
	    });
	  });

	  function _end() {
	    stream.writable = false;
	    end.call(stream);
	    if (!stream.readable && stream.autoDestroy) stream.destroy();
	  }

	  stream.end = function (data) {
	    if (ended) return;
	    ended = true;
	    if (arguments.length) stream.write(data);
	    _end(); // will emit or queue
	    return stream;
	  };

	  stream.destroy = function () {
	    if (destroyed) return;
	    destroyed = true;
	    ended = true;
	    buffer.length = 0;
	    stream.writable = stream.readable = false;
	    stream.emit('close');
	    return stream;
	  };

	  stream.pause = function () {
	    if (stream.paused) return;
	    stream.paused = true;
	    return stream;
	  };

	  stream.resume = function () {
	    if (stream.paused) {
	      stream.paused = false;
	      stream.emit('resume');
	    }
	    drain();
	    //may have become paused again,
	    //as drain emits 'data'.
	    if (!stream.paused) stream.emit('drain');
	    return stream;
	  };
	  return stream;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var types = __webpack_require__(462);

	function TypeOverrides(userTypes) {
	  this._types = userTypes || types;
	  this.text = {};
	  this.binary = {};
	}

	TypeOverrides.prototype.getOverrides = function (format) {
	  switch (format) {
	    case 'text':
	      return this.text;
	    case 'binary':
	      return this.binary;
	    default:
	      return {};
	  }
	};

	TypeOverrides.prototype.setTypeParser = function (oid, format, parseFn) {
	  if (typeof format == 'function') {
	    parseFn = format;
	    format = 'text';
	  }
	  this.getOverrides(format)[oid] = parseFn;
	};

	TypeOverrides.prototype.getTypeParser = function (oid, format) {
	  format = format || 'text';
	  return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
	};

	module.exports = TypeOverrides;

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var textParsers = __webpack_require__(463);
	var binaryParsers = __webpack_require__(471);
	var arrayParser = __webpack_require__(466);

	exports.getTypeParser = getTypeParser;
	exports.setTypeParser = setTypeParser;
	exports.arrayParser = arrayParser;

	var typeParsers = {
	  text: {},
	  binary: {}
	};

	//the empty parse function
	function noParse(val) {
	  return String(val);
	};

	//returns a function used to convert a specific type (specified by
	//oid) into a result javascript type
	//note: the oid can be obtained via the following sql query:
	//SELECT oid FROM pg_type WHERE typname = 'TYPE_NAME_HERE';
	function getTypeParser(oid, format) {
	  format = format || 'text';
	  if (!typeParsers[format]) {
	    return noParse;
	  }
	  return typeParsers[format][oid] || noParse;
	};

	function setTypeParser(oid, format, parseFn) {
	  if (typeof format == 'function') {
	    parseFn = format;
	    format = 'text';
	  }
	  typeParsers[format][oid] = parseFn;
	};

	textParsers.init(function (oid, converter) {
	  typeParsers.text[oid] = converter;
	});

	binaryParsers.init(function (oid, converter) {
	  typeParsers.binary[oid] = converter;
	});

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var array = __webpack_require__(464);
	var ap = __webpack_require__(465);
	var arrayParser = __webpack_require__(466);
	var parseDate = __webpack_require__(467);
	var parseInterval = __webpack_require__(468);
	var parseByteA = __webpack_require__(470);

	function allowNull(fn) {
	  return function nullAllowed(value) {
	    if (value === null) return value;
	    return fn(value);
	  };
	}

	function parseBool(value) {
	  if (value === null) return value;
	  return value === 't';
	}

	function parseBoolArray(value) {
	  if (!value) return null;
	  return array.parse(value, parseBool);
	}

	function parseIntegerArray(value) {
	  if (!value) return null;
	  return array.parse(value, allowNull(ap.partialRight(parseInt, 10)));
	}

	function parseBigIntegerArray(value) {
	  if (!value) return null;
	  return array.parse(value, allowNull(function (entry) {
	    return parseBigInteger(entry).trim();
	  }));
	}

	var parseFloatArray = function parseFloatArray(value) {
	  if (!value) {
	    return null;
	  }
	  var p = arrayParser.create(value, function (entry) {
	    if (entry !== null) {
	      entry = parseFloat(entry);
	    }
	    return entry;
	  });

	  return p.parse();
	};

	var parseStringArray = function parseStringArray(value) {
	  if (!value) {
	    return null;
	  }

	  var p = arrayParser.create(value);
	  return p.parse();
	};

	var parseDateArray = function parseDateArray(value) {
	  if (!value) {
	    return null;
	  }

	  var p = arrayParser.create(value, function (entry) {
	    if (entry !== null) {
	      entry = parseDate(entry);
	    }
	    return entry;
	  });

	  return p.parse();
	};

	var parseByteAArray = function parseByteAArray(value) {
	  var arr = parseStringArray(value);
	  if (!arr) return arr;

	  return arr.map(function (element) {
	    return parseByteA(element);
	  });
	};

	var parseInteger = function parseInteger(value) {
	  return parseInt(value, 10);
	};

	var parseBigInteger = function parseBigInteger(value) {
	  var valStr = String(value);
	  if (/^\d+$/.test(valStr)) {
	    return valStr;
	  }
	  return value;
	};

	var parseJsonArray = function parseJsonArray(value) {
	  var arr = parseStringArray(value);

	  if (!arr) {
	    return arr;
	  }

	  return arr.map(function (el) {
	    return JSON.parse(el);
	  });
	};

	var parsePoint = function parsePoint(value) {
	  if (value[0] !== '(') {
	    return null;
	  }

	  value = value.substring(1, value.length - 1).split(',');

	  return {
	    x: parseFloat(value[0]),
	    y: parseFloat(value[1])
	  };
	};

	var parseCircle = function parseCircle(value) {
	  if (value[0] !== '<' && value[1] !== '(') {
	    return null;
	  }

	  var point = '(';
	  var radius = '';
	  var pointParsed = false;
	  for (var i = 2; i < value.length - 1; i++) {
	    if (!pointParsed) {
	      point += value[i];
	    }

	    if (value[i] === ')') {
	      pointParsed = true;
	      continue;
	    } else if (!pointParsed) {
	      continue;
	    }

	    if (value[i] === ',') {
	      continue;
	    }

	    radius += value[i];
	  }
	  var result = parsePoint(point);
	  result.radius = parseFloat(radius);

	  return result;
	};

	var init = function init(register) {
	  register(20, parseBigInteger); // int8
	  register(21, parseInteger); // int2
	  register(23, parseInteger); // int4
	  register(26, parseInteger); // oid
	  register(700, parseFloat); // float4/real
	  register(701, parseFloat); // float8/double
	  register(16, parseBool);
	  register(1082, parseDate); // date
	  register(1114, parseDate); // timestamp without timezone
	  register(1184, parseDate); // timestamp
	  register(600, parsePoint); // point
	  register(718, parseCircle); // circle
	  register(1000, parseBoolArray);
	  register(1001, parseByteAArray);
	  register(1005, parseIntegerArray); // _int2
	  register(1007, parseIntegerArray); // _int4
	  register(1028, parseIntegerArray); // oid[]
	  register(1016, parseBigIntegerArray); // _int8
	  register(1021, parseFloatArray); // _float4
	  register(1022, parseFloatArray); // _float8
	  register(1231, parseFloatArray); // _numeric
	  register(1014, parseStringArray); //char
	  register(1015, parseStringArray); //varchar
	  register(1008, parseStringArray);
	  register(1009, parseStringArray);
	  register(1115, parseDateArray); // timestamp without time zone[]
	  register(1182, parseDateArray); // _date
	  register(1185, parseDateArray); // timestamp with time zone[]
	  register(1186, parseInterval);
	  register(17, parseByteA);
	  register(114, JSON.parse.bind(JSON)); // json
	  register(3802, JSON.parse.bind(JSON)); // jsonb
	  register(199, parseJsonArray); // json[]
	  register(3807, parseJsonArray); // jsonb[]
	  register(2951, parseStringArray); // uuid[]
	  register(791, parseStringArray); // money[]
	  register(1183, parseStringArray); // time[]
	};

	module.exports = {
	  init: init
	};

/***/ },
/* 464 */
/***/ function(module, exports) {

	'use strict';

	exports.parse = function (source, transform) {
	  return new ArrayParser(source, transform).parse();
	};

	function ArrayParser(source, transform) {
	  this.source = source;
	  this.transform = transform || identity;
	  this.position = 0;
	  this.entries = [];
	  this.recorded = [];
	  this.dimension = 0;
	}

	ArrayParser.prototype.isEof = function () {
	  return this.position >= this.source.length;
	};

	ArrayParser.prototype.nextCharacter = function () {
	  var character = this.source[this.position++];
	  if (character === '\\') {
	    return {
	      value: this.source[this.position++],
	      escaped: true
	    };
	  }
	  return {
	    value: character,
	    escaped: false
	  };
	};

	ArrayParser.prototype.record = function (character) {
	  this.recorded.push(character);
	};

	ArrayParser.prototype.newEntry = function (includeEmpty) {
	  var entry;
	  if (this.recorded.length > 0 || includeEmpty) {
	    entry = this.recorded.join('');
	    if (entry === 'NULL' && !includeEmpty) {
	      entry = null;
	    }
	    if (entry !== null) entry = this.transform(entry);
	    this.entries.push(entry);
	    this.recorded = [];
	  }
	};

	ArrayParser.prototype.parse = function (nested) {
	  var character, parser, quote;
	  while (!this.isEof()) {
	    character = this.nextCharacter();
	    if (character.value === '{' && !quote) {
	      this.dimension++;
	      if (this.dimension > 1) {
	        parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
	        this.entries.push(parser.parse(true));
	        this.position += parser.position - 2;
	      }
	    } else if (character.value === '}' && !quote) {
	      this.dimension--;
	      if (!this.dimension) {
	        this.newEntry();
	        if (nested) return this.entries;
	      }
	    } else if (character.value === '"' && !character.escaped) {
	      if (quote) this.newEntry(true);
	      quote = !quote;
	    } else if (character.value === ',' && !quote) {
	      this.newEntry();
	    } else {
	      this.record(character.value);
	    }
	  }
	  if (this.dimension !== 0) {
	    throw new Error('array dimension not balanced');
	  }
	  return this.entries;
	};

	function identity(value) {
	  return value;
	}

/***/ },
/* 465 */
/***/ function(module, exports) {

	"use strict";

	exports = module.exports = ap;
	function ap(args, fn) {
	    return function () {
	        var rest = [].slice.call(arguments),
	            first = args.slice();
	        first.push.apply(first, rest);
	        return fn.apply(this, first);
	    };
	}

	exports.pa = pa;
	function pa(args, fn) {
	    return function () {
	        var rest = [].slice.call(arguments);
	        rest.push.apply(rest, args);
	        return fn.apply(this, rest);
	    };
	}

	exports.apa = apa;
	function apa(left, right, fn) {
	    return function () {
	        return fn.apply(this, left.concat.apply(left, arguments).concat(right));
	    };
	}

	exports.partial = partial;
	function partial(fn) {
	    var args = [].slice.call(arguments, 1);
	    return ap(args, fn);
	}

	exports.partialRight = partialRight;
	function partialRight(fn) {
	    var args = [].slice.call(arguments, 1);
	    return pa(args, fn);
	}

	exports.curry = curry;
	function curry(fn) {
	    return partial(partial, fn);
	}

	exports.curryRight = function curryRight(fn) {
	    return partial(partialRight, fn);
	};

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var array = __webpack_require__(464);

	module.exports = {
	  create: function create(source, transform) {
	    return {
	      parse: function parse() {
	        return array.parse(source, transform);
	      }
	    };
	  }
	};

/***/ },
/* 467 */
/***/ function(module, exports) {

	'use strict';

	var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?/;
	var DATE = /^(\d{1,})-(\d{2})-(\d{2})$/;
	var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
	var BC = /BC$/;
	var INFINITY = /^-?infinity$/;

	module.exports = function parseDate(isoDate) {
	  if (INFINITY.test(isoDate)) {
	    // Capitalize to Infinity before passing to Number
	    return Number(isoDate.replace('i', 'I'));
	  }
	  var matches = DATE_TIME.exec(isoDate);

	  if (!matches) {
	    // Force YYYY-MM-DD dates to be parsed as local time
	    return DATE.test(isoDate) ? getDate(isoDate) : null;
	  }

	  var isBC = BC.test(isoDate);
	  var year = parseInt(matches[1], 10);
	  var isFirstCentury = year > 0 && year < 100;
	  year = (isBC ? '-' : '') + year;

	  var month = parseInt(matches[2], 10) - 1;
	  var day = matches[3];
	  var hour = parseInt(matches[4], 10);
	  var minute = parseInt(matches[5], 10);
	  var second = parseInt(matches[6], 10);

	  var ms = matches[7];
	  ms = ms ? 1000 * parseFloat(ms) : 0;

	  var date;
	  var offset = timeZoneOffset(isoDate);
	  if (offset != null) {
	    var utc = Date.UTC(year, month, day, hour, minute, second, ms);
	    date = new Date(utc - offset);
	  } else {
	    date = new Date(year, month, day, hour, minute, second, ms);
	  }

	  if (isFirstCentury) {
	    date.setUTCFullYear(year);
	  }

	  return date;
	};

	function getDate(isoDate) {
	  var matches = DATE.exec(isoDate);
	  var year = parseInt(matches[1], 10);
	  var month = parseInt(matches[2], 10) - 1;
	  var day = matches[3];
	  // YYYY-MM-DD will be parsed as local time
	  var date = new Date(year, month, day);
	  date.setFullYear(year);
	  return date;
	}

	// match timezones:
	// Z (UTC)
	// -05
	// +06:30
	function timeZoneOffset(isoDate) {
	  var zone = TIME_ZONE.exec(isoDate.split(' ')[1]);
	  if (!zone) return;
	  var type = zone[1];

	  if (type === 'Z') {
	    return 0;
	  }
	  var sign = type === '-' ? -1 : 1;
	  var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);

	  return offset * sign * 1000;
	}

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var extend = __webpack_require__(469);

	module.exports = PostgresInterval;

	function PostgresInterval(raw) {
	  if (!(this instanceof PostgresInterval)) {
	    return new PostgresInterval(raw);
	  }
	  extend(this, parse(raw));
	}
	var properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years'];
	PostgresInterval.prototype.toPostgres = function () {
	  var filtered = properties.filter(this.hasOwnProperty, this);
	  if (filtered.length === 0) return '0';
	  return filtered.map(function (property) {
	    return this[property] + ' ' + property;
	  }, this).join(' ');
	};

	var NUMBER = '([+-]?\\d+)';
	var YEAR = NUMBER + '\\s+years?';
	var MONTH = NUMBER + '\\s+mons?';
	var DAY = NUMBER + '\\s+days?';
	var TIME = '([+-])?([\\d]*):(\\d\\d):(\\d\\d):?(\\d\\d\\d)?';
	var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {
	  return '(' + regexString + ')?';
	}).join('\\s*'));

	// Positions of values in regex match
	var positions = {
	  years: 2,
	  months: 4,
	  days: 6,
	  hours: 9,
	  minutes: 10,
	  seconds: 11,
	  milliseconds: 12
	};
	// We can use negative time
	var negatives = ['hours', 'minutes', 'seconds'];

	function parse(interval) {
	  if (!interval) return {};
	  var matches = INTERVAL.exec(interval);
	  var isNegative = matches[8] === '-';
	  return Object.keys(positions).reduce(function (parsed, property) {
	    var position = positions[property];
	    var value = matches[position];
	    // no empty string
	    if (!value) return parsed;
	    value = parseInt(value, 10);
	    // no zeros
	    if (!value) return parsed;
	    if (isNegative && ~negatives.indexOf(property)) {
	      value *= -1;
	    }
	    parsed[property] = value;
	    return parsed;
	  }, {});
	}

/***/ },
/* 469 */
/***/ function(module, exports) {

	"use strict";

	module.exports = extend;

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend(target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }

	    return target;
	}

/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	module.exports = function parseBytea(input) {
	  if (/^\\x/.test(input)) {
	    // new 'hex' style response (pg >9.0)
	    return new Buffer(input.substr(2), 'hex');
	  }
	  var output = '';
	  var i = 0;
	  while (i < input.length) {
	    if (input[i] !== '\\') {
	      output += input[i];
	      ++i;
	    } else {
	      if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
	        output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
	        i += 4;
	      } else {
	        var backslashes = 1;
	        while (i + backslashes < input.length && input[i + backslashes] === '\\') {
	          backslashes++;
	        }
	        for (var k = 0; k < Math.floor(backslashes / 2); ++k) {
	          output += '\\';
	        }
	        i += Math.floor(backslashes / 2) * 2;
	      }
	    }
	  }
	  return new Buffer(output, 'binary');
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 471 */
/***/ function(module, exports) {

	"use strict";

	var parseBits = function parseBits(data, bits, offset, invert, callback) {
	  offset = offset || 0;
	  invert = invert || false;
	  callback = callback || function (lastValue, newValue, bits) {
	    return lastValue * Math.pow(2, bits) + newValue;
	  };
	  var offsetBytes = offset >> 3;

	  var inv = function inv(value) {
	    if (invert) {
	      return ~value & 0xff;
	    }

	    return value;
	  };

	  // read first (maybe partial) byte
	  var mask = 0xff;
	  var firstBits = 8 - offset % 8;
	  if (bits < firstBits) {
	    mask = 0xff << 8 - bits & 0xff;
	    firstBits = bits;
	  }

	  if (offset) {
	    mask = mask >> offset % 8;
	  }

	  var result = 0;
	  if (offset % 8 + bits >= 8) {
	    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
	  }

	  // read bytes
	  var bytes = bits + offset >> 3;
	  for (var i = offsetBytes + 1; i < bytes; i++) {
	    result = callback(result, inv(data[i]), 8);
	  }

	  // bits to read, that are not a complete byte
	  var lastBits = (bits + offset) % 8;
	  if (lastBits > 0) {
	    result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
	  }

	  return result;
	};

	var parseFloatFromBits = function parseFloatFromBits(data, precisionBits, exponentBits) {
	  var bias = Math.pow(2, exponentBits - 1) - 1;
	  var sign = parseBits(data, 1);
	  var exponent = parseBits(data, exponentBits, 1);

	  if (exponent === 0) {
	    return 0;
	  }

	  // parse mantissa
	  var precisionBitsCounter = 1;
	  var parsePrecisionBits = function parsePrecisionBits(lastValue, newValue, bits) {
	    if (lastValue === 0) {
	      lastValue = 1;
	    }

	    for (var i = 1; i <= bits; i++) {
	      precisionBitsCounter /= 2;
	      if ((newValue & 0x1 << bits - i) > 0) {
	        lastValue += precisionBitsCounter;
	      }
	    }

	    return lastValue;
	  };

	  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);

	  // special cases
	  if (exponent == Math.pow(2, exponentBits + 1) - 1) {
	    if (mantissa === 0) {
	      return sign === 0 ? Infinity : -Infinity;
	    }

	    return NaN;
	  }

	  // normale number
	  return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
	};

	var parseInt16 = function parseInt16(value) {
	  if (parseBits(value, 1) == 1) {
	    return -1 * (parseBits(value, 15, 1, true) + 1);
	  }

	  return parseBits(value, 15, 1);
	};

	var parseInt32 = function parseInt32(value) {
	  if (parseBits(value, 1) == 1) {
	    return -1 * (parseBits(value, 31, 1, true) + 1);
	  }

	  return parseBits(value, 31, 1);
	};

	var parseFloat32 = function parseFloat32(value) {
	  return parseFloatFromBits(value, 23, 8);
	};

	var parseFloat64 = function parseFloat64(value) {
	  return parseFloatFromBits(value, 52, 11);
	};

	var parseNumeric = function parseNumeric(value) {
	  var sign = parseBits(value, 16, 32);
	  if (sign == 0xc000) {
	    return NaN;
	  }

	  var weight = Math.pow(10000, parseBits(value, 16, 16));
	  var result = 0;

	  var digits = [];
	  var ndigits = parseBits(value, 16);
	  for (var i = 0; i < ndigits; i++) {
	    result += parseBits(value, 16, 64 + 16 * i) * weight;
	    weight /= 10000;
	  }

	  var scale = Math.pow(10, parseBits(value, 16, 48));
	  return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
	};

	var parseDate = function parseDate(isUTC, value) {
	  var sign = parseBits(value, 1);
	  var rawValue = parseBits(value, 63, 1);

	  // discard usecs and shift from 2000 to 1970
	  var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);

	  if (!isUTC) {
	    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
	  }

	  // add microseconds to the date
	  result.usec = rawValue % 1000;
	  result.getMicroSeconds = function () {
	    return this.usec;
	  };
	  result.setMicroSeconds = function (value) {
	    this.usec = value;
	  };
	  result.getUTCMicroSeconds = function () {
	    return this.usec;
	  };

	  return result;
	};

	var parseArray = function parseArray(value) {
	  var dim = parseBits(value, 32);

	  var flags = parseBits(value, 32, 32);
	  var elementType = parseBits(value, 32, 64);

	  var offset = 96;
	  var dims = [];
	  for (var i = 0; i < dim; i++) {
	    // parse dimension
	    dims[i] = parseBits(value, 32, offset);
	    offset += 32;

	    // ignore lower bounds
	    offset += 32;
	  }

	  var parseElement = function parseElement(elementType) {
	    // parse content length
	    var length = parseBits(value, 32, offset);
	    offset += 32;

	    // parse null values
	    if (length == 0xffffffff) {
	      return null;
	    }

	    var result;
	    if (elementType == 0x17 || elementType == 0x14) {
	      // int/bigint
	      result = parseBits(value, length * 8, offset);
	      offset += length * 8;
	      return result;
	    } else if (elementType == 0x19) {
	      // string
	      result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
	      return result;
	    } else {
	      console.log("ERROR: ElementType not implemented: " + elementType);
	    }
	  };

	  var parse = function parse(dimension, elementType) {
	    var array = [];
	    var i;

	    if (dimension.length > 1) {
	      var count = dimension.shift();
	      for (i = 0; i < count; i++) {
	        array[i] = parse(dimension, elementType);
	      }
	      dimension.unshift(count);
	    } else {
	      for (i = 0; i < dimension[0]; i++) {
	        array[i] = parseElement(elementType);
	      }
	    }

	    return array;
	  };

	  return parse(dims, elementType);
	};

	var parseText = function parseText(value) {
	  return value.toString('utf8');
	};

	var parseBool = function parseBool(value) {
	  if (value === null) return null;
	  return parseBits(value, 8) > 0;
	};

	var init = function init(register) {
	  register(21, parseInt16);
	  register(23, parseInt32);
	  register(26, parseInt32);
	  register(1700, parseNumeric);
	  register(700, parseFloat32);
	  register(701, parseFloat64);
	  register(16, parseBool);
	  register(1114, parseDate.bind(null, false));
	  register(1184, parseDate.bind(null, true));
	  register(1000, parseArray);
	  register(1007, parseArray);
	  register(1016, parseArray);
	  register(1008, parseArray);
	  register(1009, parseArray);
	  register(25, parseText);
	};

	module.exports = {
	  init: init
	};

/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var url = __webpack_require__(216);
	var dns = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"dns\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	var defaults = __webpack_require__(473);

	var val = function val(key, config, envVar) {
	  if (envVar === undefined) {
	    envVar = process.env['PG' + key.toUpperCase()];
	  } else if (envVar === false) {
	    // do nothing ... use false
	  } else {
	    envVar = process.env[envVar];
	  }

	  return config[key] || envVar || defaults[key];
	};

	//parses a connection string
	var parse = __webpack_require__(474).parse;

	var useSsl = function useSsl() {
	  switch (process.env.PGSSLMODE) {
	    case "disable":
	      return false;
	    case "prefer":
	    case "require":
	    case "verify-ca":
	    case "verify-full":
	      return true;
	  }
	  return defaults.ssl;
	};

	var ConnectionParameters = function ConnectionParameters(config) {
	  //if a string is passed, it is a raw connection string so we parse it into a config
	  config = typeof config == 'string' ? parse(config) : config || {};
	  //if the config has a connectionString defined, parse IT into the config we use
	  //this will override other default values with what is stored in connectionString
	  if (config.connectionString) {
	    config = parse(config.connectionString);
	  }
	  this.user = val('user', config);
	  this.database = val('database', config);
	  this.port = parseInt(val('port', config), 10);
	  this.host = val('host', config);
	  this.password = val('password', config);
	  this.binary = val('binary', config);
	  this.ssl = config.ssl || useSsl();
	  this.client_encoding = val("client_encoding", config);
	  //a domain socket begins with '/'
	  this.isDomainSocket = !(this.host || '').indexOf('/');

	  this.application_name = val('application_name', config, 'PGAPPNAME');
	  this.fallback_application_name = val('fallback_application_name', config, false);
	};

	var add = function add(params, config, paramName) {
	  var value = config[paramName];
	  if (value) {
	    params.push(paramName + "='" + value + "'");
	  }
	};

	ConnectionParameters.prototype.getLibpqConnectionString = function (cb) {
	  var params = [];
	  add(params, this, 'user');
	  add(params, this, 'password');
	  add(params, this, 'port');
	  add(params, this, 'application_name');
	  add(params, this, 'fallback_application_name');

	  if (this.database) {
	    params.push("dbname='" + this.database + "'");
	  }
	  if (this.host) {
	    params.push("host=" + this.host);
	  }
	  if (this.isDomainSocket) {
	    return cb(null, params.join(' '));
	  }
	  if (this.client_encoding) {
	    params.push("client_encoding='" + this.client_encoding + "'");
	  }
	  dns.lookup(this.host, function (err, address) {
	    if (err) return cb(err, null);
	    params.push("hostaddr=" + address);
	    return cb(null, params.join(' '));
	  });
	};

	module.exports = ConnectionParameters;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var defaults = module.exports = {
	  // database host. defaults to localhost
	  host: 'localhost',

	  //database user's name
	  user: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,

	  //name of database to connect
	  database: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,

	  //database user's password
	  password: null,

	  // a Postgres connection string to be used instead of setting individual connection items
	  // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
	  // in the defaults object.
	  connectionString: undefined,

	  //database port
	  port: 5432,

	  //number of rows to return at a time from a prepared statement's
	  //portal. 0 will return all rows at once
	  rows: 0,

	  // binary result mode
	  binary: false,

	  //Connection pool options - see https://github.com/coopernurse/node-pool
	  //number of connections to use in connection pool
	  //0 will disable connection pooling
	  poolSize: 10,

	  //max milliseconds a client can go unused before it is removed
	  //from the pool and destroyed
	  poolIdleTimeout: 30000,

	  //frequency to check for idle clients within the client pool
	  reapIntervalMillis: 1000,

	  //if true the most recently released resources will be the first to be allocated
	  returnToHead: false,

	  //pool log function / boolean
	  poolLog: false,

	  client_encoding: "",

	  ssl: false,

	  application_name: undefined,
	  fallback_application_name: undefined,

	  parseInputDatesAsUTC: false
	};

	//parse int8 so you can get your count values as actual numbers
	module.exports.__defineSetter__("parseInt8", function (val) {
	  __webpack_require__(462).setTypeParser(20, 'text', val ? parseInt : function (val) {
	    return val;
	  });
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var url = __webpack_require__(216);

	//Parse method copied from https://github.com/brianc/node-postgres
	//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
	//MIT License

	//parses a connection string
	function parse(str) {
	  var config;
	  //unix socket
	  if (str.charAt(0) === '/') {
	    config = str.split(' ');
	    return { host: config[0], database: config[1] };
	  }
	  // url parse expects spaces encoded as %20
	  if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
	    str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
	  }
	  var result = url.parse(str, true);
	  config = {};

	  if (result.query.application_name) {
	    config.application_name = result.query.application_name;
	  }
	  if (result.query.fallback_application_name) {
	    config.fallback_application_name = result.query.fallback_application_name;
	  }

	  config.port = result.port;
	  if (result.protocol == 'socket:') {
	    config.host = decodeURI(result.pathname);
	    config.database = result.query.db;
	    config.client_encoding = result.query.encoding;
	    return config;
	  }
	  config.host = result.hostname;

	  // result.pathname is not always guaranteed to have a '/' prefix (e.g. relative urls)
	  // only strip the slash if it is present.
	  var pathname = result.pathname;
	  if (pathname && pathname.charAt(0) === '/') {
	    pathname = result.pathname.slice(1) || null;
	  }
	  config.database = pathname && decodeURI(pathname);

	  var auth = (result.auth || ':').split(':');
	  config.user = auth[0];
	  config.password = auth.splice(1).join(':');

	  var ssl = result.query.ssl;
	  if (ssl === 'true' || ssl === '1') {
	    config.ssl = true;
	  }

	  return config;
	}

	module.exports = {
	  parse: parse
	};

/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var EventEmitter = __webpack_require__(188).EventEmitter;
	var util = __webpack_require__(263);

	var Result = __webpack_require__(476);
	var utils = __webpack_require__(477);

	var Query = function Query(config, values, callback) {
	  // use of "new" optional
	  if (!(this instanceof Query)) {
	    return new Query(config, values, callback);
	  }

	  config = utils.normalizeQueryConfig(config, values, callback);

	  this.text = config.text;
	  this.values = config.values;
	  this.rows = config.rows;
	  this.types = config.types;
	  this.name = config.name;
	  this.binary = config.binary;
	  this.stream = config.stream;
	  //use unique portal name each time
	  this.portal = config.portal || "";
	  this.callback = config.callback;
	  if (process.domain && config.callback) {
	    this.callback = process.domain.bind(config.callback);
	  }
	  this._result = new Result(config.rowMode, config.types);
	  this.isPreparedStatement = false;
	  this._canceledDueToError = false;
	  this._promise = null;
	  EventEmitter.call(this);
	};

	util.inherits(Query, EventEmitter);

	Query.prototype.then = function (callback) {
	  return this.promise().then(callback);
	};

	Query.prototype.catch = function (callback) {
	  return this.promise().catch(callback);
	};

	Query.prototype.promise = function () {
	  if (this._promise) return this._promise;
	  this._promise = new Promise(function (resolve, reject) {
	    this.once('end', resolve);
	    this.once('error', reject);
	  }.bind(this));
	  return this._promise;
	};

	Query.prototype.requiresPreparation = function () {
	  //named queries must always be prepared
	  if (this.name) {
	    return true;
	  }
	  //always prepare if there are max number of rows expected per
	  //portal execution
	  if (this.rows) {
	    return true;
	  }
	  //don't prepare empty text queries
	  if (!this.text) {
	    return false;
	  }
	  //binary should be prepared to specify results should be in binary
	  //unless there are no parameters
	  if (this.binary && !this.values) {
	    return false;
	  }
	  //prepare if there are values
	  return (this.values || 0).length > 0;
	};

	//associates row metadata from the supplied
	//message with this query object
	//metadata used when parsing row results
	Query.prototype.handleRowDescription = function (msg) {
	  this._result.addFields(msg.fields);
	  this._accumulateRows = this.callback || !this.listeners('row').length;
	};

	Query.prototype.handleDataRow = function (msg) {
	  var row = this._result.parseRow(msg.fields);
	  this.emit('row', row, this._result);
	  if (this._accumulateRows) {
	    this._result.addRow(row);
	  }
	};

	Query.prototype.handleCommandComplete = function (msg, con) {
	  this._result.addCommandComplete(msg);
	  //need to sync after each command complete of a prepared statement
	  if (this.isPreparedStatement) {
	    con.sync();
	  }
	};

	//if a named prepared statement is created with empty query text
	//the backend will send an emptyQuery message but *not* a command complete message
	//execution on the connection will hang until the backend receives a sync message
	Query.prototype.handleEmptyQuery = function (con) {
	  if (this.isPreparedStatement) {
	    con.sync();
	  }
	};

	Query.prototype.handleReadyForQuery = function () {
	  if (this._canceledDueToError) {
	    return this.handleError(this._canceledDueToError);
	  }
	  if (this.callback) {
	    this.callback(null, this._result);
	  }
	  this.emit('end', this._result);
	};

	Query.prototype.handleError = function (err, connection) {
	  //need to sync after error during a prepared statement
	  if (this.isPreparedStatement) {
	    connection.sync();
	  }
	  if (this._canceledDueToError) {
	    err = this._canceledDueToError;
	    this._canceledDueToError = false;
	  }
	  //if callback supplied do not emit error event as uncaught error
	  //events will bubble up to node process
	  if (this.callback) {
	    return this.callback(err);
	  }
	  this.emit('error', err);
	};

	Query.prototype.submit = function (connection) {
	  if (this.requiresPreparation()) {
	    this.prepare(connection);
	  } else {
	    connection.query(this.text);
	  }
	};

	Query.prototype.hasBeenParsed = function (connection) {
	  return this.name && connection.parsedStatements[this.name];
	};

	Query.prototype.handlePortalSuspended = function (connection) {
	  this._getRows(connection, this.rows);
	};

	Query.prototype._getRows = function (connection, rows) {
	  connection.execute({
	    portal: this.portalName,
	    rows: rows
	  }, true);
	  connection.flush();
	};

	Query.prototype.prepare = function (connection) {
	  var self = this;
	  //prepared statements need sync to be called after each command
	  //complete or when an error is encountered
	  this.isPreparedStatement = true;
	  //TODO refactor this poor encapsulation
	  if (!this.hasBeenParsed(connection)) {
	    connection.parse({
	      text: self.text,
	      name: self.name,
	      types: self.types
	    }, true);
	  }

	  if (self.values) {
	    self.values = self.values.map(utils.prepareValue);
	  }

	  //http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
	  connection.bind({
	    portal: self.portalName,
	    statement: self.name,
	    values: self.values,
	    binary: self.binary
	  }, true);

	  connection.describe({
	    type: 'P',
	    name: self.portalName || ""
	  }, true);

	  this._getRows(connection, this.rows);
	};

	Query.prototype.handleCopyInResponse = function (connection) {
	  if (this.stream) this.stream.startStreamingToConnection(connection);else connection.sendCopyFail('No source stream defined');
	};

	Query.prototype.handleCopyData = function (msg, connection) {
	  var chunk = msg.chunk;
	  if (this.stream) {
	    this.stream.handleChunk(chunk);
	  }
	  //if there are no stream (for example when copy to query was sent by
	  //query method instead of copyTo) error will be handled
	  //on copyOutResponse event, so silently ignore this error here
	};
	module.exports = Query;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var types = __webpack_require__(462);

	//result object returned from query
	//in the 'end' event and also
	//passed as second argument to provided callback
	var Result = function Result(rowMode) {
	  this.command = null;
	  this.rowCount = null;
	  this.oid = null;
	  this.rows = [];
	  this.fields = [];
	  this._parsers = [];
	  this.RowCtor = null;
	  this.rowAsArray = rowMode == "array";
	  if (this.rowAsArray) {
	    this.parseRow = this._parseRowAsArray;
	  }
	};

	var matchRegexp = /([A-Za-z]+) ?(\d+ )?(\d+)?/;

	//adds a command complete message
	Result.prototype.addCommandComplete = function (msg) {
	  var match;
	  if (msg.text) {
	    //pure javascript
	    match = matchRegexp.exec(msg.text);
	  } else {
	    //native bindings
	    match = matchRegexp.exec(msg.command);
	  }
	  if (match) {
	    this.command = match[1];
	    //match 3 will only be existing on insert commands
	    if (match[3]) {
	      //msg.value is from native bindings
	      this.rowCount = parseInt(match[3] || msg.value, 10);
	      this.oid = parseInt(match[2], 10);
	    } else {
	      this.rowCount = parseInt(match[2], 10);
	    }
	  }
	};

	Result.prototype._parseRowAsArray = function (rowData) {
	  var row = [];
	  for (var i = 0, len = rowData.length; i < len; i++) {
	    var rawValue = rowData[i];
	    if (rawValue !== null) {
	      row.push(this._parsers[i](rawValue));
	    } else {
	      row.push(null);
	    }
	  }
	  return row;
	};

	//rowData is an array of text or binary values
	//this turns the row into a JavaScript object
	Result.prototype.parseRow = function (rowData) {
	  return new this.RowCtor(this._parsers, rowData);
	};

	Result.prototype.addRow = function (row) {
	  this.rows.push(row);
	};

	var inlineParser = function inlineParser(fieldName, i) {
	  return "\nthis['" +
	  //fields containing single quotes will break
	  //the evaluated javascript unless they are escaped
	  //see https://github.com/brianc/node-postgres/issues/507
	  //Addendum: However, we need to make sure to replace all
	  //occurences of apostrophes, not just the first one.
	  //See https://github.com/brianc/node-postgres/issues/934
	  fieldName.replace(/'/g, "\\'") + "'] = " + "rowData[" + i + "] == null ? null : parsers[" + i + "](rowData[" + i + "]);";
	};

	Result.prototype.addFields = function (fieldDescriptions) {
	  //clears field definitions
	  //multiple query statements in 1 action can result in multiple sets
	  //of rowDescriptions...eg: 'select NOW(); select 1::int;'
	  //you need to reset the fields
	  if (this.fields.length) {
	    this.fields = [];
	    this._parsers = [];
	  }
	  var ctorBody = "";
	  for (var i = 0; i < fieldDescriptions.length; i++) {
	    var desc = fieldDescriptions[i];
	    this.fields.push(desc);
	    var parser = this._getTypeParser(desc.dataTypeID, desc.format || 'text');
	    this._parsers.push(parser);
	    //this is some craziness to compile the row result parsing
	    //results in ~60% speedup on large query result sets
	    ctorBody += inlineParser(desc.name, i);
	  }
	  if (!this.rowAsArray) {
	    this.RowCtor = Function("parsers", "rowData", ctorBody);
	  }
	};

	Result.prototype._getTypeParser = types.getTypeParser;

	module.exports = Result;

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var defaults = __webpack_require__(473);

	// convert a JS array to a postgres array literal
	// uses comma separator so won't work for types like box that use
	// a different array separator.
	function arrayString(val) {
	  var result = '{';
	  for (var i = 0; i < val.length; i++) {
	    if (i > 0) {
	      result = result + ',';
	    }
	    if (val[i] === null || typeof val[i] === 'undefined') {
	      result = result + 'NULL';
	    } else if (Array.isArray(val[i])) {
	      result = result + arrayString(val[i]);
	    } else {
	      result = result + JSON.stringify(prepareValue(val[i]));
	    }
	  }
	  result = result + '}';
	  return result;
	}

	//converts values from javascript types
	//to their 'raw' counterparts for use as a postgres parameter
	//note: you can override this function to provide your own conversion mechanism
	//for complex types, etc...
	var prepareValue = function prepareValue(val, seen) {
	  if (val instanceof Buffer) {
	    return val;
	  }
	  if (val instanceof Date) {
	    if (defaults.parseInputDatesAsUTC) {
	      return dateToStringUTC(val);
	    } else {
	      return dateToString(val);
	    }
	  }
	  if (Array.isArray(val)) {
	    return arrayString(val);
	  }
	  if (val === null || typeof val === 'undefined') {
	    return null;
	  }
	  if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
	    return prepareObject(val, seen);
	  }
	  if (typeof val === 'undefined') {
	    throw new Error('SQL queries with undefined where clause option');
	  }
	  return val.toString();
	};

	function prepareObject(val, seen) {
	  if (val.toPostgres && typeof val.toPostgres === 'function') {
	    seen = seen || [];
	    if (seen.indexOf(val) !== -1) {
	      throw new Error('circular reference detected while preparing "' + val + '" for query');
	    }
	    seen.push(val);

	    return prepareValue(val.toPostgres(prepareValue), seen);
	  }
	  return JSON.stringify(val);
	}

	function pad(number, digits) {
	  number = "" + number;
	  while (number.length < digits) {
	    number = "0" + number;
	  }return number;
	}

	function dateToString(date) {

	  var offset = -date.getTimezoneOffset();
	  var ret = pad(date.getFullYear(), 4) + '-' + pad(date.getMonth() + 1, 2) + '-' + pad(date.getDate(), 2) + 'T' + pad(date.getHours(), 2) + ':' + pad(date.getMinutes(), 2) + ':' + pad(date.getSeconds(), 2) + '.' + pad(date.getMilliseconds(), 3);

	  if (offset < 0) {
	    ret += "-";
	    offset *= -1;
	  } else ret += "+";

	  return ret + pad(Math.floor(offset / 60), 2) + ":" + pad(offset % 60, 2);
	}

	function dateToStringUTC(date) {

	  var ret = pad(date.getUTCFullYear(), 4) + '-' + pad(date.getUTCMonth() + 1, 2) + '-' + pad(date.getUTCDate(), 2) + 'T' + pad(date.getUTCHours(), 2) + ':' + pad(date.getUTCMinutes(), 2) + ':' + pad(date.getUTCSeconds(), 2) + '.' + pad(date.getUTCMilliseconds(), 3);

	  return ret + "+00:00";
	}

	function normalizeQueryConfig(config, values, callback) {
	  //can take in strings or config objects
	  config = typeof config == 'string' ? { text: config } : config;
	  if (values) {
	    if (typeof values === 'function') {
	      config.callback = values;
	    } else {
	      config.values = values;
	    }
	  }
	  if (callback) {
	    config.callback = callback;
	  }
	  return config;
	}

	module.exports = {
	  prepareValue: function prepareValueWrapper(value) {
	    //this ensures that extra arguments do not get passed into prepareValue
	    //by accident, eg: from calling values.map(utils.prepareValue)
	    return prepareValue(value);
	  },
	  normalizeQueryConfig: normalizeQueryConfig
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var EventEmitter = __webpack_require__(188).EventEmitter;
	var util = __webpack_require__(263);

	var Writer = __webpack_require__(479);
	var Reader = __webpack_require__(480);

	var TEXT_MODE = 0;
	var BINARY_MODE = 1;
	var Connection = function Connection(config) {
	  EventEmitter.call(this);
	  config = config || {};
	  this.stream = config.stream || new net.Stream();
	  this.lastBuffer = false;
	  this.lastOffset = 0;
	  this.buffer = null;
	  this.offset = null;
	  this.encoding = 'utf8';
	  this.parsedStatements = {};
	  this.writer = new Writer();
	  this.ssl = config.ssl || false;
	  this._ending = false;
	  this._mode = TEXT_MODE;
	  this._emitMessage = false;
	  this._reader = new Reader({
	    headerSize: 1,
	    lengthPadding: -4
	  });
	  var self = this;
	  this.on('newListener', function (eventName) {
	    if (eventName == 'message') {
	      self._emitMessage = true;
	    }
	  });
	};

	util.inherits(Connection, EventEmitter);

	Connection.prototype.connect = function (port, host) {

	  if (this.stream.readyState === 'closed') {
	    this.stream.connect(port, host);
	  } else if (this.stream.readyState == 'open') {
	    this.emit('connect');
	  }

	  var self = this;

	  this.stream.on('connect', function () {
	    self.emit('connect');
	  });

	  this.stream.on('error', function (error) {
	    //don't raise ECONNRESET errors - they can & should be ignored
	    //during disconnect
	    if (self._ending && error.code == 'ECONNRESET') {
	      return;
	    }
	    self.emit('error', error);
	  });

	  this.stream.on('close', function () {
	    // NOTE: node-0.10 emits both 'end' and 'close'
	    //       for streams closed by the peer, while
	    //       node-0.8 only emits 'close'
	    self.emit('end');
	  });

	  if (!this.ssl) {
	    return this.attachListeners(this.stream);
	  }

	  this.stream.once('data', function (buffer) {
	    var responseCode = buffer.toString('utf8');
	    if (responseCode != 'S') {
	      return self.emit('error', new Error('The server does not support SSL connections'));
	    }
	    var tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	    self.stream = tls.connect({
	      socket: self.stream,
	      servername: host,
	      rejectUnauthorized: self.ssl.rejectUnauthorized,
	      ca: self.ssl.ca,
	      pfx: self.ssl.pfx,
	      key: self.ssl.key,
	      passphrase: self.ssl.passphrase,
	      cert: self.ssl.cert,
	      NPNProtocols: self.ssl.NPNProtocols
	    });
	    self.attachListeners(self.stream);
	    self.emit('sslconnect');

	    self.stream.on('error', function (error) {
	      self.emit('error', error);
	    });
	  });
	};

	Connection.prototype.attachListeners = function (stream) {
	  var self = this;
	  stream.on('data', function (buff) {
	    self._reader.addChunk(buff);
	    var packet = self._reader.read();
	    while (packet) {
	      var msg = self.parseMessage(packet);
	      if (self._emitMessage) {
	        self.emit('message', msg);
	      }
	      self.emit(msg.name, msg);
	      packet = self._reader.read();
	    }
	  });
	};

	Connection.prototype.requestSsl = function () {
	  this.checkSslResponse = true;

	  var bodyBuffer = this.writer.addInt16(0x04D2).addInt16(0x162F).flush();

	  var length = bodyBuffer.length + 4;

	  var buffer = new Writer().addInt32(length).add(bodyBuffer).join();
	  this.stream.write(buffer);
	};

	Connection.prototype.startup = function (config) {
	  var writer = this.writer.addInt16(3).addInt16(0);

	  Object.keys(config).forEach(function (key) {
	    var val = config[key];
	    writer.addCString(key).addCString(val);
	  });

	  writer.addCString('client_encoding').addCString("'utf-8'");

	  var bodyBuffer = writer.addCString('').flush();
	  //this message is sent without a code

	  var length = bodyBuffer.length + 4;

	  var buffer = new Writer().addInt32(length).add(bodyBuffer).join();
	  this.stream.write(buffer);
	};

	Connection.prototype.cancel = function (processID, secretKey) {
	  var bodyBuffer = this.writer.addInt16(1234).addInt16(5678).addInt32(processID).addInt32(secretKey).flush();

	  var length = bodyBuffer.length + 4;

	  var buffer = new Writer().addInt32(length).add(bodyBuffer).join();
	  this.stream.write(buffer);
	};

	Connection.prototype.password = function (password) {
	  //0x70 = 'p'
	  this._send(0x70, this.writer.addCString(password));
	};

	Connection.prototype._send = function (code, more) {
	  if (!this.stream.writable) {
	    return false;
	  }
	  if (more === true) {
	    this.writer.addHeader(code);
	  } else {
	    return this.stream.write(this.writer.flush(code));
	  }
	};

	Connection.prototype.query = function (text) {
	  //0x51 = Q
	  this.stream.write(this.writer.addCString(text).flush(0x51));
	};

	//send parse message
	//"more" === true to buffer the message until flush() is called
	Connection.prototype.parse = function (query, more) {
	  //expect something like this:
	  // { name: 'queryName',
	  //   text: 'select * from blah',
	  //   types: ['int8', 'bool'] }

	  //normalize missing query names to allow for null
	  query.name = query.name || '';
	  if (query.name.length > 63) {
	    console.error('Warning! Postgres only supports 63 characters for query names.');
	    console.error('You supplied', query.name, '(', query.name.length, ')');
	    console.error('This can cause conflicts and silent errors executing queries');
	  }
	  //normalize null type array
	  query.types = query.types || [];
	  var len = query.types.length;
	  var buffer = this.writer.addCString(query.name) //name of query
	  .addCString(query.text) //actual query text
	  .addInt16(len);
	  for (var i = 0; i < len; i++) {
	    buffer.addInt32(query.types[i]);
	  }

	  var code = 0x50;
	  this._send(code, more);
	};

	//send bind message
	//"more" === true to buffer the message until flush() is called
	Connection.prototype.bind = function (config, more) {
	  //normalize config
	  config = config || {};
	  config.portal = config.portal || '';
	  config.statement = config.statement || '';
	  config.binary = config.binary || false;
	  var values = config.values || [];
	  var len = values.length;
	  var useBinary = false;
	  for (var j = 0; j < len; j++) {
	    useBinary |= values[j] instanceof Buffer;
	  }var buffer = this.writer.addCString(config.portal).addCString(config.statement);
	  if (!useBinary) buffer.addInt16(0);else {
	    buffer.addInt16(len);
	    for (j = 0; j < len; j++) {
	      buffer.addInt16(values[j] instanceof Buffer);
	    }
	  }
	  buffer.addInt16(len);
	  for (var i = 0; i < len; i++) {
	    var val = values[i];
	    if (val === null || typeof val === "undefined") {
	      buffer.addInt32(-1);
	    } else if (val instanceof Buffer) {
	      buffer.addInt32(val.length);
	      buffer.add(val);
	    } else {
	      buffer.addInt32(Buffer.byteLength(val));
	      buffer.addString(val);
	    }
	  }

	  if (config.binary) {
	    buffer.addInt16(1); // format codes to use binary
	    buffer.addInt16(1);
	  } else {
	    buffer.addInt16(0); // format codes to use text
	  }
	  //0x42 = 'B'
	  this._send(0x42, more);
	};

	//send execute message
	//"more" === true to buffer the message until flush() is called
	Connection.prototype.execute = function (config, more) {
	  config = config || {};
	  config.portal = config.portal || '';
	  config.rows = config.rows || '';
	  this.writer.addCString(config.portal).addInt32(config.rows);

	  //0x45 = 'E'
	  this._send(0x45, more);
	};

	var emptyBuffer = Buffer(0);

	Connection.prototype.flush = function () {
	  //0x48 = 'H'
	  this.writer.add(emptyBuffer);
	  this._send(0x48);
	};

	Connection.prototype.sync = function () {
	  //clear out any pending data in the writer
	  this.writer.flush(0);

	  this.writer.add(emptyBuffer);
	  this._ending = true;
	  this._send(0x53);
	};

	Connection.prototype.end = function () {
	  //0x58 = 'X'
	  this.writer.add(emptyBuffer);
	  this._ending = true;
	  this._send(0x58);
	};

	Connection.prototype.close = function (msg, more) {
	  this.writer.addCString(msg.type + (msg.name || ''));
	  this._send(0x43, more);
	};

	Connection.prototype.describe = function (msg, more) {
	  this.writer.addCString(msg.type + (msg.name || ''));
	  this._send(0x44, more);
	};

	Connection.prototype.sendCopyFromChunk = function (chunk) {
	  this.stream.write(this.writer.add(chunk).flush(0x64));
	};

	Connection.prototype.endCopyFrom = function () {
	  this.stream.write(this.writer.add(emptyBuffer).flush(0x63));
	};

	Connection.prototype.sendCopyFail = function (msg) {
	  //this.stream.write(this.writer.add(emptyBuffer).flush(0x66));
	  this.writer.addCString(msg);
	  this._send(0x66);
	};

	var Message = function Message(name, length) {
	  this.name = name;
	  this.length = length;
	};

	Connection.prototype.parseMessage = function (buffer) {

	  this.offset = 0;
	  var length = buffer.length + 4;
	  switch (this._reader.header) {

	    case 0x52:
	      //R
	      return this.parseR(buffer, length);

	    case 0x53:
	      //S
	      return this.parseS(buffer, length);

	    case 0x4b:
	      //K
	      return this.parseK(buffer, length);

	    case 0x43:
	      //C
	      return this.parseC(buffer, length);

	    case 0x5a:
	      //Z
	      return this.parseZ(buffer, length);

	    case 0x54:
	      //T
	      return this.parseT(buffer, length);

	    case 0x44:
	      //D
	      return this.parseD(buffer, length);

	    case 0x45:
	      //E
	      return this.parseE(buffer, length);

	    case 0x4e:
	      //N
	      return this.parseN(buffer, length);

	    case 0x31:
	      //1
	      return new Message('parseComplete', length);

	    case 0x32:
	      //2
	      return new Message('bindComplete', length);

	    case 0x33:
	      //3
	      return new Message('closeComplete', length);

	    case 0x41:
	      //A
	      return this.parseA(buffer, length);

	    case 0x6e:
	      //n
	      return new Message('noData', length);

	    case 0x49:
	      //I
	      return new Message('emptyQuery', length);

	    case 0x73:
	      //s
	      return new Message('portalSuspended', length);

	    case 0x47:
	      //G
	      return this.parseG(buffer, length);

	    case 0x48:
	      //H
	      return this.parseH(buffer, length);

	    case 0x63:
	      //c
	      return new Message('copyDone', length);

	    case 0x64:
	      //d
	      return this.parsed(buffer, length);
	  }
	};

	Connection.prototype.parseR = function (buffer, length) {
	  var code = 0;
	  var msg = new Message('authenticationOk', length);
	  if (msg.length === 8) {
	    code = this.parseInt32(buffer);
	    if (code === 3) {
	      msg.name = 'authenticationCleartextPassword';
	    }
	    return msg;
	  }
	  if (msg.length === 12) {
	    code = this.parseInt32(buffer);
	    if (code === 5) {
	      //md5 required
	      msg.name = 'authenticationMD5Password';
	      msg.salt = new Buffer(4);
	      buffer.copy(msg.salt, 0, this.offset, this.offset + 4);
	      this.offset += 4;
	      return msg;
	    }
	  }
	  throw new Error("Unknown authenticationOk message type" + util.inspect(msg));
	};

	Connection.prototype.parseS = function (buffer, length) {
	  var msg = new Message('parameterStatus', length);
	  msg.parameterName = this.parseCString(buffer);
	  msg.parameterValue = this.parseCString(buffer);
	  return msg;
	};

	Connection.prototype.parseK = function (buffer, length) {
	  var msg = new Message('backendKeyData', length);
	  msg.processID = this.parseInt32(buffer);
	  msg.secretKey = this.parseInt32(buffer);
	  return msg;
	};

	Connection.prototype.parseC = function (buffer, length) {
	  var msg = new Message('commandComplete', length);
	  msg.text = this.parseCString(buffer);
	  return msg;
	};

	Connection.prototype.parseZ = function (buffer, length) {
	  var msg = new Message('readyForQuery', length);
	  msg.name = 'readyForQuery';
	  msg.status = this.readString(buffer, 1);
	  return msg;
	};

	var ROW_DESCRIPTION = 'rowDescription';
	Connection.prototype.parseT = function (buffer, length) {
	  var msg = new Message(ROW_DESCRIPTION, length);
	  msg.fieldCount = this.parseInt16(buffer);
	  var fields = [];
	  for (var i = 0; i < msg.fieldCount; i++) {
	    fields.push(this.parseField(buffer));
	  }
	  msg.fields = fields;
	  return msg;
	};

	var Field = function Field() {
	  this.name = null;
	  this.tableID = null;
	  this.columnID = null;
	  this.dataTypeID = null;
	  this.dataTypeSize = null;
	  this.dataTypeModifier = null;
	  this.format = null;
	};

	var FORMAT_TEXT = 'text';
	var FORMAT_BINARY = 'binary';
	Connection.prototype.parseField = function (buffer) {
	  var field = new Field();
	  field.name = this.parseCString(buffer);
	  field.tableID = this.parseInt32(buffer);
	  field.columnID = this.parseInt16(buffer);
	  field.dataTypeID = this.parseInt32(buffer);
	  field.dataTypeSize = this.parseInt16(buffer);
	  field.dataTypeModifier = this.parseInt32(buffer);
	  if (this.parseInt16(buffer) === TEXT_MODE) {
	    this._mode = TEXT_MODE;
	    field.format = FORMAT_TEXT;
	  } else {
	    this._mode = BINARY_MODE;
	    field.format = FORMAT_BINARY;
	  }
	  return field;
	};

	var DATA_ROW = 'dataRow';
	var DataRowMessage = function DataRowMessage(length, fieldCount) {
	  this.name = DATA_ROW;
	  this.length = length;
	  this.fieldCount = fieldCount;
	  this.fields = [];
	};

	//extremely hot-path code
	Connection.prototype.parseD = function (buffer, length) {
	  var fieldCount = this.parseInt16(buffer);
	  var msg = new DataRowMessage(length, fieldCount);
	  for (var i = 0; i < fieldCount; i++) {
	    msg.fields.push(this._readValue(buffer));
	  }
	  return msg;
	};

	//extremely hot-path code
	Connection.prototype._readValue = function (buffer) {
	  var length = this.parseInt32(buffer);
	  if (length === -1) return null;
	  if (this._mode === TEXT_MODE) {
	    return this.readString(buffer, length);
	  }
	  return this.readBytes(buffer, length);
	};

	//parses error
	Connection.prototype.parseE = function (buffer, length) {
	  var fields = {};
	  var msg, item;
	  var input = new Message('error', length);
	  var fieldType = this.readString(buffer, 1);
	  while (fieldType != '\0') {
	    fields[fieldType] = this.parseCString(buffer);
	    fieldType = this.readString(buffer, 1);
	  }
	  if (input.name === 'error') {
	    // the msg is an Error instance
	    msg = new Error(fields.M);
	    for (item in input) {
	      // copy input properties to the error
	      if (input.hasOwnProperty(item)) {
	        msg[item] = input[item];
	      }
	    }
	  } else {
	    // the msg is an object literal
	    msg = input;
	    msg.message = fields.M;
	  }
	  msg.severity = fields.S;
	  msg.code = fields.C;
	  msg.detail = fields.D;
	  msg.hint = fields.H;
	  msg.position = fields.P;
	  msg.internalPosition = fields.p;
	  msg.internalQuery = fields.q;
	  msg.where = fields.W;
	  msg.schema = fields.s;
	  msg.table = fields.t;
	  msg.column = fields.c;
	  msg.dataType = fields.d;
	  msg.constraint = fields.n;
	  msg.file = fields.F;
	  msg.line = fields.L;
	  msg.routine = fields.R;
	  return msg;
	};

	//same thing, different name
	Connection.prototype.parseN = function (buffer, length) {
	  var msg = this.parseE(buffer, length);
	  msg.name = 'notice';
	  return msg;
	};

	Connection.prototype.parseA = function (buffer, length) {
	  var msg = new Message('notification', length);
	  msg.processId = this.parseInt32(buffer);
	  msg.channel = this.parseCString(buffer);
	  msg.payload = this.parseCString(buffer);
	  return msg;
	};

	Connection.prototype.parseG = function (buffer, length) {
	  var msg = new Message('copyInResponse', length);
	  return this.parseGH(buffer, msg);
	};

	Connection.prototype.parseH = function (buffer, length) {
	  var msg = new Message('copyOutResponse', length);
	  return this.parseGH(buffer, msg);
	};

	Connection.prototype.parseGH = function (buffer, msg) {
	  var isBinary = buffer[this.offset] !== 0;
	  this.offset++;
	  msg.binary = isBinary;
	  var columnCount = this.parseInt16(buffer);
	  msg.columnTypes = [];
	  for (var i = 0; i < columnCount; i++) {
	    msg.columnTypes.push(this.parseInt16(buffer));
	  }
	  return msg;
	};

	Connection.prototype.parsed = function (buffer, length) {
	  var msg = new Message('copyData', length);
	  msg.chunk = this.readBytes(buffer, msg.length - 4);
	  return msg;
	};

	Connection.prototype.parseInt32 = function (buffer) {
	  var value = buffer.readInt32BE(this.offset, true);
	  this.offset += 4;
	  return value;
	};

	Connection.prototype.parseInt16 = function (buffer) {
	  var value = buffer.readInt16BE(this.offset, true);
	  this.offset += 2;
	  return value;
	};

	Connection.prototype.readString = function (buffer, length) {
	  return buffer.toString(this.encoding, this.offset, this.offset += length);
	};

	Connection.prototype.readBytes = function (buffer, length) {
	  return buffer.slice(this.offset, this.offset += length);
	};

	Connection.prototype.parseCString = function (buffer) {
	  var start = this.offset;
	  while (buffer[this.offset++] !== 0) {}
	  return buffer.toString(this.encoding, start, this.offset - 1);
	};
	//end parsing methods
	module.exports = Connection;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";

	//binary data writer tuned for creating
	//postgres message packets as effeciently as possible by reusing the
	//same buffer to avoid memcpy and limit memory allocations
	var Writer = module.exports = function (size) {
	  this.size = size || 1024;
	  this.buffer = Buffer(this.size + 5);
	  this.offset = 5;
	  this.headerPosition = 0;
	};

	//resizes internal buffer if not enough size left
	Writer.prototype._ensure = function (size) {
	  var remaining = this.buffer.length - this.offset;
	  if (remaining < size) {
	    var oldBuffer = this.buffer;
	    // exponential growth factor of around ~ 1.5
	    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy
	    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
	    this.buffer = new Buffer(newSize);
	    oldBuffer.copy(this.buffer);
	  }
	};

	Writer.prototype.addInt32 = function (num) {
	  this._ensure(4);
	  this.buffer[this.offset++] = num >>> 24 & 0xFF;
	  this.buffer[this.offset++] = num >>> 16 & 0xFF;
	  this.buffer[this.offset++] = num >>> 8 & 0xFF;
	  this.buffer[this.offset++] = num >>> 0 & 0xFF;
	  return this;
	};

	Writer.prototype.addInt16 = function (num) {
	  this._ensure(2);
	  this.buffer[this.offset++] = num >>> 8 & 0xFF;
	  this.buffer[this.offset++] = num >>> 0 & 0xFF;
	  return this;
	};

	//for versions of node requiring 'length' as 3rd argument to buffer.write
	var writeString = function writeString(buffer, string, offset, len) {
	  buffer.write(string, offset, len);
	};

	//overwrite function for older versions of node
	if (Buffer.prototype.write.length === 3) {
	  writeString = function writeString(buffer, string, offset, len) {
	    buffer.write(string, offset);
	  };
	}

	Writer.prototype.addCString = function (string) {
	  //just write a 0 for empty or null strings
	  if (!string) {
	    this._ensure(1);
	  } else {
	    var len = Buffer.byteLength(string);
	    this._ensure(len + 1); //+1 for null terminator
	    writeString(this.buffer, string, this.offset, len);
	    this.offset += len;
	  }

	  this.buffer[this.offset++] = 0; // null terminator
	  return this;
	};

	Writer.prototype.addChar = function (c) {
	  this._ensure(1);
	  writeString(this.buffer, c, this.offset, 1);
	  this.offset++;
	  return this;
	};

	Writer.prototype.addString = function (string) {
	  string = string || "";
	  var len = Buffer.byteLength(string);
	  this._ensure(len);
	  this.buffer.write(string, this.offset);
	  this.offset += len;
	  return this;
	};

	Writer.prototype.getByteLength = function () {
	  return this.offset - 5;
	};

	Writer.prototype.add = function (otherBuffer) {
	  this._ensure(otherBuffer.length);
	  otherBuffer.copy(this.buffer, this.offset);
	  this.offset += otherBuffer.length;
	  return this;
	};

	Writer.prototype.clear = function () {
	  this.offset = 5;
	  this.headerPosition = 0;
	  this.lastEnd = 0;
	};

	//appends a header block to all the written data since the last
	//subsequent header or to the beginning if there is only one data block
	Writer.prototype.addHeader = function (code, last) {
	  var origOffset = this.offset;
	  this.offset = this.headerPosition;
	  this.buffer[this.offset++] = code;
	  //length is everything in this packet minus the code
	  this.addInt32(origOffset - (this.headerPosition + 1));
	  //set next header position
	  this.headerPosition = origOffset;
	  //make space for next header
	  this.offset = origOffset;
	  if (!last) {
	    this._ensure(5);
	    this.offset += 5;
	  }
	};

	Writer.prototype.join = function (code) {
	  if (code) {
	    this.addHeader(code, true);
	  }
	  return this.buffer.slice(code ? 0 : 5, this.offset);
	};

	Writer.prototype.flush = function (code) {
	  var result = this.join(code);
	  this.clear();
	  return result;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var assert = __webpack_require__(342);

	var Reader = module.exports = function (options) {
	  //TODO - remove for version 1.0
	  if (typeof options == 'number') {
	    options = { headerSize: options };
	  }
	  options = options || {};
	  this.offset = 0;
	  this.lastChunk = false;
	  this.chunk = null;
	  this.headerSize = options.headerSize || 0;
	  this.lengthPadding = options.lengthPadding || 0;
	  this.header = null;
	  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported');
	};

	Reader.prototype.addChunk = function (chunk) {
	  this.offset = 0;
	  this.chunk = chunk;
	  if (this.lastChunk) {
	    this.chunk = Buffer.concat([this.lastChunk, this.chunk]);
	    this.lastChunk = false;
	  }
	};

	Reader.prototype._save = function () {
	  //save any unread chunks for next read
	  if (this.offset < this.chunk.length) {
	    this.lastChunk = this.chunk.slice(this.offset);
	  }
	  return false;
	};

	Reader.prototype.read = function () {
	  if (this.chunk.length < this.headerSize + 4 + this.offset) {
	    return this._save();
	  }

	  if (this.headerSize) {
	    this.header = this.chunk[this.offset];
	  }

	  //read length of next item
	  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding;

	  //next item spans more chunks than we have
	  var remaining = this.chunk.length - (this.offset + 4 + this.headerSize);
	  if (length > remaining) {
	    return this._save();
	  }

	  this.offset += this.headerSize + 4;
	  var result = this.chunk.slice(this.offset, this.offset + length);
	  this.offset += length;
	  return result;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var EventEmitter = __webpack_require__(188).EventEmitter;

	var defaults = __webpack_require__(473);
	var genericPool = __webpack_require__(482);

	module.exports = function (Client) {
	  var pools = {
	    Client: Client,
	    //dictionary of all key:pool pairs
	    all: {},
	    //reference to the client constructor - can override in tests or for require('pg').native
	    getOrCreate: function getOrCreate(clientConfig) {
	      clientConfig = clientConfig || {};
	      var name = JSON.stringify(clientConfig);
	      var pool = pools.all[name];
	      if (pool) {
	        return pool;
	      }
	      pool = genericPool.Pool({
	        name: name,
	        max: clientConfig.poolSize || defaults.poolSize,
	        idleTimeoutMillis: clientConfig.poolIdleTimeout || defaults.poolIdleTimeout,
	        reapIntervalMillis: clientConfig.reapIntervalMillis || defaults.reapIntervalMillis,
	        returnToHead: clientConfig.returnToHead || defaults.returnToHead,
	        log: clientConfig.poolLog || defaults.poolLog,
	        create: function create(cb) {
	          var client = new pools.Client(clientConfig);
	          // Ignore errors on pooled clients until they are connected.
	          client.on('error', Function.prototype);
	          client.connect(function (err) {
	            if (err) return cb(err, null);

	            // Remove the noop error handler after a connection has been established.
	            client.removeListener('error', Function.prototype);

	            //handle connected client background errors by emitting event
	            //via the pg object and then removing errored client from the pool
	            client.on('error', function (e) {
	              pool.emit('error', e, client);

	              // If the client is already being destroyed, the error
	              // occurred during stream ending. Do not attempt to destroy
	              // the client again.
	              if (!client._destroying) {
	                pool.destroy(client);
	              }
	            });

	            // Remove connection from pool on disconnect
	            client.on('end', function (e) {
	              // Do not enter infinite loop between pool.destroy
	              // and client 'end' event...
	              if (!client._destroying) {
	                pool.destroy(client);
	              }
	            });
	            client.poolCount = 0;
	            return cb(null, client);
	          });
	        },
	        destroy: function destroy(client) {
	          client._destroying = true;
	          client.poolCount = undefined;
	          client.end();
	        }
	      });
	      pools.all[name] = pool;
	      //mixin EventEmitter to pool
	      EventEmitter.call(pool);
	      for (var key in EventEmitter.prototype) {
	        if (EventEmitter.prototype.hasOwnProperty(key)) {
	          pool[key] = EventEmitter.prototype[key];
	        }
	      }
	      //monkey-patch with connect method
	      pool.connect = function (cb) {
	        var domain = process.domain;
	        pool.acquire(function (err, client) {
	          if (domain) {
	            cb = domain.bind(cb);
	          }
	          if (err) return cb(err, null, function () {/*NOOP*/});
	          client.poolCount++;
	          cb(null, client, function (err) {
	            if (err) {
	              pool.destroy(client);
	            } else {
	              pool.release(client);
	            }
	          });
	        });
	      };
	      return pool;
	    }
	  };

	  return pools;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * @class
	 * @private
	 */
	function PriorityQueue(size) {
	  if (!(this instanceof PriorityQueue)) {
	    return new PriorityQueue();
	  }

	  this._size = size;
	  this._slots = null;
	  this._total = null;

	  // initialize arrays to hold queue elements
	  size = Math.max(+size | 0, 1);
	  this._slots = [];
	  for (var i = 0; i < size; i += 1) {
	    this._slots.push([]);
	  }
	}

	PriorityQueue.prototype.size = function size() {
	  if (this._total === null) {
	    this._total = 0;
	    for (var i = 0; i < this._size; i += 1) {
	      this._total += this._slots[i].length;
	    }
	  }
	  return this._total;
	};

	PriorityQueue.prototype.enqueue = function enqueue(obj, priority) {
	  var priorityOrig;

	  // Convert to integer with a default value of 0.
	  priority = priority && +priority | 0 || 0;

	  // Clear cache for total.
	  this._total = null;
	  if (priority) {
	    priorityOrig = priority;
	    if (priority < 0 || priority >= this._size) {
	      priority = this._size - 1;
	      // put obj at the end of the line
	      console.error('invalid priority: ' + priorityOrig + ' must be between 0 and ' + priority);
	    }
	  }

	  this._slots[priority].push(obj);
	};

	PriorityQueue.prototype.dequeue = function dequeue(callback) {
	  var obj = null;
	  // Clear cache for total.
	  this._total = null;
	  for (var i = 0, sl = this._slots.length; i < sl; i += 1) {
	    if (this._slots[i].length) {
	      obj = this._slots[i].shift();
	      break;
	    }
	  }
	  return obj;
	};

	function doWhileAsync(conditionFn, iterateFn, callbackFn) {
	  var next = function next() {
	    if (conditionFn()) {
	      iterateFn(next);
	    } else {
	      callbackFn();
	    }
	  };
	  next();
	}

	/**
	 * Generate an Object pool with a specified `factory`.
	 *
	 * @class
	 * @param {Object} factory
	 *   Factory to be used for generating and destorying the items.
	 * @param {String} factory.name
	 *   Name of the factory. Serves only logging purposes.
	 * @param {Function} factory.create
	 *   Should create the item to be acquired,
	 *   and call it's first callback argument with the generated item as it's argument.
	 * @param {Function} factory.destroy
	 *   Should gently close any resources that the item is using.
	 *   Called before the items is destroyed.
	 * @param {Function} factory.validate
	 *   Should return true if connection is still valid and false
	 *   If it should be removed from pool. Called before item is
	 *   acquired from pool.
	 * @param {Function} factory.validateAsync
	 *   Asynchronous validate function. Receives a callback function
	 *   as its second argument, that should be called with a single
	 *   boolean argument being true if the item is still valid and false
	 *   if it should be removed from pool. Called before item is
	 *   acquired from pool. Only one of validate/validateAsync may be specified
	 * @param {Number} factory.max
	 *   Maximum number of items that can exist at the same time.  Default: 1.
	 *   Any further acquire requests will be pushed to the waiting list.
	 * @param {Number} factory.min
	 *   Minimum number of items in pool (including in-use). Default: 0.
	 *   When the pool is created, or a resource destroyed, this minimum will
	 *   be checked. If the pool resource count is below the minimum, a new
	 *   resource will be created and added to the pool.
	 * @param {Number} factory.idleTimeoutMillis
	 *   Delay in milliseconds after the idle items in the pool will be destroyed.
	 *   And idle item is that is not acquired yet. Waiting items doesn't count here.
	 * @param {Number} factory.reapIntervalMillis
	 *   Cleanup is scheduled in every `factory.reapIntervalMillis` milliseconds.
	 * @param {Boolean|Function} factory.log
	 *   Whether the pool should log activity. If function is specified,
	 *   that will be used instead. The function expects the arguments msg, loglevel
	 * @param {Number} factory.priorityRange
	 *   The range from 1 to be treated as a valid priority
	 * @param {RefreshIdle} factory.refreshIdle
	 *   Should idle resources be destroyed and recreated every idleTimeoutMillis? Default: true.
	 * @param {Bool} [factory.returnToHead=false]
	 *   Returns released object to head of available objects list
	 */
	function Pool(factory) {
	  if (!(this instanceof Pool)) {
	    return new Pool(factory);
	  }

	  if (factory.validate && factory.validateAsync) {
	    throw new Error('Only one of validate or validateAsync may be specified');
	  }

	  // defaults
	  factory.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;
	  factory.returnToHead = factory.returnToHead || false;
	  factory.refreshIdle = 'refreshIdle' in factory ? factory.refreshIdle : true;
	  factory.reapInterval = factory.reapIntervalMillis || 1000;
	  factory.priorityRange = factory.priorityRange || 1;
	  factory.validate = factory.validate || function () {
	    return true;
	  };

	  factory.max = parseInt(factory.max, 10);
	  factory.min = parseInt(factory.min, 10);

	  factory.max = Math.max(isNaN(factory.max) ? 1 : factory.max, 1);
	  factory.min = Math.min(isNaN(factory.min) ? 0 : factory.min, factory.max - 1);

	  this._factory = factory;
	  this._inUseObjects = [];
	  this._draining = false;
	  this._waitingClients = new PriorityQueue(factory.priorityRange);
	  this._availableObjects = [];
	  this._count = 0;
	  this._removeIdleTimer = null;
	  this._removeIdleScheduled = false;

	  // create initial resources (if factory.min > 0)
	  this._ensureMinimum();
	}

	/**
	 * logs to console or user defined log function
	 * @private
	 * @param {string} str
	 * @param {string} level
	 */
	Pool.prototype._log = function log(str, level) {
	  if (typeof this._factory.log === 'function') {
	    this._factory.log(str, level);
	  } else if (this._factory.log) {
	    console.log(level.toUpperCase() + ' pool ' + this._factory.name + ' - ' + str);
	  }
	};

	/**
	 * Request the client to be destroyed. The factory's destroy handler
	 * will also be called.
	 *
	 * This should be called within an acquire() block as an alternative to release().
	 *
	 * @param {Object} obj
	 *   The acquired item to be destoyed.
	 */
	Pool.prototype.destroy = function destroy(obj) {
	  this._count -= 1;
	  if (this._count < 0) this._count = 0;
	  this._availableObjects = this._availableObjects.filter(function (objWithTimeout) {
	    return objWithTimeout.obj !== obj;
	  });

	  this._inUseObjects = this._inUseObjects.filter(function (objInUse) {
	    return objInUse !== obj;
	  });

	  this._factory.destroy(obj);

	  this._ensureMinimum();
	};

	/**
	 * Checks and removes the available (idle) clients that have timed out.
	 * @private
	 */
	Pool.prototype._removeIdle = function removeIdle() {
	  var toRemove = [];
	  var now = new Date().getTime();
	  var i;
	  var al;
	  var tr;
	  var timeout;

	  this._removeIdleScheduled = false;

	  // Go through the available (idle) items,
	  // check if they have timed out
	  for (i = 0, al = this._availableObjects.length; i < al && this._factory.refreshIdle && this._count - this._factory.min > toRemove.length; i += 1) {
	    timeout = this._availableObjects[i].timeout;
	    if (now >= timeout) {
	      // Client timed out, so destroy it.
	      this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');
	      toRemove.push(this._availableObjects[i].obj);
	    }
	  }

	  for (i = 0, tr = toRemove.length; i < tr; i += 1) {
	    this.destroy(toRemove[i]);
	  }

	  // Replace the available items with the ones to keep.
	  al = this._availableObjects.length;

	  if (al > 0) {
	    this._log('this._availableObjects.length=' + al, 'verbose');
	    this._scheduleRemoveIdle();
	  } else {
	    this._log('removeIdle() all objects removed', 'verbose');
	  }
	};

	/**
	 * Schedule removal of idle items in the pool.
	 *
	 * More schedules cannot run concurrently.
	 */
	Pool.prototype._scheduleRemoveIdle = function scheduleRemoveIdle() {
	  var self = this;
	  if (!this._removeIdleScheduled) {
	    this._removeIdleScheduled = true;
	    this._removeIdleTimer = setTimeout(function () {
	      self._removeIdle();
	    }, this._factory.reapInterval);
	  }
	};

	/**
	 * Try to get a new client to work, and clean up pool unused (idle) items.
	 *
	 *  - If there are available clients waiting, shift the first one out (LIFO),
	 *    and call its callback.
	 *  - If there are no waiting clients, try to create one if it won't exceed
	 *    the maximum number of clients.
	 *  - If creating a new client would exceed the maximum, add the client to
	 *    the wait list.
	 * @private
	 */
	Pool.prototype._dispense = function dispense() {
	  var self = this;
	  var objWithTimeout = null;
	  var err = null;
	  var clientCb = null;
	  var waitingCount = this._waitingClients.size();

	  this._log('dispense() clients=' + waitingCount + ' available=' + this._availableObjects.length, 'info');
	  if (waitingCount > 0) {
	    if (this._factory.validateAsync) {
	      doWhileAsync(function () {
	        return self._availableObjects.length > 0;
	      }, function (next) {
	        self._log('dispense() - reusing obj', 'verbose');
	        objWithTimeout = self._availableObjects[0];

	        self._factory.validateAsync(objWithTimeout.obj, function (valid) {
	          if (!valid) {
	            self.destroy(objWithTimeout.obj);
	            next();
	          } else {
	            self._availableObjects.shift();
	            self._inUseObjects.push(objWithTimeout.obj);
	            clientCb = self._waitingClients.dequeue();
	            clientCb(err, objWithTimeout.obj);
	          }
	        });
	      }, function () {
	        if (self._count < self._factory.max) {
	          self._createResource();
	        }
	      });

	      return;
	    }

	    while (this._availableObjects.length > 0) {
	      this._log('dispense() - reusing obj', 'verbose');
	      objWithTimeout = this._availableObjects[0];
	      if (!this._factory.validate(objWithTimeout.obj)) {
	        this.destroy(objWithTimeout.obj);
	        continue;
	      }
	      this._availableObjects.shift();
	      this._inUseObjects.push(objWithTimeout.obj);
	      clientCb = this._waitingClients.dequeue();
	      return clientCb(err, objWithTimeout.obj);
	    }
	    if (this._count < this._factory.max) {
	      this._createResource();
	    }
	  }
	};

	/**
	 * @private
	 */
	Pool.prototype._createResource = function _createResource() {
	  this._count += 1;
	  this._log('createResource() - creating obj - count=' + this._count + ' min=' + this._factory.min + ' max=' + this._factory.max, 'verbose');
	  var self = this;
	  this._factory.create(function () {
	    var err, obj;
	    var clientCb = self._waitingClients.dequeue();
	    if (arguments.length > 1) {
	      err = arguments[0];
	      obj = arguments[1];
	    } else {
	      err = arguments[0] instanceof Error ? arguments[0] : null;
	      obj = arguments[0] instanceof Error ? null : arguments[0];
	    }
	    if (err) {
	      self._count -= 1;
	      if (self._count < 0) self._count = 0;
	      if (clientCb) {
	        clientCb(err, obj);
	      }
	      process.nextTick(function () {
	        self._dispense();
	      });
	    } else {
	      self._inUseObjects.push(obj);
	      if (clientCb) {
	        clientCb(err, obj);
	      } else {
	        self.release(obj);
	      }
	    }
	  });
	};

	/**
	 * @private
	 */
	Pool.prototype._ensureMinimum = function _ensureMinimum() {
	  var i, diff;
	  if (!this._draining && this._count < this._factory.min) {
	    diff = this._factory.min - this._count;
	    for (i = 0; i < diff; i++) {
	      this._createResource();
	    }
	  }
	};

	/**
	 * Request a new client. The callback will be called,
	 * when a new client will be availabe, passing the client to it.
	 *
	 * @param {Function} callback
	 *   Callback function to be called after the acquire is successful.
	 *   The function will receive the acquired item as the first parameter.
	 *
	 * @param {Number} priority
	 *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority
	 *   of the caller if there are no available resources.  Lower numbers mean higher
	 *   priority.
	 *
	 * @returns {boolean} `true` if the pool is not fully utilized, `false` otherwise.
	 */
	Pool.prototype.acquire = function acquire(callback, priority) {
	  if (this._draining) {
	    throw new Error('pool is draining and cannot accept work');
	  }
	  this._waitingClients.enqueue(callback, priority);
	  this._dispense();
	  return this._count < this._factory.max;
	};

	/**
	 * @deprecated
	 */
	Pool.prototype.borrow = function borrow(callback, priority) {
	  this._log('borrow() is deprecated. use acquire() instead', 'warn');
	  this.acquire(callback, priority);
	};

	/**
	 * Return the client to the pool, in case it is no longer required.
	 *
	 * @param {Object} obj
	 *   The acquired object to be put back to the pool.
	 */
	Pool.prototype.release = function release(obj) {
	  // check to see if this object has already been released (i.e., is back in the pool of this._availableObjects)
	  if (this._availableObjects.some(function (objWithTimeout) {
	    return objWithTimeout.obj === obj;
	  })) {
	    this._log('release called twice for the same resource: ' + new Error().stack, 'error');
	    return;
	  }

	  // check to see if this object exists in the `in use` list and remove it
	  var index = this._inUseObjects.indexOf(obj);
	  if (index < 0) {
	    this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');
	    return;
	  }

	  // this._log("return to pool")
	  this._inUseObjects.splice(index, 1);
	  var objWithTimeout = { obj: obj, timeout: new Date().getTime() + this._factory.idleTimeoutMillis };
	  if (this._factory.returnToHead) {
	    this._availableObjects.splice(0, 0, objWithTimeout);
	  } else {
	    this._availableObjects.push(objWithTimeout);
	  }
	  this._log('timeout: ' + objWithTimeout.timeout, 'verbose');
	  this._dispense();
	  this._scheduleRemoveIdle();
	};

	/**
	 * @deprecated
	 */
	Pool.prototype.returnToPool = function returnToPool(obj) {
	  this._log('returnToPool() is deprecated. use release() instead', 'warn');
	  this.release(obj);
	};

	/**
	 * Disallow any new requests and let the request backlog dissapate.
	 *
	 * @param {Function} callback
	 *   Optional. Callback invoked when all work is done and all clients have been
	 *   released.
	 */
	Pool.prototype.drain = function drain(callback) {
	  this._log('draining', 'info');

	  // disable the ability to put more work on the queue.
	  this._draining = true;

	  var self = this;
	  var check = function check() {
	    if (self._waitingClients.size() > 0) {
	      // wait until all client requests have been satisfied.
	      setTimeout(check, 100);
	    } else if (self._availableObjects.length !== self._count) {
	      // wait until all objects have been released.
	      setTimeout(check, 100);
	    } else if (callback) {
	      callback();
	    }
	  };
	  check();
	};

	/**
	 * Forcibly destroys all clients regardless of timeout.  Intended to be
	 * invoked as part of a drain.  Does not prevent the creation of new
	 * clients as a result of subsequent calls to acquire.
	 *
	 * Note that if factory.min > 0, the pool will destroy all idle resources
	 * in the pool, but replace them with newly created resources up to the
	 * specified factory.min value.  If this is not desired, set factory.min
	 * to zero before calling destroyAllNow()
	 *
	 * @param {Function} callback
	 *   Optional. Callback invoked after all existing clients are destroyed.
	 */
	Pool.prototype.destroyAllNow = function destroyAllNow(callback) {
	  this._log('force destroying all objects', 'info');
	  var willDie = this._availableObjects;
	  this._availableObjects = [];
	  var obj = willDie.shift();
	  while (obj !== null && obj !== undefined) {
	    this.destroy(obj.obj);
	    obj = willDie.shift();
	  }
	  this._removeIdleScheduled = false;
	  clearTimeout(this._removeIdleTimer);
	  if (callback) {
	    callback();
	  }
	};

	/**
	 * Decorates a function to use a acquired client from the object pool when called.
	 *
	 * @param {Function} decorated
	 *   The decorated function, accepting a client as the first argument and
	 *   (optionally) a callback as the final argument.
	 *
	 * @param {Number} priority
	 *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority
	 *   of the caller if there are no available resources.  Lower numbers mean higher
	 *   priority.
	 */
	Pool.prototype.pooled = function pooled(decorated, priority) {
	  var self = this;
	  return function () {
	    var callerArgs = arguments;
	    var callerCallback = callerArgs[callerArgs.length - 1];
	    var callerHasCallback = typeof callerCallback === 'function';
	    self.acquire(function (err, client) {
	      if (err) {
	        if (callerHasCallback) {
	          callerCallback(err);
	        }
	        return;
	      }

	      var args = [client].concat(Array.prototype.slice.call(callerArgs, 0, callerHasCallback ? -1 : undefined));
	      args.push(function () {
	        self.release(client);
	        if (callerHasCallback) {
	          callerCallback.apply(null, arguments);
	        }
	      });

	      decorated.apply(null, args);
	    }, priority);
	  };
	};

	Pool.prototype.getPoolSize = function getPoolSize() {
	  return this._count;
	};

	Pool.prototype.getName = function getName() {
	  return this._factory.name;
	};

	Pool.prototype.availableObjectsCount = function availableObjectsCount() {
	  return this._availableObjects.length;
	};

	Pool.prototype.inUseObjectsCount = function inUseObjectsCount() {
	  return this._inUseObjects.length;
	};

	Pool.prototype.waitingClientsCount = function waitingClientsCount() {
	  return this._waitingClients.size();
	};

	Pool.prototype.getMaxPoolSize = function getMaxPoolSize() {
	  return this._factory.max;
	};

	Pool.prototype.getMinPoolSize = function getMinPoolSize() {
	  return this._factory.min;
	};

	exports.Pool = Pool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Native = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"pg-native\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var TypeOverrides = __webpack_require__(461);
	var semver = __webpack_require__(484);
	var pkg = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var assert = __webpack_require__(342);
	var EventEmitter = __webpack_require__(188).EventEmitter;
	var util = __webpack_require__(263);
	var ConnectionParameters = __webpack_require__(472);

	var msg = 'Version >= ' + pkg.minNativeVersion + ' of pg-native required.';
	assert(semver.gte(Native.version, pkg.minNativeVersion), msg);

	var NativeQuery = __webpack_require__(486);

	var Client = module.exports = function (config) {
	  EventEmitter.call(this);
	  config = config || {};

	  this._types = new TypeOverrides(config.types);

	  this.native = new Native({
	    types: this._types
	  });

	  this._queryQueue = [];
	  this._connected = false;

	  //keep these on the object for legacy reasons
	  //for the time being. TODO: deprecate all this jazz
	  var cp = this.connectionParameters = new ConnectionParameters(config);
	  this.user = cp.user;
	  this.password = cp.password;
	  this.database = cp.database;
	  this.host = cp.host;
	  this.port = cp.port;

	  //a hash to hold named queries
	  this.namedQueries = {};
	};

	util.inherits(Client, EventEmitter);

	//connect to the backend
	//pass an optional callback to be called once connected
	//or with an error if there was a connection error
	//if no callback is passed and there is a connection error
	//the client will emit an error event.
	Client.prototype.connect = function (cb) {
	  var self = this;

	  var onError = function onError(err) {
	    if (cb) return cb(err);
	    return self.emit('error', err);
	  };

	  this.connectionParameters.getLibpqConnectionString(function (err, conString) {
	    if (err) return onError(err);
	    self.native.connect(conString, function (err) {
	      if (err) return onError(err);

	      //set internal states to connected
	      self._connected = true;

	      //handle connection errors from the native layer
	      self.native.on('error', function (err) {
	        //error will be handled by active query
	        if (self._activeQuery && self._activeQuery.state != 'end') {
	          return;
	        }
	        self.emit('error', err);
	      });

	      self.native.on('notification', function (msg) {
	        self.emit('notification', {
	          channel: msg.relname,
	          payload: msg.extra
	        });
	      });

	      //signal we are connected now
	      self.emit('connect');
	      self._pulseQueryQueue(true);

	      //possibly call the optional callback
	      if (cb) cb();
	    });
	  });
	};

	//send a query to the server
	//this method is highly overloaded to take
	//1) string query, optional array of parameters, optional function callback
	//2) object query with {
	//    string query
	//    optional array values,
	//    optional function callback instead of as a separate parameter
	//    optional string name to name & cache the query plan
	//    optional string rowMode = 'array' for an array of results
	//  }
	Client.prototype.query = function (config, values, callback) {
	  var query = new NativeQuery(this.native);

	  //support query('text', ...) style calls
	  if (typeof config == 'string') {
	    query.text = config;
	  }

	  //support passing everything in via a config object
	  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) == 'object') {
	    query.text = config.text;
	    query.values = config.values;
	    query.name = config.name;
	    query.callback = config.callback;
	    query._arrayMode = config.rowMode == 'array';
	  }

	  //support query({...}, function() {}) style calls
	  //& support query(..., ['values'], ...) style calls
	  if (typeof values == 'function') {
	    query.callback = values;
	  } else if (util.isArray(values)) {
	    query.values = values;
	  }
	  if (typeof callback == 'function') {
	    query.callback = callback;
	  }

	  this._queryQueue.push(query);
	  this._pulseQueryQueue();
	  return query;
	};

	//disconnect from the backend server
	Client.prototype.end = function (cb) {
	  var self = this;
	  if (!this._connected) {
	    this.once('connect', this.end.bind(this, cb));
	  }
	  this.native.end(function () {
	    //send an error to the active query
	    if (self._hasActiveQuery()) {
	      var msg = 'Connection terminated';
	      self._queryQueue.length = 0;
	      self._activeQuery.handleError(new Error(msg));
	    }
	    self.emit('end');
	    if (cb) cb();
	  });
	};

	Client.prototype._hasActiveQuery = function () {
	  return this._activeQuery && this._activeQuery.state != 'error' && this._activeQuery.state != 'end';
	};

	Client.prototype._pulseQueryQueue = function (initialConnection) {
	  if (!this._connected) {
	    return;
	  }
	  if (this._hasActiveQuery()) {
	    return;
	  }
	  var query = this._queryQueue.shift();
	  if (!query) {
	    if (!initialConnection) {
	      this.emit('drain');
	    }
	    return;
	  }
	  this._activeQuery = query;
	  query.submit(this);
	  var self = this;
	  query.once('_done', function () {
	    self._pulseQueryQueue();
	  });
	};

	//attempt to cancel an in-progress query
	Client.prototype.cancel = function (query) {
	  if (this._activeQuery == query) {
	    this.native.cancel(function () {});
	  } else if (this._queryQueue.indexOf(query) != -1) {
	    this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
	  }
	};

	Client.prototype.setTypeParser = function (oid, format, parseFn) {
	  return this._types.setTypeParser(oid, format, parseFn);
	};

	Client.prototype.getTypeParser = function (oid, format) {
	  return this._types.getTypeParser(oid, format);
	};

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	;(function (exports) {

	  // export the class if we are in a Node-like system.
	  if (( false ? 'undefined' : _typeof(module)) === 'object' && module.exports === exports) exports = module.exports = SemVer;

	  // The debug function is excluded entirely from the minified version.

	  // Note: this is the semver.org version of the spec that it implements
	  // Not necessarily the package version of this code.
	  exports.SEMVER_SPEC_VERSION = '2.0.0';

	  var MAX_LENGTH = 256;
	  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

	  // The actual regexps go on exports.re
	  var re = exports.re = [];
	  var src = exports.src = [];
	  var R = 0;

	  // The following Regular Expressions can be used for tokenizing,
	  // validating, and parsing SemVer version strings.

	  // ## Numeric Identifier
	  // A single `0`, or a non-zero digit followed by zero or more digits.

	  var NUMERICIDENTIFIER = R++;
	  src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	  var NUMERICIDENTIFIERLOOSE = R++;
	  src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

	  // ## Non-numeric Identifier
	  // Zero or more digits, followed by a letter or hyphen, and then zero or
	  // more letters, digits, or hyphens.

	  var NONNUMERICIDENTIFIER = R++;
	  src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

	  // ## Main Version
	  // Three dot-separated numeric identifiers.

	  var MAINVERSION = R++;
	  src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';

	  var MAINVERSIONLOOSE = R++;
	  src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

	  // ## Pre-release Version Identifier
	  // A numeric identifier, or a non-numeric identifier.

	  var PRERELEASEIDENTIFIER = R++;
	  src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';

	  var PRERELEASEIDENTIFIERLOOSE = R++;
	  src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';

	  // ## Pre-release Version
	  // Hyphen, followed by one or more dot-separated pre-release version
	  // identifiers.

	  var PRERELEASE = R++;
	  src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

	  var PRERELEASELOOSE = R++;
	  src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

	  // ## Build Metadata Identifier
	  // Any combination of digits, letters, or hyphens.

	  var BUILDIDENTIFIER = R++;
	  src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

	  // ## Build Metadata
	  // Plus sign, followed by one or more period-separated build metadata
	  // identifiers.

	  var BUILD = R++;
	  src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

	  // ## Full Version String
	  // A main version, followed optionally by a pre-release version and
	  // build metadata.

	  // Note that the only major, minor, patch, and pre-release sections of
	  // the version string are capturing groups.  The build metadata is not a
	  // capturing group, because it should not ever be used in version
	  // comparison.

	  var FULL = R++;
	  var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';

	  src[FULL] = '^' + FULLPLAIN + '$';

	  // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	  // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	  // common in the npm registry.
	  var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';

	  var LOOSE = R++;
	  src[LOOSE] = '^' + LOOSEPLAIN + '$';

	  var GTLT = R++;
	  src[GTLT] = '((?:<|>)?=?)';

	  // Something like "2.*" or "1.2.x".
	  // Note that "x.x" is a valid xRange identifer, meaning "any version"
	  // Only the first item is strictly required.
	  var XRANGEIDENTIFIERLOOSE = R++;
	  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	  var XRANGEIDENTIFIER = R++;
	  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

	  var XRANGEPLAIN = R++;
	  src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';

	  var XRANGEPLAINLOOSE = R++;
	  src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';

	  var XRANGE = R++;
	  src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
	  var XRANGELOOSE = R++;
	  src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

	  // Tilde ranges.
	  // Meaning is "reasonably at or greater than"
	  var LONETILDE = R++;
	  src[LONETILDE] = '(?:~>?)';

	  var TILDETRIM = R++;
	  src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
	  re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
	  var tildeTrimReplace = '$1~';

	  var TILDE = R++;
	  src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
	  var TILDELOOSE = R++;
	  src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

	  // Caret ranges.
	  // Meaning is "at least and backwards compatible with"
	  var LONECARET = R++;
	  src[LONECARET] = '(?:\\^)';

	  var CARETTRIM = R++;
	  src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
	  re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
	  var caretTrimReplace = '$1^';

	  var CARET = R++;
	  src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
	  var CARETLOOSE = R++;
	  src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

	  // A simple gt/lt/eq thing, or just "" to indicate "any version"
	  var COMPARATORLOOSE = R++;
	  src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
	  var COMPARATOR = R++;
	  src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

	  // An expression to strip any whitespace between the gtlt and the thing
	  // it modifies, so that `> 1.2.3` ==> `>1.2.3`
	  var COMPARATORTRIM = R++;
	  src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

	  // this one has to use the /g flag
	  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
	  var comparatorTrimReplace = '$1$2$3';

	  // Something like `1.2.3 - 1.2.4`
	  // Note that these all use the loose form, because they'll be
	  // checked against either the strict or loose comparator form
	  // later.
	  var HYPHENRANGE = R++;
	  src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';

	  var HYPHENRANGELOOSE = R++;
	  src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';

	  // Star ranges basically just allow anything at all.
	  var STAR = R++;
	  src[STAR] = '(<|>)?=?\\s*\\*';

	  // Compile to actual regexp objects.
	  // All are flag-free, unless they were created above with a flag.
	  for (var i = 0; i < R; i++) {
	    ;
	    if (!re[i]) re[i] = new RegExp(src[i]);
	  }

	  exports.parse = parse;
	  function parse(version, loose) {
	    if (version.length > MAX_LENGTH) return null;

	    var r = loose ? re[LOOSE] : re[FULL];
	    if (!r.test(version)) return null;

	    try {
	      return new SemVer(version, loose);
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.valid = valid;
	  function valid(version, loose) {
	    var v = parse(version, loose);
	    return v ? v.version : null;
	  }

	  exports.clean = clean;
	  function clean(version, loose) {
	    var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
	    return s ? s.version : null;
	  }

	  exports.SemVer = SemVer;

	  function SemVer(version, loose) {
	    if (version instanceof SemVer) {
	      if (version.loose === loose) return version;else version = version.version;
	    } else if (typeof version !== 'string') {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');

	    if (!(this instanceof SemVer)) return new SemVer(version, loose);

	    ;
	    this.loose = loose;
	    var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

	    if (!m) throw new TypeError('Invalid Version: ' + version);

	    this.raw = version;

	    // these are actually numbers
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');

	    // numberify any prerelease numeric ids
	    if (!m[4]) this.prerelease = [];else this.prerelease = m[4].split('.').map(function (id) {
	      return (/^[0-9]+$/.test(id) ? +id : id
	      );
	    });

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  SemVer.prototype.format = function () {
	    this.version = this.major + '.' + this.minor + '.' + this.patch;
	    if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
	    return this.version;
	  };

	  SemVer.prototype.inspect = function () {
	    return '<SemVer "' + this + '">';
	  };

	  SemVer.prototype.toString = function () {
	    return this.version;
	  };

	  SemVer.prototype.compare = function (other) {
	    ;
	    if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

	    return this.compareMain(other) || this.comparePre(other);
	  };

	  SemVer.prototype.compareMain = function (other) {
	    if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

	    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
	  };

	  SemVer.prototype.comparePre = function (other) {
	    if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

	    // NOT having a prerelease is > having one
	    if (this.prerelease.length && !other.prerelease.length) return -1;else if (!this.prerelease.length && other.prerelease.length) return 1;else if (!this.prerelease.length && !other.prerelease.length) return 0;

	    var i = 0;
	    do {
	      var a = this.prerelease[i];
	      var b = other.prerelease[i];
	      ;
	      if (a === undefined && b === undefined) return 0;else if (b === undefined) return 1;else if (a === undefined) return -1;else if (a === b) continue;else return compareIdentifiers(a, b);
	    } while (++i);
	  };

	  // preminor will bump the version up to the next minor release, and immediately
	  // down to pre-release. premajor and prepatch work the same way.
	  SemVer.prototype.inc = function (release, identifier) {
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier);
	        break;
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier);
	        break;
	      case 'prepatch':
	        // If this is already a prerelease, it will bump to the next version
	        // drop any prereleases that might already exist, since they are not
	        // relevant at this point.
	        this.prerelease.length = 0;
	        this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;
	      // If the input is a non-prerelease version, this acts the same as
	      // prepatch.
	      case 'prerelease':
	        if (this.prerelease.length === 0) this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;

	      case 'major':
	        // If this is a pre-major version, bump up to the same major version.
	        // Otherwise increment major.
	        // 1.0.0-5 bumps to 1.0.0
	        // 1.1.0 bumps to 2.0.0
	        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break;
	      case 'minor':
	        // If this is a pre-minor version, bump up to the same minor version.
	        // Otherwise increment minor.
	        // 1.2.0-5 bumps to 1.2.0
	        // 1.2.1 bumps to 1.3.0
	        if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
	        this.patch = 0;
	        this.prerelease = [];
	        break;
	      case 'patch':
	        // If this is not a pre-release version, it will increment the patch.
	        // If it is a pre-release it will bump up to the same patch version.
	        // 1.2.0-5 patches to 1.2.0
	        // 1.2.0 patches to 1.2.1
	        if (this.prerelease.length === 0) this.patch++;
	        this.prerelease = [];
	        break;
	      // This probably shouldn't be used publicly.
	      // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
	      case 'pre':
	        if (this.prerelease.length === 0) this.prerelease = [0];else {
	          var i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) // didn't increment anything
	            this.prerelease.push(0);
	        }
	        if (identifier) {
	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	          if (this.prerelease[0] === identifier) {
	            if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
	          } else this.prerelease = [identifier, 0];
	        }
	        break;

	      default:
	        throw new Error('invalid increment argument: ' + release);
	    }
	    this.format();
	    return this;
	  };

	  exports.inc = inc;
	  function inc(version, release, loose, identifier) {
	    if (typeof loose === 'string') {
	      identifier = loose;
	      loose = undefined;
	    }

	    try {
	      return new SemVer(version, loose).inc(release, identifier).version;
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.diff = diff;
	  function diff(version1, version2) {
	    if (eq(version1, version2)) {
	      return null;
	    } else {
	      var v1 = parse(version1);
	      var v2 = parse(version2);
	      if (v1.prerelease.length || v2.prerelease.length) {
	        for (var key in v1) {
	          if (key === 'major' || key === 'minor' || key === 'patch') {
	            if (v1[key] !== v2[key]) {
	              return 'pre' + key;
	            }
	          }
	        }
	        return 'prerelease';
	      }
	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return key;
	          }
	        }
	      }
	    }
	  }

	  exports.compareIdentifiers = compareIdentifiers;

	  var numeric = /^[0-9]+$/;
	  function compareIdentifiers(a, b) {
	    var anum = numeric.test(a);
	    var bnum = numeric.test(b);

	    if (anum && bnum) {
	      a = +a;
	      b = +b;
	    }

	    return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
	  }

	  exports.rcompareIdentifiers = rcompareIdentifiers;
	  function rcompareIdentifiers(a, b) {
	    return compareIdentifiers(b, a);
	  }

	  exports.major = major;
	  function major(a, loose) {
	    return new SemVer(a, loose).major;
	  }

	  exports.minor = minor;
	  function minor(a, loose) {
	    return new SemVer(a, loose).minor;
	  }

	  exports.patch = patch;
	  function patch(a, loose) {
	    return new SemVer(a, loose).patch;
	  }

	  exports.compare = compare;
	  function compare(a, b, loose) {
	    return new SemVer(a, loose).compare(b);
	  }

	  exports.compareLoose = compareLoose;
	  function compareLoose(a, b) {
	    return compare(a, b, true);
	  }

	  exports.rcompare = rcompare;
	  function rcompare(a, b, loose) {
	    return compare(b, a, loose);
	  }

	  exports.sort = sort;
	  function sort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compare(a, b, loose);
	    });
	  }

	  exports.rsort = rsort;
	  function rsort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.rcompare(a, b, loose);
	    });
	  }

	  exports.gt = gt;
	  function gt(a, b, loose) {
	    return compare(a, b, loose) > 0;
	  }

	  exports.lt = lt;
	  function lt(a, b, loose) {
	    return compare(a, b, loose) < 0;
	  }

	  exports.eq = eq;
	  function eq(a, b, loose) {
	    return compare(a, b, loose) === 0;
	  }

	  exports.neq = neq;
	  function neq(a, b, loose) {
	    return compare(a, b, loose) !== 0;
	  }

	  exports.gte = gte;
	  function gte(a, b, loose) {
	    return compare(a, b, loose) >= 0;
	  }

	  exports.lte = lte;
	  function lte(a, b, loose) {
	    return compare(a, b, loose) <= 0;
	  }

	  exports.cmp = cmp;
	  function cmp(a, op, b, loose) {
	    var ret;
	    switch (op) {
	      case '===':
	        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') a = a.version;
	        if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') b = b.version;
	        ret = a === b;
	        break;
	      case '!==':
	        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') a = a.version;
	        if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') b = b.version;
	        ret = a !== b;
	        break;
	      case '':case '=':case '==':
	        ret = eq(a, b, loose);break;
	      case '!=':
	        ret = neq(a, b, loose);break;
	      case '>':
	        ret = gt(a, b, loose);break;
	      case '>=':
	        ret = gte(a, b, loose);break;
	      case '<':
	        ret = lt(a, b, loose);break;
	      case '<=':
	        ret = lte(a, b, loose);break;
	      default:
	        throw new TypeError('Invalid operator: ' + op);
	    }
	    return ret;
	  }

	  exports.Comparator = Comparator;
	  function Comparator(comp, loose) {
	    if (comp instanceof Comparator) {
	      if (comp.loose === loose) return comp;else comp = comp.value;
	    }

	    if (!(this instanceof Comparator)) return new Comparator(comp, loose);

	    ;
	    this.loose = loose;
	    this.parse(comp);

	    if (this.semver === ANY) this.value = '';else this.value = this.operator + this.semver.version;

	    ;
	  }

	  var ANY = {};
	  Comparator.prototype.parse = function (comp) {
	    var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	    var m = comp.match(r);

	    if (!m) throw new TypeError('Invalid comparator: ' + comp);

	    this.operator = m[1];
	    if (this.operator === '=') this.operator = '';

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) this.semver = ANY;else this.semver = new SemVer(m[2], this.loose);
	  };

	  Comparator.prototype.inspect = function () {
	    return '<SemVer Comparator "' + this + '">';
	  };

	  Comparator.prototype.toString = function () {
	    return this.value;
	  };

	  Comparator.prototype.test = function (version) {
	    ;

	    if (this.semver === ANY) return true;

	    if (typeof version === 'string') version = new SemVer(version, this.loose);

	    return cmp(version, this.operator, this.semver, this.loose);
	  };

	  exports.Range = Range;
	  function Range(range, loose) {
	    if (range instanceof Range && range.loose === loose) return range;

	    if (!(this instanceof Range)) return new Range(range, loose);

	    this.loose = loose;

	    // First, split based on boolean or ||
	    this.raw = range;
	    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
	      return this.parseRange(range.trim());
	    }, this).filter(function (c) {
	      // throw out any that are not relevant for whatever reason
	      return c.length;
	    });

	    if (!this.set.length) {
	      throw new TypeError('Invalid SemVer Range: ' + range);
	    }

	    this.format();
	  }

	  Range.prototype.inspect = function () {
	    return '<SemVer Range "' + this.range + '">';
	  };

	  Range.prototype.format = function () {
	    this.range = this.set.map(function (comps) {
	      return comps.join(' ').trim();
	    }).join('||').trim();
	    return this.range;
	  };

	  Range.prototype.toString = function () {
	    return this.range;
	  };

	  Range.prototype.parseRange = function (range) {
	    var loose = this.loose;
	    range = range.trim();
	    ;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace);
	    ;
	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
	    ;

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[TILDETRIM], tildeTrimReplace);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[CARETTRIM], caretTrimReplace);

	    // normalize spaces
	    range = range.split(/\s+/).join(' ');

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	    var set = range.split(' ').map(function (comp) {
	      return parseComparator(comp, loose);
	    }).join(' ').split(/\s+/);
	    if (this.loose) {
	      // in loose mode, throw out any that are not valid comparators
	      set = set.filter(function (comp) {
	        return !!comp.match(compRe);
	      });
	    }
	    set = set.map(function (comp) {
	      return new Comparator(comp, loose);
	    });

	    return set;
	  };

	  // Mostly just for testing and legacy API reasons
	  exports.toComparators = toComparators;
	  function toComparators(range, loose) {
	    return new Range(range, loose).set.map(function (comp) {
	      return comp.map(function (c) {
	        return c.value;
	      }).join(' ').trim().split(' ');
	    });
	  }

	  // comprised of xranges, tildes, stars, and gtlt's at this point.
	  // already replaced the hyphen ranges
	  // turn into a set of JUST comparators.
	  function parseComparator(comp, loose) {
	    ;
	    comp = replaceCarets(comp, loose);
	    ;
	    comp = replaceTildes(comp, loose);
	    ;
	    comp = replaceXRanges(comp, loose);
	    ;
	    comp = replaceStars(comp, loose);
	    ;
	    return comp;
	  }

	  function isX(id) {
	    return !id || id.toLowerCase() === 'x' || id === '*';
	  }

	  // ~, ~> --> * (any, kinda silly)
	  // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
	  // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
	  // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
	  // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
	  // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
	  function replaceTildes(comp, loose) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceTilde(comp, loose);
	    }).join(' ');
	  }

	  function replaceTilde(comp, loose) {
	    var r = loose ? re[TILDELOOSE] : re[TILDE];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      ;
	      var ret;

	      if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p))
	        // ~1.2 == >=1.2.0- <1.3.0-
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else if (pr) {
	        ;
	        if (pr.charAt(0) !== '-') pr = '-' + pr;
	        ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        // ~1.2.3 == >=1.2.3 <1.3.0
	        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';

	      ;
	      return ret;
	    });
	  }

	  // ^ --> * (any, kinda silly)
	  // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
	  // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
	  // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
	  // ^1.2.3 --> >=1.2.3 <2.0.0
	  // ^1.2.0 --> >=1.2.0 <2.0.0
	  function replaceCarets(comp, loose) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceCaret(comp, loose);
	    }).join(' ');
	  }

	  function replaceCaret(comp, loose) {
	    ;
	    var r = loose ? re[CARETLOOSE] : re[CARET];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      ;
	      var ret;

	      if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) {
	        if (M === '0') ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	      } else if (pr) {
	        ;
	        if (pr.charAt(0) !== '-') pr = '-' + pr;
	        if (M === '0') {
	          if (m === '0') ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
	        } else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
	      } else {
	        ;
	        if (M === '0') {
	          if (m === '0') ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	        } else ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
	      }

	      ;
	      return ret;
	    });
	  }

	  function replaceXRanges(comp, loose) {
	    ;
	    return comp.split(/\s+/).map(function (comp) {
	      return replaceXRange(comp, loose);
	    }).join(' ');
	  }

	  function replaceXRange(comp, loose) {
	    comp = comp.trim();
	    var r = loose ? re[XRANGELOOSE] : re[XRANGE];
	    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
	      ;
	      var xM = isX(M);
	      var xm = xM || isX(m);
	      var xp = xm || isX(p);
	      var anyX = xp;

	      if (gtlt === '=' && anyX) gtlt = '';

	      if (xM) {
	        if (gtlt === '>' || gtlt === '<') {
	          // nothing is allowed
	          ret = '<0.0.0';
	        } else {
	          // nothing is forbidden
	          ret = '*';
	        }
	      } else if (gtlt && anyX) {
	        // replace X with 0
	        if (xm) m = 0;
	        if (xp) p = 0;

	        if (gtlt === '>') {
	          // >1 => >=2.0.0
	          // >1.2 => >=1.3.0
	          // >1.2.3 => >= 1.2.4
	          gtlt = '>=';
	          if (xm) {
	            M = +M + 1;
	            m = 0;
	            p = 0;
	          } else if (xp) {
	            m = +m + 1;
	            p = 0;
	          }
	        } else if (gtlt === '<=') {
	          // <=0.7.x is actually <0.8.0, since any 0.7.x should
	          // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	          gtlt = '<';
	          if (xm) M = +M + 1;else m = +m + 1;
	        }

	        ret = gtlt + M + '.' + m + '.' + p;
	      } else if (xm) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (xp) {
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      }

	      ;

	      return ret;
	    });
	  }

	  // Because * is AND-ed with everything else in the comparator,
	  // and '' means "any version", just remove the *s entirely.
	  function replaceStars(comp, loose) {
	    ;
	    // Looseness is ignored here.  star is always as loose as it gets!
	    return comp.trim().replace(re[STAR], '');
	  }

	  // This function is passed to string.replace(re[HYPHENRANGE])
	  // M, m, patch, prerelease, build
	  // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	  // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
	  // 1.2 - 3.4 => >=1.2.0 <3.5.0
	  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {

	    if (isX(fM)) from = '';else if (isX(fm)) from = '>=' + fM + '.0.0';else if (isX(fp)) from = '>=' + fM + '.' + fm + '.0';else from = '>=' + from;

	    if (isX(tM)) to = '';else if (isX(tm)) to = '<' + (+tM + 1) + '.0.0';else if (isX(tp)) to = '<' + tM + '.' + (+tm + 1) + '.0';else if (tpr) to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;else to = '<=' + to;

	    return (from + ' ' + to).trim();
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  Range.prototype.test = function (version) {
	    if (!version) return false;

	    if (typeof version === 'string') version = new SemVer(version, this.loose);

	    for (var i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version)) return true;
	    }
	    return false;
	  };

	  function testSet(set, version) {
	    for (var i = 0; i < set.length; i++) {
	      if (!set[i].test(version)) return false;
	    }

	    if (version.prerelease.length) {
	      // Find the set of versions that are allowed to have prereleases
	      // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	      // That should allow `1.2.3-pr.2` to pass.
	      // However, `1.2.4-alpha.notready` should NOT be allowed,
	      // even though it's within the range set by the comparators.
	      for (var i = 0; i < set.length; i++) {
	        ;
	        if (set[i].semver === ANY) return true;

	        if (set[i].semver.prerelease.length > 0) {
	          var allowed = set[i].semver;
	          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
	        }
	      }

	      // Version has a -pre, but it's not one of the ones we like.
	      return false;
	    }

	    return true;
	  }

	  exports.satisfies = satisfies;
	  function satisfies(version, range, loose) {
	    try {
	      range = new Range(range, loose);
	    } catch (er) {
	      return false;
	    }
	    return range.test(version);
	  }

	  exports.maxSatisfying = maxSatisfying;
	  function maxSatisfying(versions, range, loose) {
	    return versions.filter(function (version) {
	      return satisfies(version, range, loose);
	    }).sort(function (a, b) {
	      return rcompare(a, b, loose);
	    })[0] || null;
	  }

	  exports.validRange = validRange;
	  function validRange(range, loose) {
	    try {
	      // Return '*' instead of '' so that truthiness works.
	      // This will throw if it's invalid anyway
	      return new Range(range, loose).range || '*';
	    } catch (er) {
	      return null;
	    }
	  }

	  // Determine if version is less than all the versions possible in the range
	  exports.ltr = ltr;
	  function ltr(version, range, loose) {
	    return outside(version, range, '<', loose);
	  }

	  // Determine if version is greater than all the versions possible in the range.
	  exports.gtr = gtr;
	  function gtr(version, range, loose) {
	    return outside(version, range, '>', loose);
	  }

	  exports.outside = outside;
	  function outside(version, range, hilo, loose) {
	    version = new SemVer(version, loose);
	    range = new Range(range, loose);

	    var gtfn, ltefn, ltfn, comp, ecomp;
	    switch (hilo) {
	      case '>':
	        gtfn = gt;
	        ltefn = lte;
	        ltfn = lt;
	        comp = '>';
	        ecomp = '>=';
	        break;
	      case '<':
	        gtfn = lt;
	        ltefn = gte;
	        ltfn = gt;
	        comp = '<';
	        ecomp = '<=';
	        break;
	      default:
	        throw new TypeError('Must provide a hilo val of "<" or ">"');
	    }

	    // If it satisifes the range it is not outside
	    if (satisfies(version, range, loose)) {
	      return false;
	    }

	    // From now on, variable terms are as if we're in "gtr" mode.
	    // but note that everything is flipped for the "ltr" function.

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];

	      var high = null;
	      var low = null;

	      comparators.forEach(function (comparator) {
	        high = high || comparator;
	        low = low || comparator;
	        if (gtfn(comparator.semver, high.semver, loose)) {
	          high = comparator;
	        } else if (ltfn(comparator.semver, low.semver, loose)) {
	          low = comparator;
	        }
	      });

	      // If the edge version comparator has a operator then our version
	      // isn't outside it
	      if (high.operator === comp || high.operator === ecomp) {
	        return false;
	      }

	      // If the lowest version comparator has an operator and our version
	      // is less than it then it isn't higher than the range
	      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
	        return false;
	      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  // Use the define() function if we're in AMD land
	  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (exports), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(( false ? 'undefined' : _typeof(exports)) === 'object' ? exports :  true ? {} : semver = {});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(218)(module)))

/***/ },
/* 485 */,
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process) {'use strict';

	var EventEmitter = __webpack_require__(188).EventEmitter;
	var util = __webpack_require__(263);
	var utils = __webpack_require__(477);
	var NativeResult = __webpack_require__(487);

	var NativeQuery = module.exports = function (native) {
	  EventEmitter.call(this);
	  this.native = native;
	  this.text = null;
	  this.values = null;
	  this.name = null;
	  this.callback = null;
	  this.state = 'new';
	  this._arrayMode = false;

	  //if the 'row' event is listened for
	  //then emit them as they come in
	  //without setting singleRowMode to true
	  //this has almost no meaning because libpq
	  //reads all rows into memory befor returning any
	  this._emitRowEvents = false;
	  this.on('newListener', function (event) {
	    if (event === 'row') this._emitRowEvents = true;
	  }.bind(this));
	};

	util.inherits(NativeQuery, EventEmitter);

	NativeQuery.prototype.then = function (callback) {
	  return this.promise().then(callback);
	};

	NativeQuery.prototype.catch = function (callback) {
	  return this.promise().catch(callback);
	};

	NativeQuery.prototype.promise = function () {
	  if (this._promise) return this._promise;
	  this._promise = new Promise(function (resolve, reject) {
	    this.once('end', resolve);
	    this.once('error', reject);
	  }.bind(this));
	  return this._promise;
	};

	NativeQuery.prototype.handleError = function (err) {
	  var self = this;
	  //copy pq error fields into the error object
	  var fields = self.native.pq.resultErrorFields();
	  if (fields) {
	    for (var key in fields) {
	      err[key] = fields[key];
	    }
	  }
	  if (self.callback) {
	    self.callback(err);
	  } else {
	    self.emit('error', err);
	  }
	  self.state = 'error';
	};

	NativeQuery.prototype.submit = function (client) {
	  this.state = 'running';
	  var self = this;
	  client.native.arrayMode = this._arrayMode;

	  var after = function after(err, rows) {
	    client.native.arrayMode = false;
	    setImmediate(function () {
	      self.emit('_done');
	    });

	    //handle possible query error
	    if (err) {
	      return self.handleError(err);
	    }

	    var result = new NativeResult();
	    result.addCommandComplete(self.native.pq);
	    result.rows = rows;

	    //emit row events for each row in the result
	    if (self._emitRowEvents) {
	      rows.forEach(function (row) {
	        self.emit('row', row, result);
	      });
	    }

	    //handle successful result
	    self.state = 'end';
	    self.emit('end', result);
	    if (self.callback) {
	      self.callback(null, result);
	    }
	  };

	  if (process.domain) {
	    after = process.domain.bind(after);
	  }

	  //named query
	  if (this.name) {
	    if (this.name.length > 63) {
	      console.error('Warning! Postgres only supports 63 characters for query names.');
	      console.error('You supplied', this.name, '(', this.name.length, ')');
	      console.error('This can cause conflicts and silent errors executing queries');
	    }
	    var values = (this.values || []).map(utils.prepareValue);

	    //check if the client has already executed this named query
	    //if so...just execute it again - skip the planning phase
	    if (client.namedQueries[this.name]) {
	      return this.native.execute(this.name, values, after);
	    }
	    //plan the named query the first time, then execute it
	    return this.native.prepare(this.name, this.text, values.length, function (err) {
	      if (err) return after(err);
	      client.namedQueries[self.name] = true;
	      return self.native.execute(self.name, values, after);
	    });
	  } else if (this.values) {
	    var vals = this.values.map(utils.prepareValue);
	    this.native.query(this.text, vals, after);
	  } else {
	    this.native.query(this.text, after);
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(192).setImmediate, __webpack_require__(4)))

/***/ },
/* 487 */
/***/ function(module, exports) {

	'use strict';

	var NativeResult = module.exports = function (pq) {
	  this.command = null;
	  this.rowCount = 0;
	  this.rows = null;
	  this.fields = null;
	};

	NativeResult.prototype.addCommandComplete = function (pq) {
	  this.command = pq.cmdStatus().split(' ')[0];
	  this.rowCount = parseInt(pq.cmdTuples(), 10);
	  var nfields = pq.nfields();
	  if (nfields < 1) return;

	  this.fields = [];
	  for (var i = 0; i < nfields; i++) {
	    this.fields.push({
	      name: pq.fname(i),
	      dataTypeID: pq.ftype(i)
	    });
	  }
	};

	NativeResult.prototype.addRow = function (row) {
	  // This is empty to ensure pg code doesn't break when switching to pg-native
	  // pg-native loads all rows into the final result object by default.
	  // This is because libpg loads all rows into memory before passing the result
	  // to pg-native.
	};

/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parser = __webpack_require__(489);
	var error = __webpack_require__(491);

	parser.minify.SQLParsingError = error.SQLParsingError;
	parser.minify.parsingErrorCode = error.parsingErrorCode;

	module.exports = parser.minify;

/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var os = __webpack_require__(490);
	var errorLib = __webpack_require__(491);

	var PEC = errorLib.parsingErrorCode;

	// symbols that need no spaces around them:
	var compressors = '.,;:()[]=<>+-*/|!?@#';

	///////////////////////////////////////////
	// Parses and minifies a PostgreSQL script.
	function minify(sql, options) {

	    if (typeof sql !== 'string') {
	        throw new TypeError("Input SQL must be a text string.");
	    }

	    if (options !== undefined && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
	        throw new TypeError("Parameter 'options' must be an object.");
	    }

	    if (!sql.length) {
	        return '';
	    }

	    var idx = 0,
	        // current index
	    result = '',
	        // resulting sql
	    len = sql.length,
	        // sql length
	    EOL = getEOL(sql),
	        // end-of-line
	    space = false,
	        // add a space on the next step
	    compress = options && options.compress; // options 'compress'

	    do {
	        var s = sql[idx],
	            // current symbol;
	        s1 = idx < len - 1 ? sql[idx + 1] : ''; // next symbol;

	        if (isGap(s)) {
	            while (++idx < len && isGap(sql[idx])) {}
	            if (idx < len) {
	                space = true;
	            }
	            idx--;
	            continue;
	        }

	        if (s === '-' && s1 === '-') {
	            var lb = sql.indexOf(EOL, idx + 2);
	            if (lb < 0) {
	                break;
	            }
	            idx = lb - 1;
	            skipGaps();
	            continue;
	        }

	        if (s === '/' && s1 === '*') {
	            var end = sql.indexOf('*/', idx + 2);
	            if (end < 0) {
	                throwError(PEC.unclosedMLC);
	            }
	            idx = end + 1;
	            skipGaps();
	            continue;
	        }

	        if (s === '"') {
	            var closeIdx = sql.indexOf('"', idx + 1);
	            if (closeIdx < 0) {
	                throwError(PEC.unclosedQI);
	            }
	            var text = sql.substr(idx, closeIdx - idx + 1);
	            if (text.indexOf(EOL) > 0) {
	                throwError(PEC.multiLineQI);
	            }
	            if (compress) {
	                space = false;
	            }
	            addSpace();
	            result += text;
	            idx = closeIdx;
	            skipGaps();
	            continue;
	        }

	        if (s === '\'') {
	            var closeIdx = idx;
	            do {
	                closeIdx = sql.indexOf('\'', closeIdx + 1);
	                if (closeIdx > 0) {
	                    var step = closeIdx;
	                    while (++step < len && sql[step] === '\'') {}
	                    if ((step - closeIdx) % 2) {
	                        closeIdx = step - 1;
	                        break;
	                    }
	                    closeIdx = step === len ? -1 : step;
	                }
	            } while (closeIdx > 0);
	            if (closeIdx < 0) {
	                throwError(PEC.unclosedText);
	            }
	            if (compress) {
	                space = false;
	            }
	            addSpace();
	            var text = sql.substr(idx, closeIdx - idx + 1);
	            var hasLB = text.indexOf(EOL) > 0;
	            if (hasLB) {
	                text = text.split(EOL).map(function (m) {
	                    return m.replace(/^\s+|\s+$/g, '');
	                }).join('\\n');
	            }
	            var hasTabs = text.indexOf('\t') > 0;
	            if (hasLB || hasTabs) {
	                var prev = idx ? sql[idx - 1] : '';
	                if (prev !== 'E' && prev !== 'e') {
	                    var r = result ? result[result.length - 1] : '';
	                    if (r && r !== ' ' && compressors.indexOf(r) < 0) {
	                        result += ' ';
	                    }
	                    result += 'E';
	                }
	                if (hasTabs) {
	                    text = text.replace(/\t/g, '\\t');
	                }
	            }
	            result += text;
	            idx = closeIdx;
	            skipGaps();
	            continue;
	        }

	        if (compress && compressors.indexOf(s) >= 0) {
	            space = false;
	            skipGaps();
	        }

	        addSpace();
	        result += s;
	    } while (++idx < len);

	    return result;

	    function skipGaps() {
	        if (compress) {
	            while (idx < len - 1 && isGap(sql[idx + 1])) {
	                idx++;
	            }
	        }
	    }

	    function addSpace() {
	        if (space) {
	            if (result.length) {
	                result += ' ';
	            }
	            space = false;
	        }
	    }

	    function throwError(code) {
	        var position = getIndexPos(sql, idx, EOL);
	        throw new errorLib.SQLParsingError(code, position);
	    }
	}

	//////////////////////////////////////
	// Returns the End-Of-Line from text.
	function getEOL(text) {
	    var idx = 0,
	        unix = 0,
	        windows = 0;
	    while (idx < text.length) {
	        idx = text.indexOf('\n', idx);
	        if (idx == -1) {
	            break;
	        }
	        if (idx > 0 && text[idx - 1] === '\r') {
	            windows++;
	        } else {
	            unix++;
	        }
	        idx++;
	    }
	    if (unix === windows) {
	        return os.EOL;
	    }
	    return unix > windows ? '\n' : '\r\n';
	}

	///////////////////////////////////////////////////////
	// Returns {line, column} of an index within the text.
	function getIndexPos(text, index, eol) {
	    var lineIdx = 0,
	        colIdx = index,
	        pos = 0;
	    do {
	        pos = text.indexOf(eol, pos);
	        if (pos == -1 || index < pos + eol.length) {
	            break;
	        }
	        lineIdx++;
	        pos += eol.length;
	        colIdx = index - pos;
	    } while (pos < index);
	    return {
	        line: lineIdx + 1,
	        column: colIdx + 1
	    };
	}

	////////////////////////////////////
	// Identifies a gap / empty symbol.
	function isGap(s) {
	    return s === ' ' || s === '\t' || s === '\r' || s === '\n';
	}

	module.exports = {
	    minify: minify,

	    // these are exported only for testing:
	    getEOL: getEOL,
	    getIndexPos: getIndexPos
	};

/***/ },
/* 490 */
/***/ function(module, exports) {

	'use strict';

	exports.endianness = function () {
	    return 'LE';
	};

	exports.hostname = function () {
	    if (typeof location !== 'undefined') {
	        return location.hostname;
	    } else return '';
	};

	exports.loadavg = function () {
	    return [];
	};

	exports.uptime = function () {
	    return 0;
	};

	exports.freemem = function () {
	    return Number.MAX_VALUE;
	};

	exports.totalmem = function () {
	    return Number.MAX_VALUE;
	};

	exports.cpus = function () {
	    return [];
	};

	exports.type = function () {
	    return 'Browser';
	};

	exports.release = function () {
	    if (typeof navigator !== 'undefined') {
	        return navigator.appVersion;
	    }
	    return '';
	};

	exports.networkInterfaces = exports.getNetworkInterfaces = function () {
	    return {};
	};

	exports.arch = function () {
	    return 'javascript';
	};

	exports.platform = function () {
	    return 'browser';
	};

	exports.tmpdir = exports.tmpDir = function () {
	    return '/tmp';
	};

	exports.EOL = '\n';

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EOL = __webpack_require__(490).EOL;

	var parsingErrorCode = {
	    unclosedMLC: 0, // Unclosed multi-line comment.
	    unclosedText: 1, // Unclosed text block.
	    unclosedQI: 2, // Unclosed quoted identifier.
	    multiLineQI: 3 // Multi-line quoted identifiers are not supported.
	};

	Object.freeze(parsingErrorCode);

	var errorMessages = [{ name: "unclosedMLC", message: "Unclosed multi-line comment." }, { name: "unclosedText", message: "Unclosed text block." }, { name: "unclosedQI", message: "Unclosed quoted identifier." }, { name: "multiLineQI", message: "Multi-line quoted identifiers are not supported." }];

	function SQLParsingError(code, position) {
	    var temp = Error.apply(this, arguments);
	    temp.name = this.name = 'SQLParsingError';
	    this.stack = temp.stack;
	    this.code = code; // one of parsingErrorCode values;
	    this.error = errorMessages[code].message;
	    this.position = position; // Error position in the text: {line, column}
	    this.message = "Error parsing SQL at {line:" + position.line + ",col:" + position.column + "}: " + this.error;
	}

	SQLParsingError.prototype = Object.create(Error.prototype, {
	    constructor: {
	        value: SQLParsingError,
	        writable: true,
	        configurable: true
	    }
	});

	SQLParsingError.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap = messageGap(level + 1);
	    var lines = ['SQLParsingError {', gap + 'code: parsingErrorCode.' + errorMessages[this.code].name, gap + 'error: "' + this.error + '"', gap + 'position: {line: ' + this.position.line + ", col: " + this.position.column + '}', messageGap(level) + '}'];
	    return lines.join(EOL);
	};

	function messageGap(level) {
	    return Array(1 + level * 4).join(' ');
	}

	SQLParsingError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = {
	    SQLParsingError: SQLParsingError,
	    parsingErrorCode: parsingErrorCode
	};

/***/ },
/* 492 */
/***/ function(module, exports) {

	'use strict';

	// Number of times it is faster than the standard 'map', by Node.js versions:
	// 0.10.44: ~2.8
	// 0.11.16: ~3.8
	// 0.12.13: ~3.8
	// 4.4.4: ~1.38
	// 5.11.0: ~1.44
	// 6.1.0: ~8.25

	function map(arr, cb, obj) {
	    var res = new Array(arr.length);
	    if (obj) {
	        for (var i = 0; i < arr.length; i++) {
	            res[i] = cb.call(obj, arr[i], i, arr);
	        }
	    } else {
	        for (var i = 0; i < arr.length; i++) {
	            res[i] = cb(arr[i], i, arr);
	        }
	    }
	    return res;
	}

	// Number of times it is faster than the standard 'filter', by Node.js versions:
	// 0.10.44: ~2.42
	// 0.11.16: ~2.83
	// 0.12.13: ~2.78
	// 4.4.4: ~1.12
	// 5.11.0: ~1.14
	// 6.1.0: ~7.54
	function filter(arr, cb, obj) {
	    var res = [];
	    if (obj) {
	        for (var i = 0; i < arr.length; i++) {
	            if (cb.call(obj, arr[i], i, arr)) {
	                res.push(arr[i]);
	            }
	        }
	    } else {
	        for (var i = 0; i < arr.length; i++) {
	            if (cb(arr[i], i, arr)) {
	                res.push(arr[i]);
	            }
	        }
	    }
	    return res;
	}

	// Number of times it is faster than the standard 'forEach', by Node.js versions:
	// 0.10.44: ~3.11
	// 0.11.16: ~4.6
	// 0.12.13: ~4.4
	// 4.4.4: ~1.55
	// 5.11.0: ~1.54
	// 6.1.0: ~1.21
	function forEach(arr, cb, obj) {
	    if (obj) {
	        for (var i = 0; i < arr.length; i++) {
	            cb.call(obj, arr[i], i, arr);
	        }
	    } else {
	        for (var i = 0; i < arr.length; i++) {
	            cb(arr[i], i, arr);
	        }
	    }
	}

	//////////////////////////
	// Custom Methods
	//////////////////////////

	// Counts elements based on a condition;
	function countIf(arr, cb, obj) {
	    var count = 0;
	    if (obj) {
	        for (var i = 0; i < arr.length; i++) {
	            count += cb.call(obj, arr[i], i, arr) ? 1 : 0;
	        }
	    } else {
	        for (var i = 0; i < arr.length; i++) {
	            count += cb(arr[i], i, arr) ? 1 : 0;
	        }
	    }
	    return count;
	}

	module.exports = {
	    map: map,
	    filter: filter,
	    forEach: forEach,
	    countIf: countIf
	};

	Object.freeze(module.exports);

/***/ },
/* 493 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * @constructor PromiseAdapter
	 * @summary Adapter for the primary promise operations.
	 * @description
	 * Provides compatibility with promise libraries that cannot be recognized automatically,
	 * via functions that implement the primary operations with promises:
	 *
	 *  - construct a new promise with a callback function
	 *  - resolve a promise with some result data
	 *  - reject a promise with a reason
	 *
	 * The type is available from the library's root: `pgp.PromiseAdapter`.
	 *
	 * @param {function} create
	 * A function that takes a callback parameter and returns a new promise object.
	 * The callback parameter is expected to be `function(resolve, reject)`.
	 *
	 * Passing in anything other than a function will throw `Adapter requires a function to create a promise.`
	 *
	 * @param {function} resolve
	 * A function that takes an optional data parameter and resolves a promise with it.
	 *
	 * Passing in anything other than a function will throw `Adapter requires a function to resolve a promise.`
	 *
	 * @param {function} reject
	 * A function that takes an optional error parameter and rejects a promise with it.
	 *
	 * Passing in anything other than a function will throw `Adapter requires a function to reject a promise.`
	 * 
	 * @returns {PromiseAdapter}
	 */

	function PromiseAdapter(create, resolve, reject) {

	    if (!(this instanceof PromiseAdapter)) {
	        return new PromiseAdapter(create, resolve, reject);
	    }

	    this.create = create;
	    this.resolve = resolve;
	    this.reject = reject;

	    if (typeof create !== 'function') {
	        throw new TypeError('Adapter requires a function to create a promise.');
	    }

	    if (typeof resolve !== 'function') {
	        throw new TypeError('Adapter requires a function to resolve a promise.');
	    }

	    if (typeof reject !== 'function') {
	        throw new TypeError('Adapter requires a function to reject a promise.');
	    }
	}

	module.exports = PromiseAdapter;

/***/ },
/* 494 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * @enum {number}
	 * @alias queryResult
	 * @readonly
	 * @summary Query Result Mask.
	 * @description
	 * Binary mask that represents the result expected from queries.
	 * It is used in the generic {@link Database.query query} method,
	 * as well as method {@link Database.func func}.
	 *
	 * The mask is always the last optional parameter, which defaults to `queryResult.any`.
	 *
	 * Any combination of flags is supported, except for `one + many`.
	 *
	 * The type is available from the library's root: `pgp.queryResult`.
	 *
	 * @see {@link Database.query}, {@link Database.func}
	 */

	var queryResult = {
	  /** Single row is expected. */
	  one: 1,
	  /** One or more rows expected. */
	  many: 2,
	  /** Expecting no rows. */
	  none: 4,
	  /** `many|none` - any result is expected. */
	  any: 6
	};

	Object.freeze(queryResult);

	module.exports = queryResult;

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var PromiseAdapter = __webpack_require__(493);

	//////////////////////////////////////////
	// Parses and validates a promise library;
	function parsePromiseLib(pl) {

	    var promise;
	    if (pl instanceof PromiseAdapter) {
	        promise = function promise(func) {
	            return pl.create(func);
	        };
	        promise.resolve = pl.resolve;
	        promise.reject = pl.reject;
	        return promise;
	    }
	    var t = typeof pl === 'undefined' ? 'undefined' : _typeof(pl);
	    if (t === 'function' || t === 'object') {
	        var root = pl.Promise instanceof Function ? pl.Promise : pl;
	        promise = function promise(func) {
	            return new root(func);
	        };
	        promise.resolve = root.resolve;
	        promise.reject = root.reject;
	        if (promise.resolve instanceof Function && promise.reject instanceof Function) {
	            return promise;
	        }
	    }

	    throw new TypeError("Invalid promise library specified.");
	}

	function init(promiseLib) {
	    var result = {
	        promiseLib: promiseLib
	    };
	    if (promiseLib) {
	        result.promise = parsePromiseLib(promiseLib);
	    } else {
	        // istanbul ignore if
	        // Excluding from coverage, because it is
	        // only triggered for NodeJS prior to 0.12
	        if (typeof Promise === 'undefined') {
	            // ES6 Promise isn't supported, NodeJS is pre-0.12;
	            throw new TypeError("Promise library must be specified.");
	        }
	        result.promise = parsePromiseLib(Promise);
	        result.promiseLib = Promise;
	    }
	    return result;
	}

	module.exports = init;

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $arr = __webpack_require__(492);

	// Format Modification Flags;
	var fmFlags = {
	    raw: 1, // Raw-Text variable
	    name: 2, // SQL Name/Identifier
	    json: 4, // JSON modifier
	    csv: 8, // CSV modifier
	    value: 16 // escaped, but without ''
	};

	// Format Modification Map;
	var fmMap = {
	    '^': fmFlags.raw,
	    ':raw': fmFlags.raw,
	    '~': fmFlags.name,
	    ':name': fmFlags.name,
	    ':json': fmFlags.json,
	    ':csv': fmFlags.csv,
	    ':value': fmFlags.value,
	    '#': fmFlags.value
	};

	////////////////////////////////////////////////////
	// Converts a single value into its Postgres format.
	function formatValue(value, fm, obj) {

	    if (value instanceof Function) {
	        return formatValue(resolveFunc(value, obj), fm, obj);
	    }

	    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	        var ctf = value['formatDBType']; // custom type formatting;
	        if (ctf instanceof Function) {
	            fm |= value._rawDBType ? fmFlags.raw : 0;
	            return formatValue(resolveFunc(ctf, value), fm, obj);
	        }
	    }

	    var isRaw = !!(fm & fmFlags.raw);
	    fm &= ~fmFlags.raw;

	    switch (fm) {
	        case fmFlags.name:
	            return $as.name(value);
	        case fmFlags.json:
	            return $as.json(value, isRaw);
	        case fmFlags.csv:
	            return $as.csv(value);
	        case fmFlags.value:
	            return $as.value(value);
	        default:
	            break;
	    }

	    if (isNull(value)) {
	        throwIfRaw(isRaw);
	        return 'null';
	    }

	    switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
	        case 'string':
	            return $as.text(value, isRaw);
	        case 'boolean':
	            return $as.bool(value);
	        case 'number':
	            return $as.number(value);
	        default:
	            if (value instanceof Date) {
	                return $as.date(value, isRaw);
	            }
	            if (value instanceof Array) {
	                return $as.array(value);
	            }
	            if (value instanceof Buffer) {
	                return $as.buffer(value, isRaw);
	            }
	            return $as.json(value, isRaw);
	    }
	}

	//////////////////////////////////////////////////////////////////////////
	// Converts array of values into PostgreSQL Array Constructor: array[...],
	// as per PostgreSQL documentation: http://www.postgresql.org/docs/9.4/static/arrays.html
	// Arrays of any depth/dimension are supported.
	function formatArray(array) {
	    function loop(a) {
	        return '[' + $arr.map(a, function (v) {
	            return v instanceof Array ? loop(v) : formatValue(v);
	        }).join() + ']';
	    }

	    return 'array' + loop(array);
	}

	///////////////////////////////////////////////////////////////
	// Formats array of javascript-type parameters as a csv string,
	// so it can be passed into a PostgreSQL function.
	// Both single value and array or values are supported.
	function formatCSV(values) {
	    if (values instanceof Array) {
	        return $arr.map(values, function (v) {
	            return formatValue(v);
	        }).join();
	    }
	    return values === undefined ? '' : formatValue(values);
	}

	///////////////////////////////
	// Query formatting helpers;
	var formatAs = {

	    object: function object(query, obj, raw, options) {
	        options = options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options : {};
	        var pattern = /\$(?:({)|(\()|(<)|(\[)|(\/))\s*[a-zA-Z0-9\$_]+(\^|~|#|:raw|:name|:json|:csv|:value)?\s*(?:(?=\2)(?=\3)(?=\4)(?=\5)}|(?=\1)(?=\3)(?=\4)(?=\5)\)|(?=\1)(?=\2)(?=\4)(?=\5)>|(?=\1)(?=\2)(?=\3)(?=\5)]|(?=\1)(?=\2)(?=\3)(?=\4)\/)/g;
	        return query.replace(pattern, function (name) {
	            var v = formatAs.stripName(name.replace(/^\$[{(<[/]|[\s})>\]/]/g, ''), raw);
	            if (v.name in obj) {
	                return formatValue(obj[v.name], v.fm, obj);
	            }
	            if (v.name === 'this') {
	                return formatValue(obj, v.fm);
	            }
	            if ('default' in options) {
	                var d = options.default,
	                    value = d instanceof Function ? d.call(obj, v.name, obj) : d;
	                return formatValue(value, v.fm, obj);
	            }
	            if (options.partial) {
	                return name;
	            }
	            // property must exist as the object's own or inherited;
	            throw new Error("Property '" + v.name + "' doesn't exist.");
	        });
	    },

	    array: function array(query, _array, raw, options) {
	        options = options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options : {};
	        return query.replace(/\$([1-9][0-9]{0,3}(?![0-9])(\^|~|#|:raw|:name|:json|:csv|:value)?)/g, function (name) {
	            var v = formatAs.stripName(name.substr(1), raw);
	            var idx = v.name - 1;
	            if (idx < _array.length) {
	                return formatValue(_array[idx], v.fm);
	            }
	            if ('default' in options) {
	                var d = options.default,
	                    value = d instanceof Function ? d.call(_array, idx, _array) : d;
	                return formatValue(value, v.fm);
	            }
	            if (options.partial) {
	                return name;
	            }
	            throw new RangeError("Variable $" + v.name + " out of range. Parameters array length: " + _array.length);
	        });
	    },

	    value: function value(query, _value, raw) {
	        return query.replace(/\$1(?![0-9])(\^|~|#|:raw|:name|:json|:csv|:value)?/g, function (name) {
	            var v = formatAs.stripName(name, raw);
	            return formatValue(_value, v.fm);
	        });
	    },

	    stripName: function stripName(name, raw) {
	        var mod = name.match(/\^|~|#|:raw|:name|:json|:csv|:value/);
	        if (mod) {
	            return {
	                name: name.substr(0, mod.index),
	                fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)
	            };
	        } else {
	            return {
	                name: name,
	                fm: raw ? fmFlags.raw : null
	            };
	        }
	    }
	};

	////////////////////////////////////////////
	// Simpler check for null/undefined;
	function isNull(value) {
	    return value === undefined || value === null;
	}

	/////////////////////////////////////////
	// Wraps a text string in single quotes;
	function TEXT(text) {
	    return "'" + text + "'";
	}

	////////////////////////////////////////////////
	// Replaces each single-quote symbol ' with two,
	// for compliance with PostgreSQL strings.
	function safeText(text) {
	    return text.replace(/'/g, "''");
	}

	/////////////////////////////////////////////
	// Throws an exception, if flag 'raw' is set.
	function throwIfRaw(raw) {
	    if (raw) {
	        throw new TypeError("Values null/undefined cannot be used as raw text.");
	    }
	}

	////////////////////////////////////////////
	// Recursively resolves parameter-function,
	// with the optional calling context.
	function resolveFunc(value, obj) {
	    while (value instanceof Function) {
	        value = obj ? value.call(obj) : value();
	    }
	    return value;
	}

	///////////////////////////////////////////////////////////////////////////////////
	// 'pg-promise' query formatting solution;
	//
	// It implements two types of formatting, depending on the 'values' passed:
	//
	// 1. format "$1, $2, etc", when 'values' is of type string, boolean, number, date,
	//    function or null (or an array of the same types, plus undefined values);
	// 2. format $*propName*, when 'values' is an object (not null and not Date),
	//    and where * is any of the supported open-close pairs: {}, (), [], <>, //
	//
	// NOTES:
	// 1. Raw-text values can be injected using syntax: $1^,$2^,... or $*propName^*
	// 2. If 'values' is an object that supports function formatDBType, either its
	//    own or inherited, the actual value and the formatting syntax are determined
	//    by the result returned from that function.
	//
	// When formatting fails, the function throws an error.
	function $formatQuery(query, values, raw, options) {
	    if (typeof query !== 'string') {
	        throw new TypeError("Parameter 'query' must be a text string.");
	    }
	    if (values && (typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
	        var ctf = values['formatDBType']; // custom type formatting;
	        if (ctf instanceof Function) {
	            return $formatQuery(query, resolveFunc(ctf, values), raw || values._rawDBType, options);
	        }
	        if (values instanceof Array) {
	            // $1, $2,... formatting to be applied;
	            return formatAs.array(query, values, raw, options);
	        }
	        if (!(values instanceof Date || values instanceof Buffer)) {
	            // $*propName* formatting to be applied;
	            return formatAs.object(query, values, raw, options);
	        }
	    }
	    // $1 formatting to be applied, if values != undefined;
	    return values === undefined ? query : formatAs.value(query, values, raw);
	}

	//////////////////////////////////////////////////////
	// Formats a standard PostgreSQL function call query;
	function $formatFunction(funcName, values, capSQL) {
	    var sql = capSQL ? 'SELECT * FROM ' : 'select * from ';
	    return sql + funcName + '(' + formatCSV(values) + ')';
	}

	/**
	 * @namespace formatting
	 * @description
	 * Namespace for all query-formatting functions, available from `pgp.as`, before and after initializing the library.
	 *
	 * @property {function} name
	 * {@link formatting.name name} - formats an SQL name.
	 *
	 * @property {function} text
	 * {@link formatting.text text} - formats a text string.
	 *
	 * @property {function} number
	 * {@link formatting.number number} - formats a number.
	 *
	 * @property {function} buffer
	 * {@link formatting.buffer buffer} - formats a `Buffer` object.
	 *
	 * @property {function} value
	 * {@link formatting.value value} - formats text as an open value.
	 *
	 * @property {function} json
	 * {@link formatting.json json} - formats any value as JSON.
	 *
	 * @property {function} func
	 * {@link formatting.func func} - formats the value returned from a function.
	 *
	 * @property {function} format
	 * {@link formatting.format format} - formats a query according to parameters.
	 *
	 */
	var $as = {

	    /**
	     * @method formatting.text
	     * @description
	     * Converts a value into PostgreSQL text presentation, escaped as required.
	     *
	     * Escaping the result means:
	     *  1. Every single-quote (apostrophe) is replaced with two
	     *  2. The resulting text is wrapped in apostrophes
	     *
	     * @param {value|function} value
	     * Value to be converted, or a function that returns the value.
	     *
	     * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,
	     * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`
	     *
	     * @param {boolean} [raw=false]
	     * Indicates when not to escape the resulting text.
	     *
	     * @returns {string}
	     *
	     * - `null` string, if the `value` resolves as `null` or `undefined`
	     * - escaped result of `value.toString()`, if the `value` isn't a string
	     * - escaped string version, if `value` is a string.
	     *
	     *  The result is not escaped, if `raw` was passed in as `true`.
	     */
	    text: function text(value, raw) {
	        value = resolveFunc(value);
	        if (isNull(value)) {
	            throwIfRaw(raw);
	            return 'null';
	        }
	        if (typeof value !== 'string') {
	            value = value.toString();
	        }
	        return raw ? value : TEXT(safeText(value));
	    },

	    /**
	     * @method formatting.name
	     * @description
	     * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.
	     *
	     * Implements a safe way to format SQL Names that neutralizes SQL Injection.
	     *
	     * **Added in v.4.7.7:**
	     *
	     * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is.
	     *
	     * @param {String|function} name
	     * SQL name or identifier, or a function that returns it.
	     *
	     * The name must be at least 1 character long.
	     *
	     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `An sql name/identifier must be a non-empty text string.`
	     *
	     * @returns {string}
	     * The SQL Name/Identifier properly escaped for compliance with the PostgreSQL standard for SQL names and identifiers.
	     */
	    name: function name(_name) {
	        _name = resolveFunc(_name);
	        if (typeof _name !== 'string' || !_name.length) {
	            throw new TypeError("An sql name/identifier must be a non-empty text string.");
	        }
	        return (/^\s*\*(\s*)$/.test(_name) ? _name : '"' + _name.replace(/"/g, '""') + '"'
	        );
	    },

	    /**
	     * @method formatting.value
	     * @description
	     * Represents an open value, one to be formatted according to its type, properly escaped,
	     * but without surrounding quotes for text types.
	     *
	     * @param {value|function} value
	     * Value to be converted, or a function that returns the value.
	     *
	     * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`
	     *
	     * @returns {string}
	     * Formatted and properly escaped string, but without surrounding quotes for text types.
	     */
	    value: function value(_value2) {
	        _value2 = resolveFunc(_value2);
	        if (isNull(_value2)) {
	            throw new TypeError("Open values cannot be null or undefined.");
	        }
	        return safeText(formatValue(_value2, fmFlags.raw));
	    },

	    /**
	     * @method formatting.buffer
	     * @description
	     * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.
	     *
	     * @param {Buffer|function} obj
	     * Object to be converted, or a function that returns one.
	     *
	     * @param {boolean} [raw=false]
	     * Indicates when not to wrap the resulting string in quotes.
	     *
	     * The generated hex string doesn't need to be escaped.
	     *
	     * @returns {string}
	     */
	    buffer: function buffer(obj, raw) {
	        obj = resolveFunc(obj);
	        if (isNull(obj)) {
	            throwIfRaw(raw);
	            return 'null';
	        }
	        if (obj instanceof Buffer) {
	            var s = "\\x" + obj.toString("hex");
	            return raw ? s : TEXT(s);
	        }
	        throw new TypeError(TEXT(obj) + " is not a Buffer object.");
	    },

	    /**
	     * @method formatting.bool
	     * @description
	     * Converts a truthy value into PostgreSQL boolean presentation.
	     *
	     * @param {boolean|function} value
	     * Value to be converted, or a function that returns the value.
	     *
	     * @returns {string}
	     */
	    bool: function bool(value) {
	        value = resolveFunc(value);
	        if (isNull(value)) {
	            return 'null';
	        }
	        return value ? 'true' : 'false';
	    },

	    /**
	     * @method formatting.date
	     * @description
	     * Converts a `Date`-type value into PostgreSQL date/time presentation,
	     * as a UTC string, wrapped in quotes (unless flag `raw` is set).
	     *
	     * @param {date|function} d
	     * Date object to be converted, or a function that returns one.
	     *
	     * @param {boolean} [raw=false]
	     * Indicates when not to escape the value.
	     *
	     * @returns {string}
	     */
	    date: function date(d, raw) {
	        d = resolveFunc(d);
	        if (isNull(d)) {
	            throwIfRaw(raw);
	            return 'null';
	        }
	        if (d instanceof Date) {
	            // UTC date string is what PostgreSQL understands automatically;
	            var s = d.toUTCString();
	            // NOTE: Many languages use apostrophes in month names;
	            return raw ? s : TEXT(safeText(s));
	        }
	        throw new TypeError(TEXT(d) + " is not a Date object.");
	    },

	    /**
	     * @method formatting.number
	     * @description
	     * Converts a numeric value into its PostgreSQL number presentation,
	     * with support for `NaN`, `+Infinity` and `-Infinity`.
	     *
	     * @param {number|function} num
	     * Number to be converted, or a function that returns one.
	     *
	     * @returns {string}
	     */
	    number: function number(num) {
	        num = resolveFunc(num);
	        if (isNull(num)) {
	            return 'null';
	        }
	        if (typeof num !== 'number') {
	            throw new TypeError(TEXT(num) + " is not a number.");
	        }
	        if (isFinite(num)) {
	            return num.toString();
	        }
	        // Converting NaN/+Infinity/-Infinity according to Postgres documentation:
	        // http://www.postgresql.org/docs/9.4/static/datatype-numeric.html#DATATYPE-FLOAT
	        //
	        // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.
	        if (num === Number.POSITIVE_INFINITY) {
	            return TEXT("+Infinity");
	        }
	        if (num === Number.NEGATIVE_INFINITY) {
	            return TEXT("-Infinity");
	        }
	        return TEXT("NaN");
	    },

	    /**
	     * @method formatting.array
	     * @description
	     * Converts an array of values into its PostgreSQL presentation as an Array-Type
	     * constructor string: `array[]`.
	     *
	     * @param {array|function} arr
	     * Array to be converted, or a function that returns one.
	     *
	     * @returns {string}
	     */
	    array: function array(arr) {
	        arr = resolveFunc(arr);
	        if (isNull(arr)) {
	            return 'null';
	        }
	        if (arr instanceof Array) {
	            return formatArray(arr);
	        }
	        throw new TypeError(TEXT(arr) + " is not an Array object.");
	    },

	    /**
	     * @method formatting.csv
	     * @description
	     * Converts a single value or an array of values into a CSV string, with all values formatted
	     * according to their type.
	     *
	     * @param {array|value|function} values
	     * Value(s) to be converted, or a function that returns it.
	     *
	     * @returns {string}
	     */
	    csv: function csv(values) {
	        return formatCSV(resolveFunc(values));
	    },

	    /**
	     * @method formatting.json
	     * @description
	     * Converts any value into JSON (using `JSON.stringify`), and returns it as
	     * a valid string, with single-quote symbols fixed, unless flag `raw` is set.
	     *
	     * @param {object|function} obj
	     * Object/Value to be converted, or a function that returns it.
	     *
	     * @param {boolean} [raw=false]
	     * Indicates when not to escape the result.
	     *
	     * @returns {string}
	     */
	    json: function json(obj, raw) {
	        obj = resolveFunc(obj);
	        if (isNull(obj)) {
	            throwIfRaw(raw);
	            return 'null';
	        }
	        var s = JSON.stringify(obj);
	        return raw ? s : TEXT(safeText(s));
	    },

	    /**
	     * @method formatting.func
	     * @description
	     * Calls the function to get the actual value, and then formats the result
	     * according to its type + `raw` flag.
	     *
	     * @param {function} func
	     * Function to be called, with support for nesting.
	     *
	     * @param {boolean} [raw=false]
	     * Indicates when not to escape the result.
	     *
	     * @param {object} [obj]
	     * `this` context to be passed into the function on all nested levels.
	     *
	     * @returns {string}
	     */
	    func: function func(_func, raw, obj) {
	        if (isNull(_func)) {
	            throwIfRaw(raw);
	            return 'null';
	        }
	        if (typeof _func !== 'function') {
	            throw new TypeError(TEXT(_func) + " is not a function.");
	        }
	        var fm = raw ? fmFlags.raw : null;
	        if (isNull(obj)) {
	            return formatValue(resolveFunc(_func), fm);
	        }
	        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	            return formatValue(resolveFunc(_func, obj), fm, obj);
	        }
	        throw new TypeError(TEXT(obj) + " is not an object.");
	    },

	    /**
	     * @method formatting.format
	     * @description
	     * Replaces variables in a string according to the type of `values`:
	     *
	     * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `Date`, `Buffer` or when it is `null`.
	     * - Replaces variables `$1`, `$2`, ...`$9999` when `values` is an array of parameters. When a variable is out of range,
	     *   it throws {@link external:RangeError RangeError} = `Variable $n out of range. Parameters array length: x`, unless
	     *   option `partial` is used.
	     * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object
	     *   that's not a `Date`, `Buffer` or `null`. Special property name `this` refers to the formatting object itself,
	     *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws
	     *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.
	     *
	     * By default, each variable is automatically formatted according to its type, unless it is a special variable:
	     * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not
	     *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`
	     *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)
	     *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)
	     * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are
	     *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`
	     *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)
	     *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)
	     * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:
	     *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)
	     *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)
	     * - JSON override ends with `:json` to format the value of any type as a JSON string
	     * - CSV override ends with `:csv` to format an array as a properly escaped comma-separated list of values.
	     *
	     * @param {string} query
	     * Query string with formatting variables in it.
	     *
	     * @param {array|object|value} [values]
	     * Formatting parameter(s) / variable value(s).
	     *
	     * @param {object} [options]
	     * Formatting Options.
	     *
	     * @param {boolean} [options.partial=false]
	     * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or
	     * property name that's missing within the formatting parameters.
	     *
	     * This option has no meaning when option `default` is present.
	     *
	     * @param {} [options.default]
	     * **Added in v.5.0.5**
	     *
	     * Sets a default value for every variable that's missing, consequently preventing errors when encountering a variable
	     * or property name that's missing within the formatting parameters.
	     *
	     * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,
	     * and to return the actual default value:
	     *
	     * - Named Parameters formatting:
	     *   - `name` - name of the property missing in the formatting object
	     *   - `obj` - the formatting object, and is the same as `this` context
	     *
	     * - Regular variable formatting:
	     *   - `index` - element's index that's outside of the formatting array's range
	     *   - `arr` - the formatting array, and is the same as `this` context
	     *
	     * @returns {string}
	     * Formatted query string.
	     *
	     */
	    format: function format(query, values, options) {
	        return $formatQuery(query, values, false, options);
	    }
	};

	Object.freeze($as);

	module.exports = {
	    formatQuery: $formatQuery,
	    formatFunction: $formatFunction,
	    as: $as
	};

	/**
	 * @external Error
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
	 */

	/**
	 * @external TypeError
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError
	 */

	/**
	 * @external RangeError
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError
	 */
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    insert: __webpack_require__(498),
	    update: __webpack_require__(503),
	    values: __webpack_require__(504),
	    sets: __webpack_require__(505),
	    TableName: __webpack_require__(499),
	    ColumnSet: __webpack_require__(501),
	    Column: __webpack_require__(502)
	};

	/**
	 * @namespace helpers
	 * @description
	 * **Added in v.4.1.0**
	 * 
	 * Namespace for query-formatting generators, available as `pgp.helpers`, after initializing the library.
	 *
	 * It is a set of types and methods for generating queries in a fast, flexible and reliable way.
	 *
	 * See also: $[Performance Boost].
	 *
	 * @property {function} TableName
	 * {@link helpers.TableName TableName} class constructor.
	 *
	 * @property {function} ColumnSet
	 * {@link helpers.ColumnSet ColumnSet} class constructor.
	 *
	 * @property {function} Column
	 * {@link helpers.Column Column} class constructor.
	 *
	 * @property {function} insert
	 * {@link helpers.insert insert} static method.
	 *
	 * @property {function} update
	 * {@link helpers.update update} static method.
	 *
	 * @property {function} values
	 * {@link helpers.values values} static method.
	 *
	 * @property {function} sets
	 * {@link helpers.sets sets} static method.
	 */
	module.exports = function (config) {
	    var res = {
	        insert: function insert(data, columns, table) {
	            var capSQL = config.options && config.options.capSQL;
	            return $npm.insert(data, columns, table, capSQL);
	        },
	        update: function update(data, columns, table, options) {
	            var capSQL = config.options && config.options.capSQL;
	            return $npm.update(data, columns, table, options, capSQL);
	        },
	        values: $npm.values,
	        sets: $npm.sets,
	        TableName: $npm.TableName,
	        ColumnSet: $npm.ColumnSet,
	        Column: $npm.Column
	    };
	    Object.freeze(res);
	    return res;
	};

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    TableName: __webpack_require__(499),
	    ColumnSet: __webpack_require__(501),
	    formatting: __webpack_require__(496),
	    utils: __webpack_require__(500)
	};

	var $arr = __webpack_require__(492);

	/**
	 * @method helpers.insert
	 * @description
	 * Generates an `INSERT` query for either one object or an array of objects.
	 *
	 * @param {object|object[]} data
	 * An insert object with properties for insert values, or an array of such objects.
	 *
	 * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`
	 *
	 * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an INSERT from an empty array.`
	 *
	 * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =
	 * `Invalid insert object at index N.`
	 *
	 * @param {array|helpers.Column|helpers.ColumnSet} [columns]
	 * Set of columns to be inserted.
	 *
	 * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array
	 * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when inserting multiple records.`
	 *
	 * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}
	 * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).
	 *
	 * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw
	 * {@link external:Error Error} = `Cannot generate an INSERT without any columns.`
	 *
	 * @param {helpers.TableName|string|{table,schema}} [table]
	 * Destination table.
	 *
	 * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object
	 * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method
	 * will throw {@link external:Error Error} = `Table name is unknown.`
	 *
	 * @returns {string}
	 * The resulting query string.
	 *
	 * @see
	 *  {@link helpers.Column Column},
	 *  {@link helpers.ColumnSet ColumnSet},
	 *  {@link helpers.TableName TableName}
	 *
	 * @example
	 *
	 * var pgp = require('pg-promise')({
	 *    capSQL: true // if you want all generated SQL capitalized
	 * });
	 *
	 * var dataSingle = {val: 123, msg: 'hello'};
	 * var dataMulti = [{val: 123, msg: 'hello'}, {val: 456, msg: 'world!'}];
	 *
	 * // Column details can be taken from the data object:
	 *
	 * pgp.helpers.insert(dataSingle, null, 'my-table');
	 * //=> INSERT INTO "my-table"("val","msg") VALUES(123,'hello')
	 *
	 * @example
	 *
	 * // Column details are required for a multi-row `INSERT`:
	 *
	 * pgp.helpers.insert(dataMulti, ['val', 'msg'], 'my-table');
	 * //=> INSERT INTO "my-table"("val","msg") VALUES(123,'hello'),(456,'world!')
	 *
	 * @example
	 *
	 * // Column details from a reusable ColumnSet (recommended for performance):
	 *
	 * var cs = new pgp.helpers.ColumnSet(['val', 'msg'], {table: 'my-table'});
	 *
	 * pgp.helpers.insert(dataMulti, cs);
	 * //=> INSERT INTO "my-table"("val","msg") VALUES(123,'hello'),(456,'world!')
	 *
	 */
	function insert(data, columns, table, capSQL) {

	    if (!data || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
	        throw new TypeError("Invalid parameter 'data' specified.");
	    }

	    var isArray = Array.isArray(data);

	    if (isArray && !data.length) {
	        throw new TypeError("Cannot generate an INSERT from an empty array.");
	    }

	    if (columns instanceof $npm.ColumnSet) {
	        if ($npm.utils.isNull(table)) {
	            table = columns.table;
	        }
	    } else {
	        if (isArray && $npm.utils.isNull(columns)) {
	            throw new TypeError("Parameter 'columns' is required when inserting multiple records.");
	        }
	        columns = new $npm.ColumnSet(columns || data);
	    }

	    if (!columns.columns.length) {
	        throw new Error("Cannot generate an INSERT without any columns.");
	    }

	    if (!table) {
	        throw new Error("Table name is unknown.");
	    }

	    if (!(table instanceof $npm.TableName)) {
	        table = new $npm.TableName(table);
	    }

	    var query = capSQL ? sql.capCase : sql.lowCase;

	    var format = $npm.formatting.as.format;
	    query = format(query, table.name + columns.names);

	    if (isArray) {
	        return query + $arr.map(data, function (d, index) {
	            if (!d || (typeof d === 'undefined' ? 'undefined' : _typeof(d)) !== 'object') {
	                throw new Error("Invalid insert object at index " + index + ".");
	            }
	            return '(' + format(columns.castVariables, columns.prepare(d)) + ')';
	        }).join();
	    }
	    return query + '(' + format(columns.castVariables, columns.prepare(data)) + ')';
	}

	var sql = {
	    lowCase: "insert into $1^ values",
	    capCase: "INSERT INTO $1^ VALUES"
	};

	module.exports = insert;

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    utils: __webpack_require__(500),
	    formatting: __webpack_require__(496)
	};

	/**
	 * @class helpers.TableName
	 * @description
	 *
	 * **Alternative Syntax:** `TableName({table, [schema]})` &#8658; {@link helpers.TableName}
	 *
	 * Prepares and escapes a full table name that can be injected into queries directly.
	 *
	 * This is a read-only type that can be used wherever parameter `table` is supported.
	 *
	 * **Added in v.4.7.4:**
	 *
	 * Support for $[Custom Type Formatting], i.e. you can use the type directly as a formatting parameter,
	 * without specifying any escaping.
	 *
	 * @param {String|Object} table
	 * Table name details, depending on the type:
	 *
	 * - table name, if `table` is a string
	 * - object `{table, [schema]}`
	 *
	 * @param {string} [schema]
	 * Database schema name.
	 *
	 * When `table` is passed in as `{table, [schema]}`, this parameter is ignored.
	 *
	 * @property {string} name
	 * Formatted/escaped full table name, based on properties `schema` + `table`.
	 *
	 * @property {string} table
	 * Table name.
	 *
	 * @property {string} schema
	 * Database schema name.
	 *
	 * It is `undefined` when no schema was specified (or if it was an empty string).
	 *
	 * @returns {helpers.TableName}
	 *
	 * @example
	 *
	 * var table = new pgp.helpers.TableName('my-table', 'my-schema');
	 * console.log(table);
	 * //=> "my-schema"."my-table"
	 *
	 * // From v.4.7.4 we use the type directly:
	 * pgp.as.format("SELECT $1", table);
	 * //=> SELECT "my-schema"."my-table"
	 *
	 */
	function TableName(table, schema) {

	    if (!(this instanceof TableName)) {
	        return new TableName(table, schema);
	    }

	    if (table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && 'table' in table) {
	        schema = table.schema;
	        table = table.table;
	    }

	    if (!$npm.utils.isText(table)) {
	        throw new TypeError("Table name must be non-empty text string.");
	    }

	    if (!$npm.utils.isNull(schema)) {
	        if (typeof schema !== 'string') {
	            throw new TypeError("Invalid schema name.");
	        }
	        if (schema.length > 0) {
	            this.schema = schema;
	        }
	    }

	    this.table = table;
	    this.name = $npm.formatting.as.name(table);

	    if (this.schema) {
	        this.name = $npm.formatting.as.name(schema) + '.' + this.name;
	    }

	    this._rawDBType = true;

	    Object.freeze(this);
	}

	TableName.prototype.formatDBType = function () {
	    return this.name;
	};

	/**
	 * @method helpers.TableName.toString
	 * @description
	 * Creates a well-formatted string that represents the object.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @returns {string}
	 */
	TableName.prototype.toString = function () {
	    return this.name;
	};

	TableName.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = TableName;

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $path = __webpack_require__(230);

	////////////////////////////////////////////
	// Simpler check for null/undefined;
	function isNull(value) {
	    return value === null || value === undefined;
	}

	////////////////////////////////////////////////////////
	// Verifies parameter for being a non-empty text string;
	function isText(txt) {
	    return txt && typeof txt === 'string' && /\S/.test(txt);
	}

	//////////////////////////////////////
	// Verifies value for being an object,
	// based on type and property names.
	function isObject(value, properties) {
	    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	        for (var i = 0; i < properties.length; i++) {
	            if (!(properties[i] in value)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    return false;
	}

	///////////////////////////////////////////////////
	// Locks all properties in an object to read-only,
	// or freezes the entire object for any changes.
	function lock(obj, freeze, options) {
	    if (options && options.noLocking) {
	        return;
	    }
	    if (freeze) {
	        Object.freeze(obj); // freeze the entire object, permanently;
	    } else {
	        var desc = {
	            writable: false,
	            configurable: false,
	            enumerable: true
	        };
	        for (var p in obj) {
	            Object.defineProperty(obj, p, desc);
	        }
	    }
	}

	/////////////////////////////////////////////
	// Adds properties from source to the target,
	// making them read-only and enumerable.
	function addReadProperties(target, source) {
	    for (var p in source) {
	        addReadProp(target, p, source[p]);
	    }
	}

	///////////////////////////////////////////////////////
	// Adds a read-only, non-deletable enumerable property.
	function addReadProp(obj, name, value, hidden) {
	    Object.defineProperty(obj, name, {
	        value: value,
	        configurable: false,
	        enumerable: !hidden,
	        writable: false
	    });
	}

	//////////////////////////////////////////////////////////////
	// Converts a connection string or object into its safe copy:
	// if password is present, it is masked with symbol '#'.
	function getSafeConnection(cn) {
	    if ((typeof cn === 'undefined' ? 'undefined' : _typeof(cn)) === 'object') {
	        var copy = JSON.parse(JSON.stringify(cn));
	        if (typeof copy.password === 'string') {
	            copy.password = copy.password.replace(/./g, '#');
	        }
	        return copy;
	    }
	    // or else it is a connection string;
	    return cn.replace(/:(?![\/])([^@]+)/, function (_, m) {
	        return ':' + new Array(m.length + 1).join('#');
	    });
	}

	///////////////////////////////////////////
	// Returns a space gap for console output;
	function messageGap(level) {
	    return Array(1 + level * 4).join(' ');
	}

	/////////////////////////////////////////
	// Provides platform-neutral inheritance;
	function inherits(child, parent) {
	    child.prototype.__proto__ = parent.prototype;
	}

	///////////////////////////////////////////////////////////////////////////
	// Checks if the path is absolute;
	//
	// We exclude this from the coverage, because the code is platform-specific,
	// and while most of its code is for Windows, Travis CI is a linux platform.
	//
	// istanbul ignore next
	function isPathAbsolute(path) {
	    // Based on: https://github.com/sindresorhus/path-is-absolute
	    if (process.platform === 'win32') {
	        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	        var result = splitDeviceRe.exec(path);
	        var device = result[1] || '';
	        var isUnc = !!device && device.charAt(1) !== ':';
	        return !!result[2] || isUnc;
	    }
	    return path.charAt(0) === '/';
	}

	function getLocalStack(startIdx) {
	    // from the call stack, we take only lines starting with the client's
	    // source code, and only those that contain a full path inside brackets,
	    // indicating a reference to the client's source code:
	    return new Error().stack.split('\n').slice(startIdx).filter(function (line) {
	        return line.match(/\(.*(\\+|\/+).*\)/); // contains \ or / inside ()
	    }).join('\n');
	}

	//////////////////////////////
	// Internal error container;
	function InternalError(error) {
	    this.error = error;
	}

	var exp = {
	    InternalError: InternalError,
	    getLocalStack: getLocalStack,
	    isPathAbsolute: isPathAbsolute,
	    lock: lock,
	    isText: isText,
	    isNull: isNull,
	    isObject: isObject,
	    addReadProp: addReadProp,
	    addReadProperties: addReadProperties,
	    getSafeConnection: getSafeConnection,
	    messageGap: messageGap,
	    inherits: inherits
	};

	var mainFile = process.argv[1];

	// istanbul ignore next
	exp.startDir = mainFile ? $path.dirname(mainFile) : process.cwd();

	Object.freeze(exp);

	module.exports = exp;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    formatting: __webpack_require__(496),
	    TableName: __webpack_require__(499),
	    Column: __webpack_require__(502)
	};

	var $arr = __webpack_require__(492);

	/**
	 * @class helpers.ColumnSet
	 * @description
	 *
	 * Performance-optimized, read-only structure with query-formatting columns.
	 *
	 * For performance-oriented applications this type should be created globally, to be reused by all methods.
	 *
	 * @param {object|helpers.Column|array} columns
	 * Columns information object, depending on the type:
	 *
	 * - When it is a simple object, its properties are enumerated to represent both column names and property names
	 *   within the source objects. See also option `inherit` that's applicable in this case.
	 *
	 * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with
	 *   just a single column. It is not a unique situation when only a single column is required for an update operation.
	 *
	 * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},
	 *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.
	 *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name "name".`
	 *
	 * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`
	 *
	 * @param {object} [options]
	 *
	 * @param {helpers.TableName|string|{table,schema}} [options.table]
	 * Table details.
	 *
	 * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.
	 *
	 * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter
	 * `table` is omitted, and for logging purposes.
	 *
	 * @param {boolean} [options.inherit = false]
	 * Use inherited properties in addition to the object's own properties.
	 *
	 * By default, only the object's own properties are enumerated for column names.
	 *
	 * @returns {helpers.ColumnSet}
	 *
	 * @example
	 *
	 * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.
	 * // For a good performance, you should declare such objects once and then reuse them.
	 * //
	 * // Column Requirements:
	 * //
	 * // 1. Property 'id' is only to be used for a WHERE condition in updates
	 * // 2. Property 'list' needs to be formatted as a csv
	 * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the
	 * //    property is missing in the source object
	 * // 4. Property 'log' is a JSON object with 'log-entry' for the column name
	 * // 5. Property 'data' requires SQL type casting '::int[]'
	 * // 6. Property 'amount' needs to be set to 100, if it is 0
	 * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its
	 * //    column name is 'total-val'
	 *
	 * var cs = new pgp.helpers.ColumnSet([
	 *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}
	 *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}
	 *     {
	 *         name: 'code',
	 *         mod: '^', // format as raw text
	 *         def: 0 // default to 0 when the property doesn't exist
	 *     },
	 *     {
	 *         name: 'log-entry',
	 *         prop: 'log',
	 *         mod: ':json' // format as JSON
	 *     },
	 *     {
	 *         name: 'data',
	 *         cast: 'int[]' // use SQL type casting '::int[]'
	 *     },
	 *     {
	 *         name: 'amount',
	 *         init: function (value) {
	 *             // set to 100, if the value is 0:
	 *             return values === 0 ? 100 : value;
	 *         }
	 *     },
	 *     {
	 *         name: 'total-val',
	 *         prop: 'total',
	 *         skip: function (name) {
	 *             // skip from updates, if 'amount' is 0:
	 *             return (this.amount === 0);
	 *         }
	 *     }
	 * ], {table: {table: 'purchases', schema: 'fiscal'}});
	 *
	 * // Alternatively, you could take the table declaration out:
	 * // var table = new pgp.helpers.TableName('purchases', 'fiscal');
	 *
	 * console.log(cs); // console output for the object:
	 * //=>
	 * // ColumnSet {
	 * //    table: "fiscal"."purchases"
	 * //    columns: [
	 * //        Column {
	 * //            name: "id"
	 * //            cnd: true
	 * //        }
	 * //        Column {
	 * //            name: "list"
	 * //            mod: ":csv"
	 * //        }
	 * //        Column {
	 * //            name: "code"
	 * //            mod: "^"
	 * //            def: 0
	 * //        }
	 * //        Column {
	 * //            name: "log-entry"
	 * //            prop: "log"
	 * //            mod: ":json"
	 * //        }
	 * //        Column {
	 * //            name: "data"
	 * //            cast: "int[]"
	 * //        }
	 * //        Column {
	 * //            name: "amount"
	 * //            init: [Function]
	 * //        }
	 * //        Column {
	 * //            name: "total-val"
	 * //            prop: "total"
	 * //            skip: [Function]
	 * //        }
	 * //    ]
	 * // }
	 */
	function ColumnSet(columns, options) {

	    if (!(this instanceof ColumnSet)) {
	        return new ColumnSet(columns, options);
	    }

	    if (!columns || (typeof columns === 'undefined' ? 'undefined' : _typeof(columns)) !== 'object') {
	        throw new TypeError("Invalid parameter 'columns' specified.");
	    }

	    var inherit,
	        names,
	        variables,
	        castVariables,
	        updates,
	        canSetMany,
	        isSimple = true;

	    if (!$npm.utils.isNull(options)) {
	        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
	            throw new TypeError("Invalid parameter 'options' specified.");
	        }
	        if (!$npm.utils.isNull(options.table)) {
	            if (options.table instanceof $npm.TableName) {
	                this.table = options.table;
	            } else {
	                this.table = new $npm.TableName(options.table);
	            }
	        }
	        inherit = options.inherit;
	    }

	    /**
	     * @name helpers.ColumnSet#table
	     * @type {helpers.TableName}
	     * @readonly
	     * @description
	     * Destination table. It can be specified for two purposes:
	     *
	     * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}
	     * - **secondary:** to be automatically written into the console (for logging purposes).
	     */

	    /**
	     * @name helpers.ColumnSet#columns
	     * @type helpers.Column[]
	     * @readonly
	     * @description
	     * Array of {@link helpers.Column Column} objects.
	     */
	    if (Array.isArray(columns)) {
	        var colNames = {};
	        this.columns = $arr.map(columns, function (c) {
	            var col = c instanceof $npm.Column ? c : new $npm.Column(c);
	            if (col.name in colNames) {
	                throw new Error('Duplicate column name "' + col.name + '".');
	            }
	            colNames[col.name] = true;
	            return col;
	        });
	    } else {
	        if (columns instanceof $npm.Column) {
	            this.columns = [columns];
	        } else {
	            this.columns = [];
	            for (var name in columns) {
	                if (inherit || columns.hasOwnProperty(name)) {
	                    this.columns.push(new $npm.Column(name));
	                }
	            }
	        }
	    }

	    Object.freeze(this.columns);

	    // ColumnSet is simple when the source objects require no preparation,
	    // and should be used directly:
	    for (var i = 0; i < this.columns.length; i++) {
	        var c = this.columns[i];
	        if (c.prop || c.init || 'def' in c) {
	            isSimple = false;
	            break;
	        }
	    }

	    /**
	     * @name helpers.ColumnSet#names
	     * @private
	     * @type String
	     * @readonly
	     * @description
	     * A string that contains a comma-separated list of escaped column names, wrapped in `()`.
	     */
	    Object.defineProperty(this, 'names', {
	        get: function get() {
	            if (!names) {
	                names = $arr.map(this.columns, function (c) {
	                    return c.escapedName;
	                }).join();
	                if (names) {
	                    names = '(' + names + ')';
	                }
	            }
	            return names;
	        }
	    });

	    /**
	     * @name helpers.ColumnSet#variables
	     * @private
	     * @type String
	     * @readonly
	     * @description
	     * A string that contains a comma-separated list of all variables.
	     */
	    Object.defineProperty(this, 'variables', {
	        get: function get() {
	            if (!variables) {
	                variables = $arr.map(this.columns, function (c) {
	                    return c.variable;
	                }).join();
	            }
	            return variables;
	        }
	    });

	    /**
	     * @name helpers.ColumnSet#castVariables
	     * @private
	     * @type String
	     * @readonly
	     * @description
	     * A string that contains a comma-separated list of all variables with casting.
	     */
	    Object.defineProperty(this, 'castVariables', {
	        get: function get() {
	            if (!castVariables) {
	                castVariables = $arr.map(this.columns, function (c) {
	                    return c.variable + c.castText;
	                }).join();
	            }
	            return castVariables;
	        }
	    });

	    /**
	     * @method helpers.ColumnSet.getUpdates
	     * @private
	     * @readonly
	     * @description
	     * Returns the complete list of SET-s for a single object.
	     */
	    this.getUpdates = function (obj) {
	        if (updates) {
	            return updates;
	        }
	        var dynamic;
	        var list = $arr.filter(this.columns, function (c) {
	            if (c.cnd) {
	                return false;
	            }
	            if (c.skip) {
	                dynamic = true;
	                if (c.skip.call(obj, c.prop || c.name)) {
	                    return false;
	                }
	            }
	            return true;
	        });

	        list = $arr.map(list, function (c) {
	            return c.escapedName + '=' + c.variable + c.castText;
	        }).join();

	        if (!dynamic) {
	            updates = list;
	        }
	        return list;
	    };

	    /**
	     * @method helpers.ColumnSet.extend
	     * @description
	     * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.
	     *
	     * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.
	     *
	     * @param {helpers.Column|helpers.ColumnSet|array} columns
	     * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:
	     * - it can also be of type {@link helpers.ColumnSet ColumnSet}
	     * - it cannot be a simple object (properties enumeration is not supported here)
	     *
	     * @returns {helpers.ColumnSet}
	     * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.
	     *
	     * @see
	     * {@link helpers.Column Column},
	     * {@link helpers.ColumnSet.merge merge}
	     *
	     * @example
	     *
	     * var pgp = require('pg-promise')();
	     *
	     * var cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});
	     * console.log(cs);
	     * //=>
	     * // ColumnSet {
	     * //    table: "my-table"
	     * //    columns: [
	     * //        Column {
	     * //            name: "one"
	     * //        }
	     * //        Column {
	     * //            name: "two"
	     * //        }
	     * //    ]
	     * // }
	     * var csExtended = cs.extend(['three']);
	     * console.log(csExtended);
	     * //=>
	     * // ColumnSet {
	     * //    table: "my-table"
	     * //    columns: [
	     * //        Column {
	     * //            name: "one"
	     * //        }
	     * //        Column {
	     * //            name: "two"
	     * //        }
	     * //        Column {
	     * //            name: "three"
	     * //        }
	     * //    ]
	     * // }
	     */
	    this.extend = function (columns) {
	        var cs = columns;
	        if (!(cs instanceof ColumnSet)) {
	            cs = new ColumnSet(columns);
	        }
	        // Any duplicate column will throw Error = 'Duplicate column name "name".',
	        return new ColumnSet(this.columns.concat(cs.columns), { table: this.table });
	    };

	    /**
	     * @method helpers.ColumnSet.merge
	     * @description
	     * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.
	     *
	     * Items in `columns` with the same `name` (case-sensitive) override the original columns.
	     *
	     * @param {helpers.Column|helpers.ColumnSet|array} columns
	     * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:
	     * - it can also be of type {@link helpers.ColumnSet ColumnSet}
	     * - it cannot be a simple object (properties enumeration is not supported here)
	     *
	     * @see
	     * {@link helpers.Column Column},
	     * {@link helpers.ColumnSet.extend extend}
	     *
	     * @returns {helpers.ColumnSet}
	     * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.
	     *
	     * @example
	     *
	     * var pgp = require('pg-promise')();
	     *
	     * var cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});
	     * console.log(cs);
	     * //=>
	     * // ColumnSet {
	     * //    table: "my-table"
	     * //    columns: [
	     * //        Column {
	     * //            name: "one"
	     * //            cnd: true
	     * //        }
	     * //        Column {
	     * //            name: "two"
	     * //            mod: ":json"
	     * //        }
	     * //    ]
	     * // }
	     * var csMerged = cs.merge(['two', 'three^']);
	     * console.log(csMerged);
	     * //=>
	     * // ColumnSet {
	     * //    table: "my-table"
	     * //    columns: [
	     * //        Column {
	     * //            name: "one"
	     * //            cnd: true
	     * //        }
	     * //        Column {
	     * //            name: "two"
	     * //        }
	     * //        Column {
	     * //            name: "three"
	     * //            mod: "^"
	     * //        }
	     * //    ]
	     * // }
	     *
	     */
	    this.merge = function (columns) {
	        var cs = columns;
	        if (!(cs instanceof ColumnSet)) {
	            cs = new ColumnSet(columns);
	        }
	        var colNames = {},
	            cols = [];
	        $arr.forEach(this.columns, function (c, idx) {
	            cols.push(c);
	            colNames[c.name] = idx;
	        });
	        $arr.forEach(cs.columns, function (c) {
	            if (c.name in colNames) {
	                cols[colNames[c.name]] = c;
	            } else {
	                cols.push(c);
	            }
	        });
	        return new ColumnSet(cols, { table: this.table });
	    };

	    /**
	     * @method helpers.ColumnSet.canUpdate
	     * @description
	     * Checks if it is possible to generate an `UPDATE` query (via method {@link helpers.update update}) for the specified `data`
	     * and the current {@link helpers.ColumnSet ColumnSet}, without running into errors related to the shortage of effective
	     * update columns or the lack of data. It can also be used before calling method {@link helpers.sets sets}, to determine whether
	     * it is going to return an empty string, due to the shortage of effective columns.
	     *
	     * The result and the logic depend on whether `data` is a single object or an array, and it is consistent with the validation
	     * logic that's implemented by the {@link helpers.update update} method.
	     *
	     * This method is mainly valuable for those single-object updates that make use of property {@link helpers.Column Column.skip}, which
	     * makes the list of effective columns dynamic.
	     *
	     * @param {object|array} data
	     * Data intended for an `UPDATE` query - a single source object or an array of such objects.
	     *
	     * Passing in a non-object value will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`
	     *
	     * @returns {boolean}
	     *
	     * - `true` - this `ColumnSet` can generate a valid `UPDATE` query via method {@link helpers.update update} for the `data` specified
	     * - `false` - passing such `data` into method {@link helpers.update update} will inevitably throw an error, either because
	     *   there are no columns to be updated or there is no data (when `data` is an empty array).
	     */
	    this.canUpdate = function (data) {
	        if (!data || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
	            throw new TypeError("Invalid parameter 'data' specified.");
	        }
	        var cnd = 0,
	            skip = 0,
	            total = this.columns.length;
	        if (Array.isArray(data)) {
	            if (canSetMany === undefined) {
	                cnd = $arr.countIf(this.columns, function (c) {
	                    return c.cnd;
	                });
	                canSetMany = total > cnd;
	            }
	            return canSetMany && data.length > 0;
	        }
	        $arr.forEach(this.columns, function (c) {
	            cnd += c.cnd ? 1 : 0;
	            if (c.skip) {
	                skip += c.skip.call(data, c.prop || c.name) ? 1 : 0;
	            }
	        });
	        return total > cnd + skip;
	    };

	    /**
	     * @method helpers.ColumnSet.prepare
	     * @private
	     * @description
	     * Prepares a source object to be formatted, by cloning it and applying the rules
	     * as set by the columns configuration.
	     *
	     * This method is meant primarily for internal use.
	     *
	     * @param {object} obj
	     * Source object to be prepared.
	     *
	     * @returns {object}
	     * A clone of the source objects, with all properties and values set according to
	     * the columns configuration.
	     */
	    this.prepare = function (obj) {
	        if (isSimple) {
	            return obj; // a simple ColumnSet requires no object preparation;
	        }
	        var target = {};
	        $arr.forEach(this.columns, function (c) {
	            var name = c.prop || c.name;
	            if (name in obj) {
	                var value = obj[name];
	                target[name] = c.init ? c.init.call(obj, value) : value;
	            } else {
	                var value;
	                if ('def' in c) {
	                    target[name] = value = c.def;
	                }
	                if (c.init) {
	                    target[name] = c.init.call(obj, value);
	                }
	            }
	        });
	        return target;
	    };

	    Object.freeze(this);
	}

	/**
	 * @method helpers.ColumnSet.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the object.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	ColumnSet.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        lines = ['ColumnSet {'];
	    if (this.table) {
	        lines.push(gap1 + 'table: ' + this.table);
	    }
	    if (this.columns.length) {
	        lines.push(gap1 + 'columns: [');
	        $arr.forEach(this.columns, function (c) {
	            lines.push(c.toString(2));
	        });
	        lines.push(gap1 + ']');
	    } else {
	        lines.push(gap1 + 'columns: []');
	    }
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	ColumnSet.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = ColumnSet;

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    formatting: __webpack_require__(496)
	};

	/**
	 *
	 * @class helpers.Column
	 * @description
	 *
	 * It is a read-only structure that contains details for a single column, to be primarily used by {@link helpers.ColumnSet ColumnSet}.
	 *
	 * The class parses and validates all the details, and prepares them for high-performance query generation.
	 *
	 * @param {String|helpers.ColumnConfig} col
	 * Column details, depending on the type.
	 *
	 * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.
	 * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by
	 * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:json`, `name`, `raw`, `:value`), which is then removed from the name and put
	 * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.
	 *
	 * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.
	 *
	 * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties
	 * of the class.
	 *
	 * @property {string} name
	 * Column name + property name (if `prop` isn't specified).
	 *
	 * @property {string} [prop]
	 * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.
	 *
	 * It is ignored when it is the same as `name`.
	 *
	 * @property {string} [mod]
	 * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:json`, `name`, `raw`, `:value`.
	 *
	 * @property {string} [cast]
	 * Server-side type casting, without `::` in front.
	 *
	 * @property {boolean} [cnd]
	 * Conditional column flag.
	 *
	 * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and
	 * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.
	 *
	 * It can be set from a string initialization, by adding `?` in front of the name.
	 *
	 * @property {} [def]
	 * Default value for the property, to be used only when the source object doesn't have the property.
	 *
	 * @property {helpers.initCB} [init]
	 * Override callback for the value.
	 *
	 * @property {helpers.skipCB} [skip]
	 * An override for skipping columns dynamically.
	 *
	 * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods
	 * {@link helpers.insert insert} and {@link helpers.values values}.
	 *
	 * It is also ignored when conditional flag `cnd` is set.
	 *
	 * @returns {helpers.Column}
	 *
	 * @see {@link helpers.ColumnConfig ColumnConfig}
	 *
	 * @example
	 *
	 * var pgp = require('pg-promise')({
	 *     capSQL: true // if you want all generated SQL capitalized
	 * });
	 *
	 * var Column = pgp.helpers.Column;
	 *
	 * // creating a column from just a name:
	 * var col1 = new Column('colName');
	 * console.log(col1);
	 * //=>
	 * // Column {
	 * //    name: "colName"
	 * // }
	 *
	 * // creating a column from a name + modifier:
	 * var col2 = new Column('colName:csv');
	 * console.log(col2);
	 * //=>
	 * // Column {
	 * //    name: "colName"
	 * //    mod: ":csv"
	 * // }
	 *
	 * // creating a column from a configurator:
	 * var col3 = new Column({
	 *     name: 'colName', // required
	 *     prop: 'propName', // optional
	 *     mod: '^', // optional
	 *     def: 123 // optional
	 * });
	 * console.log(col3);
	 * //=>
	 * // Column {
	 * //    name: "colName"
	 * //    prop: "propName"
	 * //    mod: "^"
	 * //    def: 123
	 * // }
	 *
	 */
	function Column(col) {

	    if (!(this instanceof Column)) {
	        return new Column(col);
	    }

	    if (typeof col === 'string') {
	        var info = parseColumn(col);
	        this.name = info.name;
	        if ('mod' in info) {
	            this.mod = info.mod;
	        }
	        if ('cnd' in info) {
	            this.cnd = info.cnd;
	        }
	    } else {
	        if (col && (typeof col === 'undefined' ? 'undefined' : _typeof(col)) === 'object' && 'name' in col) {
	            if (!$npm.utils.isText(col.name)) {
	                throw new TypeError("Invalid 'name' value: " + JSON.stringify(col.name) + ". A non-empty string was expected.");
	            }
	            if ($npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {
	                throw new TypeError("Invalid 'name' syntax: " + JSON.stringify(col.name) + ". A valid variable name was expected.");
	            }
	            this.name = col.name; // column name + property name (if 'prop' isn't specified)

	            if (!$npm.utils.isNull(col.prop)) {
	                if (!$npm.utils.isText(col.prop)) {
	                    throw new TypeError("Invalid 'prop' value: " + JSON.stringify(col.prop) + ". A non-empty string was expected.");
	                }
	                if (!isValidVariable(col.prop)) {
	                    throw new TypeError("Invalid 'prop' syntax: " + JSON.stringify(col.prop) + ". A valid variable name was expected.");
	                }
	                if (col.prop !== col.name) {
	                    // optional property name, if different from the column's name;
	                    this.prop = col.prop;
	                }
	            }
	            if (!$npm.utils.isNull(col.mod)) {
	                if (typeof col.mod !== 'string' || !isValidMod(col.mod)) {
	                    throw new TypeError("Invalid 'mod' value: " + JSON.stringify(col.mod) + ".");
	                }
	                this.mod = col.mod; // optional format modifier;
	            }
	            if (!$npm.utils.isNull(col.cast)) {
	                this.cast = parseCast(col.cast); // optional SQL type casting
	            }
	            if ('cnd' in col) {
	                this.cnd = !!col.cnd;
	            }
	            if ('def' in col) {
	                this.def = col.def; // optional default
	            }
	            if (typeof col.init === 'function') {
	                this.init = col.init; // optional value override (overrides 'def' also)
	            }
	            if (typeof col.skip === 'function') {
	                this.skip = col.skip;
	            }
	        } else {
	            throw new TypeError("Invalid column details.");
	        }
	    }

	    var variable = '${' + (this.prop || this.name) + (this.mod || '') + '}',
	        castText = this.cast ? '::' + this.cast : '',
	        escapedName = $npm.formatting.as.name(this.name);

	    Object.defineProperty(this, 'variable', {
	        enumerable: false,
	        value: variable
	    });

	    Object.defineProperty(this, 'castText', {
	        enumerable: false,
	        value: castText
	    });

	    Object.defineProperty(this, 'escapedName', {
	        enumerable: false,
	        value: escapedName
	    });

	    Object.freeze(this);
	}

	function parseCast(name) {
	    if (typeof name === 'string') {
	        var idx = 0;
	        while (idx < name.length && name[idx] === ':') {
	            idx++;
	        }
	        name = idx ? name.substr(idx) : name;
	        if ($npm.utils.isText(name)) {
	            return name;
	        }
	    }
	    throw new TypeError("Invalid 'cast' value: " + JSON.stringify(name) + ".");
	}

	function parseColumn(name) {
	    var m = name.match(/\??[a-zA-Z0-9\$_]+(\^|~|#|:raw|:name|:json|:csv|:value)?/);
	    if (m && m[0] === name) {
	        var res = {};
	        if (name[0] === '?') {
	            res.cnd = true;
	            name = name.substr(1);
	        }
	        var mod = name.match(/\^|~|#|:raw|:name|:json|:csv|:value/);
	        if (mod) {
	            res.name = name.substr(0, mod.index);
	            res.mod = mod[0];
	        } else {
	            res.name = name;
	        }
	        return res;
	    }
	    throw new TypeError("Invalid column syntax: " + JSON.stringify(name) + ".");
	}

	function isValidMod(mod) {
	    var values = ['^', '~', '#', ':raw', ':name', ':json', ':csv', ':value'];
	    return values.indexOf(mod) !== -1;
	}

	function isValidVariable(name) {
	    var m = name.match(/[a-zA-Z0-9\$_]+/);
	    return m && m[0] === name;
	}

	/**
	 * @method helpers.Column.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the object.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	Column.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        lines = [gap0 + 'Column {', gap1 + 'name: ' + JSON.stringify(this.name)];
	    if ('prop' in this) {
	        lines.push(gap1 + 'prop: ' + JSON.stringify(this.prop));
	    }
	    if ('mod' in this) {
	        lines.push(gap1 + 'mod: ' + JSON.stringify(this.mod));
	    }
	    if ('cast' in this) {
	        lines.push(gap1 + 'cast: ' + JSON.stringify(this.cast));
	    }
	    if ('cnd' in this) {
	        lines.push(gap1 + 'cnd: ' + JSON.stringify(this.cnd));
	    }
	    if ('def' in this) {
	        lines.push(gap1 + 'def: ' + JSON.stringify(this.def));
	    }
	    if ('init' in this) {
	        lines.push(gap1 + 'init: [Function]');
	    }
	    if ('skip' in this) {
	        lines.push(gap1 + 'skip: [Function]');
	    }
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	Column.prototype.inspect = function () {
	    return this.toString();
	};

	/**
	 * @typedef helpers.ColumnConfig
	 * @description
	 * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.
	 *
	 * @property {string} name
	 * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,
	 * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any string.
	 *
	 * @property {string} [prop]
	 * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.
	 *
	 * @property {string} [mod]
	 * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:json`, `name`, `raw`, `:value`.
	 *
	 * @property {string} [cast]
	 * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).
	 *
	 * @property {boolean} [cnd]
	 *
	 * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and
	 * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.
	 *
	 * @property {} [def]
	 * Default value for the property, to be used only when the source object doesn't have the property.
	 *
	 * @property {helpers.initCB} [init]
	 * Override callback for the value.
	 *
	 * @property {helpers.skipCB} [skip]
	 * An override for skipping columns dynamically.
	 *
	 * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods
	 * {@link helpers.insert insert} and {@link helpers.values values}.
	 *
	 * It is also ignored when conditional flag `cnd` is set.
	 *
	 */

	/**
	 * @callback helpers.initCB
	 * @description
	 * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.
	 *
	 * It works as an override for the corresponding property value in the source object.
	 *
	 * The function is called with `this` set to the source object.
	 *
	 * @param {} value
	 * Value of the property within the source object.
	 *
	 * If the source object doesn't have the property, and `def` option was specified,
	 * then the `value` is set to the `def` value.
	 *
	 * @returns {}
	 * The new value to be used for the corresponding column.
	 */

	/**
	 * @callback helpers.skipCB
	 * @description
	 * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.
	 *
	 * It is to dynamically determine if the property is to be skipped from the update.
	 *
	 * The function is called with `this` set to the source object.
	 *
	 * @param {string} name
	 * Name of the property within the source object.
	 *
	 * It can be used when implementing a generic verification callback to skip columns bases on a certain rule.
	 *
	 * @returns {boolean}
	 * A truthy value that indicates whether the column is to be skipped.
	 *
	 */

	module.exports = Column;

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    TableName: __webpack_require__(499),
	    ColumnSet: __webpack_require__(501),
	    formatting: __webpack_require__(496),
	    utils: __webpack_require__(500)
	};

	var $arr = __webpack_require__(492);

	/**
	 * @method helpers.update
	 * @description
	 * Generates a simplified `UPDATE` query for either one object or an array of objects.
	 *
	 * The resulting query needs a `WHERE` clause to be appended to it, to determine the update logic.
	 * This is to allow for update conditions of any complexity that are easy to add.
	 *
	 * @param {object|object[]} data
	 * An update object with properties for update values, or an array of such objects.
	 *
	 * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`
	 *
	 * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`
	 *
	 * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =
	 * `Invalid update object at index N.`
	 *
	 * @param {array|helpers.Column|helpers.ColumnSet} [columns]
	 * Set of columns to be updated.
	 *
	 * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array
	 * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`
	 *
	 * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}
	 * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).
	 *
	 * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw
	 * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.` (see also {@link helpers.ColumnSet.canUpdate ColumnSet.canUpdate})
	 *
	 * @param {helpers.TableName|string|{table,schema}} [table]
	 * Table to be updated.
	 *
	 * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object
	 * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method
	 * will throw {@link external:Error Error} = `Table name is unknown.`
	 *
	 * @param {object} [options]
	 * An object with formatting options for multi-row `UPDATE` queries. Passing in a non-null value that's not an object will
	 * throw {@link external:TypeError TypeError} = `Invalid parameter 'options' specified.`
	 *
	 * @param {string} [options.tableAlias=t]
	 * Name of the SQL variable that represents the destination table.
	 *
	 * @param {string} [options.valueAlias=v]
	 * Name of the SQL variable that represents the values.
	 *
	 * @returns {string}
	 * The resulting query string that typically needs a `WHERE` condition appended.
	 *
	 * @see
	 *  {@link helpers.Column Column},
	 *  {@link helpers.ColumnSet ColumnSet},
	 *  {@link helpers.TableName TableName}
	 *
	 * @example
	 *
	 * var pgp = require('pg-promise')({
	 *    capSQL: true // if you want all generated SQL capitalized
	 * });
	 *
	 * var dataSingle = {id: 1, val: 123, msg: 'hello'};
	 * var dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];
	 *
	 * // Although column details can be taken from the data object, it is not
	 * // a likely scenario for an update, unless updating the whole table:
	 *
	 * pgp.helpers.update(dataSingle, null, 'my-table');
	 * //=> UPDATE "my-table" SET "id"=1,"val"=123,"msg"='hello'
	 *
	 * @example
	 *
	 * // A typical single-object update:
	 *
	 * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + ' WHERE id = ' + dataSingle.id;
	 * //=> UPDATE "my-table" SET "val"=123,"msg"='hello' WHERE id = 1
	 *
	 * @example
	 *
	 * // Column details are required for a multi-row `UPDATE`;
	 * // Adding '?' in front of a column name means it is only for a WHERE condition:
	 *
	 * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';
	 * //=> UPDATE "my-table" AS t SET "val"=v."val","msg"=v."msg" FROM (VALUES(1,123,'hello'),(2,456,'world!'))
	 * //   AS v("id","val","msg") WHERE v.id = t.id
	 *
	 * @example
	 *
	 * // Column details from a reusable ColumnSet (recommended for performance):
	 *
	 * var cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});
	 *
	 * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';
	 * //=> UPDATE "my-table" AS t SET "val"=v."val","msg"=v."msg" FROM (VALUES(1,123,'hello'),(2,456,'world!'))
	 * //   AS v("id","val","msg") WHERE v.id = t.id
	 *
	 * @example
	 *
	 * // Using parameter `options` to change the default alias names:
	 *
	 * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';
	 * //=> UPDATE "my-table" AS X SET "val"=Y."val","msg"=Y."msg" FROM (VALUES(1,123,'hello'),(2,456,'world!'))
	 * //   AS Y("id","val","msg") WHERE Y.id = X.id
	 *
	 */
	function update(data, columns, table, options, capSQL) {

	    if (!data || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
	        throw new TypeError("Invalid parameter 'data' specified.");
	    }

	    var isArray = Array.isArray(data);

	    if (isArray && !data.length) {
	        throw new TypeError("Cannot generate an UPDATE from an empty array.");
	    }

	    if (columns instanceof $npm.ColumnSet) {
	        if ($npm.utils.isNull(table)) {
	            table = columns.table;
	        }
	    } else {
	        if (isArray && $npm.utils.isNull(columns)) {
	            throw new TypeError("Parameter 'columns' is required when updating multiple records.");
	        }
	        columns = new $npm.ColumnSet(columns || data);
	    }

	    if (!$npm.utils.isNull(options) && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
	        throw new TypeError("Invalid parameter 'options' specified.");
	    }

	    var format = $npm.formatting.as.format;

	    if (isArray) {
	        var tableAlias = 't',
	            valueAlias = 'v';
	        if (options) {
	            if (options.tableAlias) {
	                tableAlias = options.tableAlias.toString();
	            }
	            if (options.valueAlias) {
	                valueAlias = options.valueAlias.toString();
	            }
	        }

	        var query = capSQL ? sql.multi.capCase : sql.multi.lowCase;

	        var actualColumns = $arr.filter(columns.columns, function (c) {
	            return !c.cnd;
	        });

	        checkColumns(actualColumns);
	        checkTable();

	        var targetCols = $arr.map(actualColumns, function (c) {
	            return c.escapedName + '=' + valueAlias + '.' + c.escapedName + c.castText;
	        }).join();

	        var values = $arr.map(data, function (d, index) {
	            if (!d || (typeof d === 'undefined' ? 'undefined' : _typeof(d)) !== 'object') {
	                throw new Error("Invalid update object at index " + index + ".");
	            }
	            return '(' + format(columns.variables, columns.prepare(d)) + ')';
	        }).join();

	        return format(query, [table.name, tableAlias, targetCols, values, valueAlias + columns.names]);
	    }

	    var updates = columns.getUpdates(data);

	    checkColumns(updates);
	    checkTable();

	    var query = capSQL ? sql.single.capCase : sql.single.lowCase;

	    return format(query, table.name) + format(updates, columns.prepare(data));

	    function checkTable() {
	        if (table && !(table instanceof $npm.TableName)) {
	            table = new $npm.TableName(table);
	        }
	        if (!table) {
	            throw new Error("Table name is unknown.");
	        }
	    }

	    function checkColumns(cols) {
	        if (!cols.length) {
	            throw new Error("Cannot generate an UPDATE without any columns.");
	        }
	    }
	}

	var sql = {
	    single: {
	        lowCase: "update $1^ set ",
	        capCase: "UPDATE $1^ SET "
	    },
	    multi: {
	        lowCase: "update $1^ as $2^ set $3^ from (values$4^) as $5^",
	        capCase: "UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^"
	    }
	};

	module.exports = update;

/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    ColumnSet: __webpack_require__(501),
	    formatting: __webpack_require__(496),
	    utils: __webpack_require__(500)
	};

	var $arr = __webpack_require__(492);

	/**
	 * @method helpers.values
	 * @description
	 * Generates a string of comma-separated value groups from either one object or an array of objects,
	 * to be used as part of a query:
	 *
	 * - from a single object: `(val_1, val_2, ...)`
	 * - from an array of objects: `(val_11, val_12, ...), (val_21, val_22), ...`
	 *
	 * @param {object|object[]} data
	 * A source object with properties as values, or an array of such objects.
	 *
	 * If it is anything else, the method will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`
	 *
	 * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =
	 * `Invalid object at index N.`
	 *
	 * When `data` is an empty array, an empty string is returned.
	 *
	 * @param {array|helpers.Column|helpers.ColumnSet} [columns]
	 * Columns for which to return values.
	 *
	 * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array
	 * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when generating multi-row values.`
	 *
	 * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw
	 * {@link external:Error Error} = `Cannot generate values without any columns.`
	 *
	 * @returns {string}
	 * - comma-separated value groups, according to `data`
	 * - an empty string, if `data` is an empty array
	 *
	 * @see
	 *  {@link helpers.Column Column},
	 *  {@link helpers.ColumnSet ColumnSet}
	 *
	 * @example
	 *
	 * var pgp = require('pg-promise')();
	 *
	 * var dataSingle = {val: 123, msg: 'hello'};
	 * var dataMulti = [{val: 123, msg: 'hello'}, {val: 456, msg: 'world!'}];
	 *
	 * // Properties can be pulled automatically from a single object:
	 *
	 * pgp.helpers.values(dataSingle);
	 * //=> (123,'hello')
	 *
	 * @example
	 *
	 * // Column details are required when using an array of objects:
	 *
	 * pgp.helpers.values(dataMulti, ['val', 'msg']);
	 * //=> (123,'hello'),(456,'world!')
	 *
	 * @example
	 *
	 * // Column details from a reusable ColumnSet (recommended for performance):
	 *
	 * var cs = new pgp.helpers.ColumnSet(['val', 'msg']);
	 *
	 * pgp.helpers.values(dataMulti, cs);
	 * //=> (123,'hello'),(456,'world!')
	 *
	 */
	function values(data, columns) {

	    if (!data || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
	        throw new TypeError("Invalid parameter 'data' specified.");
	    }

	    var isArray = Array.isArray(data);

	    if (!(columns instanceof $npm.ColumnSet)) {
	        if (isArray && $npm.utils.isNull(columns)) {
	            throw new TypeError("Parameter 'columns' is required when generating multi-row values.");
	        }
	        columns = new $npm.ColumnSet(columns || data);
	    }

	    if (!columns.columns.length) {
	        throw new Error("Cannot generate values without any columns.");
	    }

	    var format = $npm.formatting.as.format;

	    if (isArray) {
	        return $arr.map(data, function (d, index) {
	            if (!d || (typeof d === 'undefined' ? 'undefined' : _typeof(d)) !== 'object') {
	                throw new Error("Invalid object at index " + index + ".");
	            }
	            return '(' + format(columns.castVariables, columns.prepare(d)) + ')';
	        }).join();
	    }
	    return '(' + format(columns.castVariables, columns.prepare(data)) + ')';
	}

	module.exports = values;

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    ColumnSet: __webpack_require__(501),
	    format: __webpack_require__(496).as.format,
	    utils: __webpack_require__(500)
	};

	/**
	 * @method helpers.sets
	 * @description
	 * Generates a string of comma-separated value-set statements from a single object: `col1=val1, col2=val2, ...`,
	 * to be used as part of a query.
	 *
	 * Since it is to be used as part of `UPDATE` queries, {@link helpers.Column Column} properties `cnd` and `skip` apply.
	 *
	 * @param {object} data
	 * A simple, non-null and non-array source object.
	 *
	 * If it is anything else, the method will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`
	 *
	 * @param {array|helpers.Column|helpers.ColumnSet} [columns]
	 * Columns for which to set values.
	 *
	 * When not specified, properties of the `data` object are used.
	 *
	 * When no effective columns are found, an empty string is returned.
	 *
	 * @returns {string}
	 * - comma-separated value-set statements for the `data` object
	 * - an empty string, if no effective columns found
	 *
	 * @see
	 *  {@link helpers.Column Column},
	 *  {@link helpers.ColumnSet ColumnSet}
	 *
	 * @example
	 *
	 * var pgp = require('pg-promise')();
	 *
	 * var data = {id: 1, val: 123, msg: 'hello'};
	 *
	 * // Properties can be pulled automatically from the object:
	 *
	 * pgp.helpers.sets(data);
	 * //=> "id"=1,"val"=123,"msg"='hello'
	 *
	 * @example
	 *
	 * // Column details from a reusable ColumnSet (recommended for performance);
	 * // NOTE: Conditional columns (start with '?') are skipped:
	 *
	 * var cs = new pgp.helpers.ColumnSet(['?id','val', 'msg']);
	 *
	 * pgp.helpers.sets(data, cs);
	 * //=> "val"=123,"msg"='hello'
	 *
	 */
	function sets(data, columns) {

	    if (!data || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || Array.isArray(data)) {
	        throw new TypeError("Invalid parameter 'data' specified.");
	    }

	    if (!(columns instanceof $npm.ColumnSet)) {
	        columns = new $npm.ColumnSet(columns || data);
	    }

	    return $npm.format(columns.getUpdates(data), columns.prepare(data));
	}

	module.exports = sets;

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    fs: __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	    os: __webpack_require__(490),
	    path: __webpack_require__(230),
	    minify: __webpack_require__(488),
	    utils: __webpack_require__(500),
	    format: __webpack_require__(496).as.format,
	    QueryFileError: __webpack_require__(507)
	};

	/**
	 * @constructor QueryFile
	 * @description
	 *
	 * Represents an external SQL file. The type is available from the library's root: `pgp.QueryFile`.
	 *
	 * Reads a file with SQL and prepares it for execution, also parses and minifies it, if required.
	 * The SQL can be of any complexity, with both single and multi-line comments.
	 *
	 * The type can be used in place of the `query` parameter, with any query method directly, plus as `text` in {@link PreparedStatement}
	 * and {@link ParameterizedQuery}.
	 *
	 * It never throws any error, leaving it for query methods to reject with {@link errors.QueryFileError QueryFileError}.
	 *
	 * For any given SQL file you should only create a single instance of this class throughout the application.
	 *
	 * @param {string} file
	 * Path to the SQL file with the query, either absolute or relative to the application's entry point file.
	 *
	 * If there is any problem reading the file, it will be reported when executing the query.
	 *
	 * @param {object} [options]
	 * A set of configuration options.
	 *
	 * @param {boolean} [options.debug]
	 * When in debug mode, the query file is checked for its last modification time on every query request,
	 * so if it changes, the file is read afresh.
	 *
	 * The default for this property is `true` when `NODE_ENV` = `development`,
	 * or `false` otherwise.
	 *
	 * @param {boolean|string} [options.minify=false]
	 * Parses and minifies the SQL using $[pg-minify]:
	 * - `false` - do not use $[pg-minify]
	 * - `true` - use $[pg-minify] to parse and minify SQL
	 * - `'after'` - use $[pg-minify] after applying static formatting parameters
	 *   (option `params`), as opposed to before it (default)
	 *
	 * If option `compress` is set, then the default for `minify` is `true`.
	 *
	 * Failure to parse SQL will result in $[SQLParsingError].
	 *
	 * @param {boolean} [options.compress=false]
	 * Sets option `compress` as supported by $[pg-minify], to uglify the SQL:
	 * - `false` - no compression to be applied, keep minimum spaces for easier read
	 * - `true` - remove all unnecessary spaces from SQL
	 *
	 * This option has no meaning, if `minify` is explicitly set to `false`. However, if `minify` is not
	 * specified and `compress` is specified as `true`, then `minify` defaults to `true`.
	 *
	 * @param {array|object|value} [options.params]
	 * Static formatting parameters to be applied to the SQL, using the same method {@link formatting.format as.format},
	 * but with option `partial` = `true`.
	 *
	 * Most of the time query formatting is fully dynamic, and applied just before executing the query.
	 * In some cases though you may need to pre-format SQL with static values. Examples of it can be a
	 * schema name, or a configurable table name.
	 *
	 * This option makes two-step SQL formatting easy: you can pre-format the SQL initially, and then
	 * apply the second-step dynamic formatting when executing the query.
	 *
	 * @returns {QueryFile}
	 *
	 * @see
	 * {@link errors.QueryFileError QueryFileError},
	 * {@link utils}
	 *
	 * @example
	 * // File sql.js
	 *
	 * // Proper way to organize an sql provider:
	 * //
	 * // - have all sql files for Users in ./sql/users
	 * // - have all sql files for Products in ./sql/products
	 * // - have your sql provider module as ./sql/index.js
	 *
	 * var QueryFile = require('pg-promise').QueryFile;
	 *
	 * // Helper for linking to external query files:
	 * function sql(file) {
	 *     var relativePath = './db/sql/';
	 *     return new QueryFile(relativePath + file, {minify: true});
	 * }
	 *
	 * var sqlProvider = {
	 *     // external queries for Users:
	 *     users: {
	 *         add: sql('users/create.sql'),
	 *         search: sql('users/search.sql'),
	 *         report: sql('users/report.sql'),
	 *     },
	 *     // external queries for Products:
	 *     products: {
	 *         add: sql('products/add.sql'),
	 *         quote: sql('products/quote.sql'),
	 *         search: sql('products/search.sql'),
	 *     }
	 * };
	 *
	 * module.exports = sqlProvider;
	 *
	 * @example
	 * // Testing our SQL provider
	 *
	 * var db = require('./db'); // our database module;
	 * var sql = require('./sql').users; // our sql for users;
	 *
	 * module.exports = {
	 *     addUser: function (name, age) {
	 *         return db.none(sql.add, [name, age]);
	 *     },
	 *     findUser: function (name) {
	 *         return db.any(sql.search, name);
	 *     }
	 * };
	 *
	 */
	function QueryFile(file, options) {

	    if (!(this instanceof QueryFile)) {
	        return new QueryFile(file, options);
	    }

	    var sql,
	        error,
	        ready,
	        modTime,
	        after,
	        filePath = file,
	        opt = {
	        debug: process.env.NODE_ENV === 'development',
	        minify: false,
	        compress: false
	    };

	    if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	        if (options.debug !== undefined) {
	            opt.debug = !!options.debug;
	        }
	        if (options.minify !== undefined) {
	            after = options.minify === 'after';
	            opt.minify = after ? 'after' : !!options.minify;
	        }
	        if (options.compress !== undefined) {
	            opt.compress = !!options.compress;
	        }
	        if (opt.compress && options.minify === undefined) {
	            opt.minify = true;
	        }
	        if (options.params !== undefined) {
	            opt.params = options.params;
	        }
	    }

	    Object.freeze(opt);

	    if ($npm.utils.isText(filePath) && !$npm.utils.isPathAbsolute(filePath)) {
	        filePath = $npm.path.join($npm.utils.startDir, filePath);
	    }

	    /**
	     * @method QueryFile.prepare
	     * @summary Prepares the query for execution.
	     * @description
	     * If the the query hasn't been prepared yet, it will read the file and process the contents according
	     * to the parameters passed into the constructor.
	     *
	     * This method is meant primarily for internal use by the library.
	     *
	     * @returns {boolean}
	     * The indication of a successful unchanged result:
	     * - `true` - successful and unchanged result
	     * - `false` - either changed or unsuccessful result
	     */
	    this.prepare = function () {
	        var lastMod;
	        if (opt.debug && ready) {
	            try {
	                lastMod = $npm.fs.statSync(filePath).mtime.getTime();
	                if (lastMod === modTime) {
	                    return true;
	                }
	                ready = false;
	            } catch (e) {
	                sql = undefined;
	                ready = false;
	                error = e;
	                return false;
	            }
	        }
	        if (ready) {
	            return true;
	        }
	        try {
	            sql = $npm.fs.readFileSync(filePath, 'utf8');
	            modTime = lastMod || $npm.fs.statSync(filePath).mtime.getTime();
	            if (opt.minify && !after) {
	                sql = $npm.minify(sql, { compress: opt.compress });
	            }
	            if (opt.params !== undefined) {
	                sql = $npm.format(sql, opt.params, { partial: true });
	            }
	            if (opt.minify && after) {
	                sql = $npm.minify(sql, { compress: opt.compress });
	            }
	            ready = true;
	            error = undefined;
	        } catch (e) {
	            sql = undefined;
	            error = new $npm.QueryFileError(e, this);
	        }
	        return false;
	    };

	    /**
	     * @name QueryFile#query
	     * @type string
	     * @default undefined
	     * @readonly
	     * @summary Prepared query string.
	     * @description
	     * When property {@link QueryFile#error error} is set, the query is `undefined`.
	     *
	     * This property is meant primarily for internal use by the library.
	     */
	    Object.defineProperty(this, 'query', {
	        get: function get() {
	            return sql;
	        }
	    });

	    /**
	     * @name QueryFile#error
	     * @type {errors.QueryFileError}
	     * @default undefined
	     * @readonly
	     * @description
	     * When in an error state, it is set to a {@link errors.QueryFileError QueryFileError} object. Otherwise, it is `undefined`.
	     *
	     * This property is meant primarily for internal use by the library.
	     */
	    Object.defineProperty(this, 'error', {
	        get: function get() {
	            return error;
	        }
	    });

	    /**
	     * @name QueryFile#file
	     * @type string
	     * @readonly
	     * @description
	     * File name that was passed into the constructor.
	     *
	     * This property is meant primarily for internal use by the library.
	     */
	    Object.defineProperty(this, 'file', {
	        get: function get() {
	            return file;
	        }
	    });

	    /**
	     * @name QueryFile#options
	     * @type object
	     * @readonly
	     * @description
	     * Set of options, as configured during the object's construction.
	     *
	     * This property is meant primarily for internal use by the library.
	     */
	    Object.defineProperty(this, 'options', {
	        get: function get() {
	            return opt;
	        }
	    });

	    this.prepare();
	}

	/**
	 * @method QueryFile.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the object's current state.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	QueryFile.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap = $npm.utils.messageGap(level + 1);
	    var lines = ['QueryFile {'];
	    this.prepare();
	    lines.push(gap + 'file: "' + this.file + '"');
	    lines.push(gap + 'options: ' + JSON.stringify(this.options));
	    if (this.error) {
	        lines.push(gap + 'error: ' + this.error.toString(level + 1));
	    } else {
	        lines.push(gap + 'query: "' + this.query + '"');
	    }
	    lines.push($npm.utils.messageGap(level) + '}');
	    return lines.join($npm.os.EOL);
	};

	QueryFile.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = QueryFile;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    minify: __webpack_require__(488)
	};

	/**
	 * @interface errors.QueryFileError
	 * @augments external:Error
	 * @description
	 * {@link errors.QueryFileError QueryFileError} interface, available from the {@link errors} namespace.
	 *
	 * This type represents all errors related to {@link QueryFile}.
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `QueryFileError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {string} file
	 * File path/name that was passed into the {@link QueryFile} constructor.
	 *
	 * @property {object} options
	 * Set of options that was used by the {@link QueryFile} object.
	 *
	 * @property {SQLParsingError} error
	 * Internal $[SQLParsingError] object.
	 *
	 * It is set only when the error was thrown by $[pg-minify] while parsing the SQL file.
	 *
	 * @see QueryFile
	 *
	 */
	function QueryFileError(error, qf) {
	    var temp = Error.apply(this, arguments);
	    temp.name = this.name = 'QueryFileError';
	    this.stack = temp.stack;
	    if (error instanceof $npm.minify.SQLParsingError) {
	        this.error = error;
	        this.message = "Failed to parse the SQL.";
	    } else {
	        this.message = error.message;
	    }
	    this.file = qf.file;
	    this.options = qf.options;
	}

	QueryFileError.prototype = Object.create(Error.prototype, {
	    constructor: {
	        value: QueryFileError,
	        writable: true,
	        configurable: true
	    }
	});

	/**
	 * @method errors.QueryFileError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	QueryFileError.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        lines = ['QueryFileError {', gap1 + 'message: "' + this.message + '"', gap1 + 'options: ' + JSON.stringify(this.options), gap1 + 'file: "' + this.file + '"'];
	    if (this.error) {
	        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));
	    }
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	QueryFileError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = QueryFileError;

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    qResult: __webpack_require__(509),
	    qFile: __webpack_require__(507),
	    prepared: __webpack_require__(510),
	    paramQuery: __webpack_require__(511)
	};

	/**
	 * @namespace errors
	 * @description
	 * Error types namespace, available as `pgp.errors`, before and after initializing the library.
	 *
	 * @property {function} PreparedStatementError
	 * {@link errors.PreparedStatementError PreparedStatementError} class constructor.
	 *
	 * Represents all errors that can be reported by class {@link PreparedStatement}.
	 *
	 * @property {function} ParameterizedQueryError
	 * {@link errors.ParameterizedQueryError ParameterizedQueryError} class constructor.
	 *
	 * Represents all errors that can be reported by class {@link ParameterizedQuery}.
	 *
	 * @property {function} QueryFileError
	 * {@link errors.QueryFileError QueryFileError} class constructor.
	 *
	 * Represents all errors that can be reported by class {@link QueryFile}.
	 *
	 * @property {function} QueryResultError
	 * {@link errors.QueryResultError QueryResultError} class constructor.
	 *
	 * Represents all result-specific errors from query methods.
	 *
	 * @property {errors.queryResultErrorCode} queryResultErrorCode
	 * Error codes `enum` used by class {@link errors.QueryResultError QueryResultError}.
	 *
	 */

	module.exports = {
	    QueryResultError: $npm.qResult.QueryResultError,
	    queryResultErrorCode: $npm.qResult.queryResultErrorCode,
	    PreparedStatementError: $npm.prepared,
	    ParameterizedQueryError: $npm.paramQuery,
	    QueryFileError: $npm.qFile
	};

	Object.freeze(module.exports);

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500)
	};

	/**
	 * @enum {number}
	 * @alias errors.queryResultErrorCode
	 * @readonly
	 * @description
	 * `queryResultError` code, available from the {@link errors} namespace.
	 *
	 * Represents an integer code for each type of error supported by type {@link errors.QueryResultError}.
	 *
	 * It is to be used when detailed error information is needed.
	 *
	 * @see {@link errors.QueryResultError}
	 */
	var queryResultErrorCode = {
	    /** No data returned from the query. */
	    noData: 0,

	    /** No return data was expected. */
	    notEmpty: 1,

	    /** Multiple rows were not expected. */
	    multiple: 2
	};

	Object.freeze(queryResultErrorCode);

	var errorMessages = [{ name: "noData", message: "No data returned from the query." }, { name: "notEmpty", message: "No return data was expected." }, { name: "multiple", message: "Multiple rows were not expected." }];

	/**
	 * @interface errors.QueryResultError
	 * @augments external:Error
	 * @description
	 *
	 * This error is specified as the rejection reason for all result-specific methods when the result doesn't match
	 * the expectation, i.e. when a query result doesn't match its Query Result Mask - the value of {@link queryResult}.
	 *
	 * The error applies to the result from the following methods: {@link Database.none none},
	 * {@link Database.one one}, {@link Database.oneOrNone oneOrNone} and {@link Database.many many}.
	 *
	 * Supported errors:
	 *
	 * - `No return data was expected.`, method {@link Database.none none}
	 * - `No data returned from the query.`, methods {@link Database.one one} and {@link Database.many many}
	 * - `Multiple rows were not expected.`, methods {@link Database.one one} and {@link Database.oneOrNone oneOrNone}
	 *
	 * Like any other error, this one is notified with through the global event {@link event:error error}.
	 *
	 * The type is available from the {@link errors} namespace.
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `QueryResultError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {object} result
	 * The original $[Result] object that was received.
	 *
	 * @property {number} received
	 * Total number of rows received. It is simply the value of `result.rows.length`.
	 *
	 * @property {number} code
	 * Error code - {@link errors.queryResultErrorCode} value.
	 *
	 * @property {string} query
	 * Query that was executed.
	 *
	 * Normally, it is the query already formatted with values, if there were any.
	 * But if you are using initialization option `pgFormatting`, then the query string is before formatting.
	 *
	 * @property {} values
	 * Values passed in as query parameters. Available only when initialization option `pgFormatting` is used.
	 * Otherwise, the values are within the pre-formatted `query` string.
	 *
	 * @example
	 *
	 * var QueryResultError = pgp.errors.QueryResultError;
	 * var qrec = pgp.errors.queryResultErrorCode;
	 *
	 * var options = {
	 *
	 *   // pg-promise initialization options...
	 *
	 *   error: function (err, e) {
	 *       if (err instanceof QueryResultError) {
	 *           // A query returned unexpected number of records, and thus rejected;
	 *           
	 *           // we can check the error code, if we want specifics:
	 *           if(err.code === qrec.noData) {
	 *               // expected some data, but received none;
	 *           }
	 *
	 *           // If you write QueryResultError into the console,
	 *           // you will get a nicely formatted output.
	 *
	 *           console.log(err);
	 *           
	 *           // See also: err, e.query, e.params, etc.
	 *       }
	 *   }
	 * };
	 *
	 * @see
	 * {@link queryResult}, {@link Database.none none}, {@link Database.one one},
	 * {@link Database.oneOrNone oneOrNone}, {@link Database.many many}
	 *
	 */
	function QueryResultError(code, result, query, values) {
	    var temp = Error.apply(this, arguments);
	    temp.name = this.name = 'QueryResultError';
	    this.stack = temp.stack;
	    this.message = errorMessages[code].message;
	    this.code = code;
	    this.result = result;
	    this.query = query;
	    this.values = values;
	    this.received = result.rows.length;
	}

	QueryResultError.prototype = Object.create(Error.prototype, {
	    constructor: {
	        value: QueryResultError,
	        writable: true,
	        configurable: true
	    }
	});

	/**
	 * @method errors.QueryResultError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	QueryResultError.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        lines = ['QueryResultError {', gap1 + 'code: queryResultErrorCode.' + errorMessages[this.code].name, gap1 + 'message: "' + this.message + '"', gap1 + 'received: ' + this.received, gap1 + 'query: ' + (typeof this.query === 'string' ? '"' + this.query + '"' : JSON.stringify(this.query))];
	    if (this.values !== undefined) {
	        lines.push(gap1 + 'values: ' + JSON.stringify(this.values));
	    }
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	QueryResultError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = {
	    QueryResultError: QueryResultError,
	    queryResultErrorCode: queryResultErrorCode
	};

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    QueryFileError: __webpack_require__(507)
	};

	/**
	 * @interface errors.PreparedStatementError
	 * @augments external:Error
	 * @description
	 * {@link errors.PreparedStatementError PreparedStatementError} interface, available from the {@link errors} namespace.
	 *
	 * This type represents all errors that can be reported by class {@link PreparedStatement}, whether it is used
	 * explicitly or implicitly (via a simple `{name, text, values}` object).
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `PreparedStatementError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {errors.QueryFileError} error
	 * Internal {@link errors.QueryFileError} object.
	 *
	 * It is set only when the source {@link PreparedStatement} used a {@link QueryFile} which threw the error.
	 *
	 * @property {object} result
	 * Resulting Prepared Statement object.
	 *
	 * @see PreparedStatement
	 */
	function PreparedStatementError(error, ps) {
	    var temp = Error.apply(this, arguments);
	    temp.name = this.name = 'PreparedStatementError';
	    this.stack = temp.stack;
	    if (error instanceof $npm.QueryFileError) {
	        this.error = error;
	        this.message = "Failed to initialize 'text' from a QueryFile.";
	    } else {
	        this.message = error;
	    }
	    this.result = ps;
	}

	PreparedStatementError.prototype = Object.create(Error.prototype, {
	    constructor: {
	        value: PreparedStatementError,
	        writable: true,
	        configurable: true
	    }
	});

	/**
	 * @method errors.PreparedStatementError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	PreparedStatementError.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        gap2 = $npm.utils.messageGap(level + 2),
	        lines = ['PreparedStatementError {', gap1 + 'message: "' + this.message + '"', gap1 + 'result: {', gap2 + 'name: ' + JSON.stringify(this.result.name), gap2 + 'text: ' + JSON.stringify(this.result.text), gap2 + 'values: ' + JSON.stringify(this.result.values), gap1 + '}'];
	    if (this.error) {
	        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));
	    }
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	PreparedStatementError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = PreparedStatementError;

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    QueryFileError: __webpack_require__(507)
	};

	/**
	 * @interface errors.ParameterizedQueryError
	 * @augments external:Error
	 * @description
	 * {@link errors.ParameterizedQueryError ParameterizedQueryError} interface, available from the {@link errors} namespace.
	 *
	 * This type represents all errors that can be reported by class {@link ParameterizedQuery}, whether it is used
	 * explicitly or implicitly (via a simple `{text, values}` object).
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `ParameterizedQueryError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {errors.QueryFileError} error
	 * Internal {@link errors.QueryFileError} object.
	 *
	 * It is set only when the source {@link ParameterizedQuery} used a {@link QueryFile} which threw the error.
	 *
	 * @property {object} result
	 * Resulting Parameterized Query object.
	 *
	 * @see ParameterizedQuery
	 */
	function ParameterizedQueryError(error, ps) {
	    var temp = Error.apply(this, arguments);
	    temp.name = this.name = 'ParameterizedQueryError';
	    this.stack = temp.stack;
	    if (error instanceof $npm.QueryFileError) {
	        this.error = error;
	        this.message = "Failed to initialize 'text' from a QueryFile.";
	    } else {
	        this.message = error;
	    }
	    this.result = ps;
	}

	ParameterizedQueryError.prototype = Object.create(Error.prototype, {
	    constructor: {
	        value: ParameterizedQueryError,
	        writable: true,
	        configurable: true
	    }
	});

	/**
	 * @method errors.ParameterizedQueryError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	ParameterizedQueryError.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        gap2 = $npm.utils.messageGap(level + 2),
	        lines = ['ParameterizedQueryError {', gap1 + 'message: "' + this.message + '"', gap1 + 'result: {', gap2 + 'text: ' + JSON.stringify(this.result.text), gap2 + 'values: ' + JSON.stringify(this.result.values), gap1 + '}'];
	    if (this.error) {
	        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));
	    }
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	ParameterizedQueryError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = ParameterizedQueryError;

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    fs: __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
	    path: __webpack_require__(230),
	    utils: __webpack_require__(500),
	    package: __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	};

	var EOL = __webpack_require__(490).EOL;

	/**
	 * @method utils.camelize
	 * @description
	 * Camelizes a text string.
	 *
	 * Case-changing characters include:
	 * - _hyphen_
	 * - _underscore_
	 * - _period_
	 * - _space_
	 *
	 * @param {string} text
	 * Input text string.
	 *
	 * @returns {string}
	 * Camelized text string.
	 *
	 * @see
	 * {@link utils.camelizeVar camelizeVar}
	 *
	 */
	function camelize(text) {
	    text = text.replace(/[\-_\s\.]+(.)?/g, function (match, chr) {
	        return chr ? chr.toUpperCase() : '';
	    });
	    return text.substr(0, 1).toLowerCase() + text.substr(1);
	}

	/**
	 * @method utils.camelizeVar
	 * @description
	 * Camelizes a text string, while making it compliant with JavaScript variable names:
	 * - contains symbols `a-Z`, `A-Z`, `0-9`, `_` and `$`
	 * - cannot have leading digits
	 *
	 * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,
	 * and then it forwards into {@link utils.camelize camelize}.
	 *
	 * @param {string} text
	 * Input text string.
	 *
	 * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.
	 *
	 * @returns {string}
	 * Camelized text string that can be used as an open property name.
	 *
	 * @see
	 * {@link utils.camelize camelize}
	 *
	 */
	function camelizeVar(text) {
	    text = text.replace(/[^a-zA-Z0-9\$_\-\s\.]/g, '').replace(/^[0-9_\-\s\.]+/, '');
	    return camelize(text);
	}

	function _enumSql(dir, options, cb, namePath) {
	    var tree = {};
	    $npm.fs.readdirSync(dir).forEach(function (file) {
	        var stat,
	            fullPath = $npm.path.join(dir, file);
	        try {
	            stat = $npm.fs.statSync(fullPath);
	        } catch (e) {
	            // while it is very easy to test manually, it is very difficult to test for
	            // access-denied errors automatically; therefore excluding from the coverage:
	            // istanbul ignore next
	            if (options.ignoreErrors) {
	                return; // on to the next file/folder;
	            } else {
	                throw e;
	            }
	        }
	        if (stat.isDirectory()) {
	            if (options.recursive) {
	                var dirName = camelizeVar(file);
	                var np = namePath ? namePath + '.' + dirName : dirName;
	                var t = _enumSql(fullPath, options, cb, np);
	                if (Object.keys(t).length) {
	                    if (!dirName.length || dirName in tree) {
	                        if (!options.ignoreErrors) {
	                            throw new Error("Empty or duplicate camelized folder name: " + fullPath);
	                        }
	                    }
	                    tree[dirName] = t;
	                }
	            }
	        } else {
	            if ($npm.path.extname(file).toLowerCase() === '.sql') {
	                var name = camelizeVar(file.replace(/\.[^/.]+$/, ''));
	                if (!name.length || name in tree) {
	                    if (!options.ignoreErrors) {
	                        throw new Error("Empty or duplicate camelized file name: " + fullPath);
	                    }
	                }
	                tree[name] = fullPath;
	                if (cb) {
	                    var result = cb(fullPath, name, namePath ? namePath + '.' + name : name);
	                    if (result !== undefined) {
	                        tree[name] = result;
	                    }
	                }
	            }
	        }
	    });
	    return tree;
	}

	/**
	 * @method utils.enumSql
	 * @description
	 * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.
	 *
	 * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},
	 * so they can be used in the code directly, as open property names.
	 *
	 * @param {string} dir
	 * Directory path where SQL files are located, either absolute or relative to the current directory.
	 *
	 * SQL files are identified by using `.sql` extension (case-insensitive).
	 *
	 * @param {object} [options]
	 * Search options.
	 *
	 * @param {boolean} [options.recursive=false]
	 * Include sub-directories into the search.
	 *
	 * Sub-directories without SQL files will be skipped from the result.
	 *
	 * @param {boolean} [options.ignoreErrors=false]
	 * Ignore the following types of errors:
	 * - access errors, when there is no read access to a file or folder
	 * - empty or duplicate camelized property names
	 *
	 * This flag does not affect errors related to invalid input parameters, or if you pass in a
	 * non-existing directory.
	 *
	 * @param {function} [cb]
	 * A callback function that takes three arguments:
	 * - `file` - SQL file path, relative or absolute, according to how you specified the search directory
	 * - `name` - name of the property that represents the SQL file
	 * - `path` - property resolution path (full property name)
	 *
	 * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.
	 *
	 * @returns {object}
	 * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).
	 *
	 * @see
	 * {@link utils.objectToCode objectToCode},
	 * {@link utils.buildSqlModule buildSqlModule}
	 *
	 * @example
	 *
	 * // simple SQL tree generation for further processing:
	 * var tree = pgp.utils.enumSql('../sql', {recursive: true});
	 *
	 * @example
	 *
	 * // generating an SQL tree for dynamic use of names:
	 * var sql = pgp.utils.enumSql(__dirname, {recursive: true}, file=> {
	 *     return new pgp.QueryFile(file, {minify: true});
	 * });
	 *
	 * @example
	 *
	 * var path = require('path');
	 *
	 * // replacing each relative path in the tree with a full one:
	 * var tree = pgp.utils.enumSql('../sql', {recursive: true}, file=> {
	 *     return path.join(__dirname, file);
	 * });
	 *
	 */
	function enumSql(dir, options, cb) {
	    if (!$npm.utils.isText(dir)) {
	        throw new TypeError("Parameter 'dir' must be a non-empty text string.");
	    }
	    if (!options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
	        options = {};
	    }
	    cb = typeof cb === 'function' ? cb : null;
	    return _enumSql(dir, options, cb, '');
	}

	/**
	 *
	 * @method utils.objectToCode
	 * @description
	 * Translates an object tree into a well-formatted JSON code string.
	 *
	 * @param {object} obj
	 * Source tree object.
	 *
	 * @param {function} [cb]
	 * A callback function to override property values for the code.
	 *
	 * It takes three arguments:
	 *
	 * - `value` - property value
	 * - `name` - property name
	 * - `obj` - current object (which contains the property)
	 *
	 * The returned value is used as is for the property value in the generated code.
	 *
	 * @returns {string}
	 *
	 * @see
	 * {@link utils.enumSql enumSql},
	 * {@link utils.buildSqlModule buildSqlModule}
	 *
	 * @example
	 *
	 * // Generating code for a simple object
	 *
	 * var tree = {one: 1, two: {item: 'abc'}};
	 *
	 * var code = pgp.utils.objectToCode(tree);
	 *
	 * console.log(code);
	 * //=>
	 * // {
	 * //     one: 1,
	 * //     two: {
	 * //         item: "abc"
	 * //     }
	 * // }
	 *
	 * @example
	 *
	 * // Generating a Node.js module with an SQL tree
	 *
	 * var fs = require('fs');
	 * var EOL = require('os').EOL;
	 *
	 * // generating an SQL tree from the folder:
	 * var tree = pgp.utils.enumSql('./sql', {recursive: true});
	 *
	 * // generating the module's code:
	 * var code = "var load = require('./loadSql');" + EOL + EOL + "module.exports = " +
	 *         pgp.utils.objectToCode(tree, function (value) {
	 *             return 'load(' + JSON.stringify(value) + ')';
	 *         }) + ';';
	 *
	 * // saving the module:
	 * fs.writeFileSync('sql.js', code);
	 *
	 * @example
	 *
	 * // generated code example (file sql.js)
	 *
	 * var load = require('./loadSql');
	 *
	 * module.exports = {
	 *     events: {
	 *         add: load("../sql/events/add.sql"),
	 *         delete: load("../sql/events/delete.sql"),
	 *         find: load("../sql/events/find.sql"),
	 *         update: load("../sql/events/update.sql")
	 *     },
	 *     products: {
	 *         add: load("../sql/products/add.sql"),
	 *         delete: load("../sql/products/delete.sql"),
	 *         find: load("../sql/products/find.sql"),
	 *         update: load("../sql/products/update.sql")
	 *     },
	 *     users: {
	 *         add: load("../sql/users/add.sql"),
	 *         delete: load("../sql/users/delete.sql"),
	 *         find: load("../sql/users/find.sql"),
	 *         update: load("../sql/users/update.sql")
	 *     },
	 *     create: load("../sql/create.sql"),
	 *     init: load("../sql/init.sql"),
	 *     drop: load("../sql/drop.sql")
	 *};
	 *
	 * @example
	 *
	 * // loadSql.js module example
	 *
	 * var QueryFile = require('pg-promise').QueryFile;
	 *
	 * module.exports = function(file) {
	 *     return new QueryFile(file, {minify: true});
	 * };
	 *
	 */
	function objectToCode(obj, cb) {

	    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
	        throw new TypeError("Parameter 'obj' must be a non-null object.");
	    }

	    cb = typeof cb === 'function' ? cb : null;

	    return '{' + generate(obj, 1) + EOL + '}';

	    function generate(obj, level) {
	        var code = '',
	            gap = $npm.utils.messageGap(level);
	        var idx = 0;
	        for (var prop in obj) {
	            var value = obj[prop];
	            if (idx) {
	                code += ',';
	            }
	            if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	                code += EOL + gap + prop + ': {';
	                code += generate(value, level + 1);
	                code += EOL + gap + '}';
	            } else {
	                code += EOL + gap + prop + ': ';
	                if (cb) {
	                    code += cb(value, prop, obj);
	                } else {
	                    code += JSON.stringify(value);
	                }
	            }
	            idx++;
	        }
	        return code;
	    }
	}

	/**
	 * @method utils.buildSqlModule
	 * @description
	 * **Added in v.4.3.8**
	 *
	 * Synchronously generates a Node.js module with a camelized SQL tree, based on a configuration object that has the format shown below.
	 *
	 * This method is normally to be used on a grunt/gulp watch that triggers when the file structure changes in your SQL directory,
	 * although it can be invoked manually as well.
	 *
	 * ```js
	 * {
	 *    // Required Properties:
	 *    
	 *    "dir" // {string}: relative or absolute directory where SQL files are located (see API for method enumSql, parameter `dir`)
	 *
	 *    // Optional Properties:
	 *    
	 *    "recursive" // {boolean}: search for sql files recursively (see API for method enumSql, option `recursive`)
	 *
	 *    "ignoreErrors" // {boolean}: ignore common errors (see API for method enumSql, option `ignoreErrors`)
	 *
	 *    "output" // {string}: relative or absolute destination file path; when not specified, no file is created,
	 *             // but you still can use the code string that's always returned by the method.
	 *     
	 *    "module": {
	 *        "path" // {string}: relative path to a module exporting a function which takes a file path
	 *               // and returns a proper value (typically, a new QueryFile object); by default, it uses `./loadSql`.
	 *
	 *        "name" // {string}: local variable name for the SQL-loading module; by default, it uses `load`.
	 *    }
	 * }
	 * ```
	 *
	 * @param {object|string} [config]
	 * Configuration parameter for generating the code.
	 *
	 * - When it is a non-null object, it is assumed to be a configuration object (see the format above).
	 * - When it is a text string - it is the relative path to either a JSON file that contains the configuration object,
	 *   or a Node.js module that exports one. The path is relative to the application's entry point file.
	 * - When `config` isn't specified, the method will try to locate the default `sql-config.json` file in the directory of your
	 *   application's entry point file, and if not found - throw {@link external:Error Error} = `Default SQL configuration file not found`.
	 *
	 * @returns {string}
	 * Generated code.
	 *
	 * @see
	 * {@link utils.enumSql enumSql},
	 * {@link utils.objectToCode objectToCode}
	 *
	 * @example
	 *
	 * // generate SQL module automatically, from sql-config.json in the module's start-up folder:
	 *
	 * pgp.utils.buildSqlModule();
	 *
	 * // see generated file below:
	 *
	 * @example
	 *
	 * /////////////////////////////////////////////////////////////////////////
	 * // This file was automatically generated by pg-promise v.4.3.8
	 * //
	 * // Generated on: 6/2/2016, at 2:15:23 PM
	 * // Total files: 15
	 * //
	 * // API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule
	 * /////////////////////////////////////////////////////////////////////////
	 *
	 * var load = require('./loadSql');
	 *
	 * module.exports = {
	 *     events: {
	 *         add: load("../sql/events/add.sql"),
	 *         delete: load("../sql/events/delete.sql"),
	 *         find: load("../sql/events/find.sql"),
	 *         update: load("../sql/events/update.sql")
	 *     },
	 *     products: {
	 *         add: load("../sql/products/add.sql"),
	 *         delete: load("../sql/products/delete.sql"),
	 *         find: load("../sql/products/find.sql"),
	 *         update: load("../sql/products/update.sql")
	 *     },
	 *     users: {
	 *         add: load("../sql/users/add.sql"),
	 *         delete: load("../sql/users/delete.sql"),
	 *         find: load("../sql/users/find.sql"),
	 *         update: load("../sql/users/update.sql")
	 *     },
	 *     create: load("../sql/create.sql"),
	 *     init: load("../sql/init.sql"),
	 *     drop: load("../sql/drop.sql")
	 *};
	 *
	 */
	function buildSqlModule(config) {

	    if ($npm.utils.isText(config)) {
	        var path = $npm.utils.isPathAbsolute(config) ? config : $npm.path.join($npm.utils.startDir, config);
	        config = __webpack_require__(514)(path);
	    } else {
	        if ($npm.utils.isNull(config)) {
	            var defConfig = $npm.path.join($npm.utils.startDir, 'sql-config.json');
	            // istanbul ignore else;
	            if (!$npm.fs.existsSync(defConfig)) {
	                throw new Error("Default SQL configuration file not found: " + defConfig);
	            }
	            // cannot test this automatically, because it requires that file 'sql-config.json'
	            // resides within the Jasmine folder, since it is the client during the test.
	            // istanbul ignore next;
	            config = __webpack_require__(514)(defConfig);
	        } else {
	            if (!config || (typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
	                throw new TypeError("Invalid parameter 'config' specified.");
	            }
	        }
	    }

	    if (!$npm.utils.isText(config.dir)) {
	        throw new Error("Property 'dir' must be a non-empty string.");
	    }

	    var total = 0;

	    var tree = enumSql(config.dir, { recursive: config.recursive, ignoreErrors: config.ignoreErrors }, function () {
	        total++;
	    });

	    var modulePath = './loadSql',
	        moduleName = 'load';
	    if (config.module && _typeof(config.module) === 'object') {
	        if ($npm.utils.isText(config.module.path)) {
	            modulePath = config.module.path;
	        }
	        if ($npm.utils.isText(config.module.name)) {
	            moduleName = config.module.name;
	        }
	    }

	    var d = new Date();

	    var header = "/////////////////////////////////////////////////////////////////////////" + EOL + "// This file was automatically generated by pg-promise v." + $npm.package.version + EOL + "//" + EOL + "// Generated on: " + d.toLocaleDateString() + ', at ' + d.toLocaleTimeString() + EOL + "// Total files: " + total + EOL + "//" + EOL + "// API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule" + EOL + "/////////////////////////////////////////////////////////////////////////" + EOL + EOL + "'use strict';" + EOL + EOL + "var " + moduleName + " = require('" + modulePath + "');" + EOL + EOL + "module.exports = ";

	    var code = header + objectToCode(tree, function (value) {
	        return moduleName + '(' + JSON.stringify(value) + ')';
	    }) + ';';

	    if ($npm.utils.isText(config.output)) {
	        var path = config.output;
	        if (!$npm.utils.isPathAbsolute(path)) {
	            path = $npm.path.join($npm.utils.startDir, path);
	        }
	        $npm.fs.writeFileSync(path, code);
	    }

	    return code;
	}

	/**
	 * @namespace utils
	 *
	 * @description
	 * **Added in v.4.3.6**
	 *
	 * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.
	 *
	 * Its main purpose is to simplify developing projects with either large or dynamic number of SQL files.
	 *
	 * See also:
	 * - [Automatic SQL Trees](https://github.com/vitaly-t/pg-promise/issues/153)
	 * - [SQL Files](https://github.com/vitaly-t/pg-promise/wiki/SQL-Files)
	 *
	 * @property {function} camelize
	 * {@link utils.camelize camelize} - camelizes a text string
	 *
	 * @property {function} camelizeVar
	 * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable
	 *
	 * @property {function} enumSql
	 * {@link utils.enumSql enumSql} - enumerates SQL files in a directory
	 *
	 * @property {function} objectToCode
	 * {@link utils.objectToCode objectToCode} - generates code from an object
	 *
	 * @property {function} buildSqlModule
	 * {@link utils.buildSqlModule buildSqlModule} - generates a complete Node.js module
	 *
	 */
	module.exports = {
	    camelize: camelize,
	    camelizeVar: camelizeVar,
	    enumSql: enumSql,
	    objectToCode: objectToCode,
	    buildSqlModule: buildSqlModule
	};

	Object.freeze(module.exports);

/***/ },
/* 513 */,
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 500,
		"./index.js": 500,
		"./public": 512,
		"./public.js": 512
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 514;


/***/ },
/* 515 */,
/* 516 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * @enum {number}
	 * @alias txMode.isolationLevel
	 * @readonly
	 * @summary Transaction Isolation Level.
	 * @description
	 * The type is available from the {@link txMode} namespace.
	 * 
	 * @see $[Transaction Isolation]
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var isolationLevel = {
	    /** Isolation level not specified. */
	    none: 0,

	    /** ISOLATION LEVEL SERIALIZABLE */
	    serializable: 1,

	    /** ISOLATION LEVEL REPEATABLE READ */
	    repeatableRead: 2,

	    /** ISOLATION LEVEL READ COMMITTED */
	    readCommitted: 3

	    // From the official documentation: http://www.postgresql.org/docs/9.5/static/sql-set-transaction.html
	    // The SQL standard defines one additional level, READ UNCOMMITTED. In PostgreSQL READ UNCOMMITTED is treated as READ COMMITTED.
	    // => skipping `READ UNCOMMITTED`.
	};

	Object.freeze(isolationLevel);

	/**
	 * @class txMode.TransactionMode
	 * @description
	 * **Alternative Syntax:** `TransactionMode({tiLevel, readOnly, deferrable})` &#8658; {@link TransactionMode}
	 *
	 * Constructs a complete transaction-opening command, based on the parameters:
	 *  - isolation level
	 *  - access mode
	 *  - deferrable mode
	 *
	 * The type is available from the {@link txMode} namespace.
	 *
	 * @param {isolationLevel|Object} [tiLevel]
	 * Transaction Isolation Level, or an object with parameters, if the alternative
	 * syntax is used.
	 *
	 * @param {boolean} [readOnly]
	 * Sets transaction access mode based on the read-only flag:
	 *  - `undefined` - access mode not specified (default)
	 *  - `true` - access mode is set to `READ ONLY`
	 *  - `false` - access mode is set to `READ WRITE`
	 *
	 * @param {boolean} [deferrable]
	 * Sets transaction deferrable mode based on the boolean value:
	 *  - `undefined` - deferrable mode not specified (default)
	 *  - `true` - mode is set to `DEFERRABLE`
	 *  - `false` - mode is set to `NOT DEFERRABLE`
	 *
	 * It is used only when `tiLevel`=`isolationLevel.serializable`
	 * and `readOnly`=`true`, or else it is ignored.
	 *
	 * @returns {txMode.TransactionMode}
	 * 
	 * @see $[BEGIN], {@link txMode.isolationLevel}
	 *
	 * @example
	 *
	 * var TransactionMode = pgp.txMode.TransactionMode;
	 * var isolationLevel = pgp.txMode.isolationLevel;
	 *
	 * // Create a reusable transaction mode (serializable + read-only + deferrable):
	 * var tmSRD = new TransactionMode({
	 *     tiLevel: isolationLevel.serializable,
	 *     readOnly: true,
	 *     deferrable: true
	 * });
	 *
	 * function myTransaction() {
	 *     return this.query("SELECT * FROM table");
	 * }
	 *
	 * myTransaction.txMode = tmSRD; // assign transaction mode;
	 *
	 * db.tx(myTransaction)
	 *     .then(function() {
	 *         // success;
	 *     });
	 *
	 * // Instead of the default BEGIN, such transaction will initiate with:
	 *
	 * // BEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE
	 *
	 */
	function TransactionMode(tiLevel, readOnly, deferrable) {

	    if (!(this instanceof TransactionMode)) {
	        return new TransactionMode(tiLevel, readOnly, deferrable);
	    }

	    if (tiLevel && (typeof tiLevel === 'undefined' ? 'undefined' : _typeof(tiLevel)) === 'object') {
	        readOnly = tiLevel.readOnly;
	        deferrable = tiLevel.deferrable;
	        tiLevel = tiLevel.tiLevel;
	    }

	    var level,
	        accessMode,
	        deferrableMode,
	        capBegin,
	        begin = 'begin';

	    tiLevel = tiLevel > 0 ? parseInt(tiLevel) : 0;

	    if (tiLevel > 0 && tiLevel < 4) {
	        var values = ['serializable', 'repeatable read', 'read committed'];
	        level = 'isolation level ' + values[tiLevel - 1];
	    }

	    if (readOnly) {
	        accessMode = 'read only';
	    } else {
	        if (readOnly !== undefined) {
	            accessMode = 'read write';
	        }
	    }

	    // From the official documentation: http://www.postgresql.org/docs/9.5/static/sql-set-transaction.html
	    // The DEFERRABLE transaction property has no effect unless the transaction is also SERIALIZABLE and READ ONLY
	    if (tiLevel === isolationLevel.serializable && readOnly) {
	        if (deferrable) {
	            deferrableMode = 'deferrable';
	        } else {
	            if (deferrable !== undefined) {
	                deferrableMode = 'not deferrable';
	            }
	        }
	    }

	    if (level) {
	        begin += ' ' + level;
	    }

	    if (accessMode) {
	        begin += ' ' + accessMode;
	    }

	    if (deferrableMode) {
	        begin += ' ' + deferrableMode;
	    }

	    capBegin = begin.toUpperCase();

	    this.begin = function (cap) {
	        return cap ? capBegin : begin;
	    };
	}

	/**
	 * @namespace txMode
	 * @description
	 * Transaction Mode namespace, available as `pgp.txMode`, before and after initializing the library.
	 *
	 * Extends the default `BEGIN` with Transaction Mode parameters:
	 *  - isolation level
	 *  - access mode
	 *  - deferrable mode
	 *
	 * @property {function} TransactionMode
	 * {@link txMode.TransactionMode TransactionMode} class constructor.
	 *
	 * @property {txMode.isolationLevel} isolationLevel
	 * Transaction Isolation Level enumerator
	 *
	 * @see $[BEGIN]
	 */
	module.exports = {
	    isolationLevel: isolationLevel,
	    TransactionMode: TransactionMode
	};

	Object.freeze(module.exports);

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    utils: __webpack_require__(500),
	    PS: __webpack_require__(518),
	    PQ: __webpack_require__(519)
	};

	// istanbul ignore next;
	function ExternalQuery() {}

	ExternalQuery.prototype.inspect = function () {
	    return this.toString();
	};

	$npm.utils.inherits($npm.PS, ExternalQuery);
	$npm.utils.inherits($npm.PQ, ExternalQuery);

	module.exports = {
	    ExternalQuery: ExternalQuery,
	    PreparedStatement: $npm.PS,
	    ParameterizedQuery: $npm.PQ
	};

/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    errors: __webpack_require__(508),
	    QueryFile: __webpack_require__(506)
	};

	/**
	 * @constructor PreparedStatement
	 * @description
	 * **Alternative Syntax:** `PreparedStatement({name, text, values, ...})` &#8658; {@link PreparedStatement}
	 *
	 * Constructs a new $[Prepared Statement] object.
	 *
	 * The alternative syntax supports advanced properties {@link PreparedStatement#binary binary}, {@link PreparedStatement#rowMode rowMode}
	 * and {@link PreparedStatement#rows rows}, which are passed into $[pg], but not used by the class.
	 *
	 * All properties can also be set after the object's construction.
	 *
	 * This type extends the basic `{name, text, values}` object, by replacing it, i.e. when the basic object is used
	 * with a query method, a new {@link PreparedStatement} object is created implicitly in its place.
	 *
	 * The type can be used in place of the `query` parameter, with any query method directly. And it never throws any error,
	 * leaving it for query methods to reject with {@link errors.PreparedStatementError PreparedStatementError}.
	 *
	 * The type is available from the library's root: `pgp.PreparedStatement`.
	 *
	 * @param {string} name
	 * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is
	 * subsequently used to execute or deallocate a previously prepared statement.
	 *
	 * @param {string|QueryFile} text
	 * A non-empty query string or a {@link QueryFile} object.
	 *
	 * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements] are formatted by the database server.
	 *
	 * @param {array} [values]
	 * Query formatting values. When it is not an `Array` and not `null`/`undefined`, it is automatically wrapped into an array.
	 *
	 * @returns {PreparedStatement}
	 *
	 * @see
	 * {@link errors.PreparedStatementError PreparedStatementError},
	 * {@link http://www.postgresql.org/docs/9.5/static/sql-prepare.html PostgreSQL Prepared Statements}
	 *
	 * @example
	 *
	 * var PS = require('pg-promise').PreparedStatement;
	 *
	 * // Creating a complete Prepared Statement with parameters:
	 * var findUser = new PS('find-user', 'SELECT * FROM Users WHERE id = $1', [123]);
	 *
	 * db.one(findUser)
	 *     .then(user=> {
	 *         // user found;
	 *     })
	 *     .catch(error=> {
	 *         // error;
	 *     });
	 *
	 * @example
	 *
	 * var PS = require('pg-promise').PreparedStatement;
	 *
	 * // Creating a reusable Prepared Statement without values:
	 * var addUser = new PS('add-user', 'INSERT INTO Users(name, age) VALUES($1, $2)');
	 *
	 * // setting values explicitly:
	 * addUser.values = ['John', 30];
	 *
	 * db.none(addUser)
	 *     .then(()=> {
	 *         // user added;
	 *     })
	 *     .catch(error=> {
	 *         // error;
	 *     });
	 *
	 * // setting values implicitly, by passing them into the query method:
	 * db.none(addUser, ['Mike', 25])
	 *     .then(()=> {
	 *         // user added;
	 *     })
	 *     .catch(error=> {
	 *         // error;
	 *     });
	 */
	function PreparedStatement(name, text, values) {
	    if (!(this instanceof PreparedStatement)) {
	        return new PreparedStatement(name, text, values);
	    }

	    var currentError,
	        PS = {},
	        changed = true,
	        state = {
	        name: name,
	        text: text,
	        binary: undefined,
	        rowMode: undefined,
	        rows: undefined
	    };

	    function setValues(v) {
	        if (Array.isArray(v)) {
	            if (v.length) {
	                PS.values = v;
	            } else {
	                delete PS.values;
	            }
	        } else {
	            if ($npm.utils.isNull(v)) {
	                delete PS.values;
	            } else {
	                PS.values = [v];
	            }
	        }
	    }

	    setValues(values);

	    /**
	     * @name PreparedStatement#name
	     * @type {string}
	     * @description
	     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is
	     * subsequently used to execute or deallocate a previously prepared statement.
	     */
	    Object.defineProperty(this, 'name', {
	        get: function get() {
	            return state.name;
	        },
	        set: function set(value) {
	            if (value !== state.name) {
	                state.name = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name PreparedStatement#text
	     * @type {string|QueryFile}
	     * @description
	     * A non-empty query string or a {@link QueryFile} object.
	     *
	     * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries
	     * for Prepared Statements are cached, with {@link PreparedStatement#name name} being the cache key.
	     */
	    Object.defineProperty(this, 'text', {
	        get: function get() {
	            return state.text;
	        },
	        set: function set(value) {
	            if (value !== state.text) {
	                state.text = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name PreparedStatement#values
	     * @type {array}
	     * @description
	     * Query formatting parameters, depending on the type:
	     *
	     * - `null` / `undefined` means the query has no formatting parameters
	     * - `Array` - it is an array of formatting parameters
	     * - None of the above, means it is a single formatting value, which
	     *   is then automatically wrapped into an array
	     */
	    Object.defineProperty(this, 'values', {
	        get: function get() {
	            return PS.values;
	        },
	        set: function set(value) {
	            setValues(value);
	        }
	    });

	    /**
	     * @name PreparedStatement#binary
	     * @type {boolean}
	     * @description
	     * Activates binary result mode. The default is the text mode.
	     *
	     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}
	     */
	    Object.defineProperty(this, 'binary', {
	        get: function get() {
	            return state.binary;
	        },
	        set: function set(value) {
	            if (value !== state.binary) {
	                state.binary = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name PreparedStatement#rowMode
	     * @type {string}
	     * @description
	     * Changes the way data arrives to the client, with only one value supported by $[pg]:
	     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.
	     *    By default, rows arrive as objects.
	     */
	    Object.defineProperty(this, 'rowMode', {
	        get: function get() {
	            return state.rowMode;
	        },
	        set: function set(value) {
	            if (value !== state.rowMode) {
	                state.rowMode = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name PreparedStatement#rows
	     * @type {number}
	     * @description
	     * Number of rows to return at a time from a Prepared Statement's portal.
	     * The default is 0, which means that all rows must be returned at once.
	     */
	    Object.defineProperty(this, 'rows', {
	        get: function get() {
	            return state.rows;
	        },
	        set: function set(value) {
	            if (value !== state.rows) {
	                state.rows = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name PreparedStatement#error
	     * @type {errors.PreparedStatementError}
	     * @description
	     * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.
	     *
	     * This property is meant primarily for internal use by the library.
	     */
	    Object.defineProperty(this, 'error', {
	        get: function get() {
	            return currentError;
	        }
	    });

	    if ($npm.utils.isObject(name, ['name'])) {
	        state.name = name.name;
	        state.text = name.text;
	        state.binary = name.binary;
	        state.rowMode = name.rowMode;
	        state.rows = name.rows;
	        setValues(name.values);
	    }

	    /**
	     * @method PreparedStatement.parse
	     * @description
	     * Parses the current object and returns a simple `{name, text, values}`, if successful,
	     * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.
	     *
	     * This method is meant primarily for internal use by the library.
	     *
	     * @returns {{name, text, values}|errors.PreparedStatementError}
	     */
	    this.parse = function () {

	        var qf = state.text instanceof $npm.QueryFile ? state.text : null;

	        if (!changed && !qf) {
	            return PS;
	        }

	        var errors = [],
	            values = PS.values;
	        PS = {
	            name: state.name
	        };
	        changed = true;
	        currentError = undefined;

	        if (!$npm.utils.isText(PS.name)) {
	            errors.push("Property 'name' must be a non-empty text string.");
	        }

	        if (qf) {
	            qf.prepare();
	            if (qf.error) {
	                PS.text = state.text;
	                errors.push(qf.error);
	            } else {
	                PS.text = qf.query;
	            }
	        } else {
	            PS.text = state.text;
	        }
	        if (!$npm.utils.isText(PS.text)) {
	            errors.push("Property 'text' must be a non-empty text string.");
	        }

	        if (!$npm.utils.isNull(values)) {
	            PS.values = values;
	        }

	        if (state.binary !== undefined) {
	            PS.binary = state.binary;
	        }

	        if (state.rowMode !== undefined) {
	            PS.rowMode = state.rowMode;
	        }

	        if (state.rows !== undefined) {
	            PS.rows = state.rows;
	        }

	        if (errors.length) {
	            return currentError = new $npm.errors.PreparedStatementError(errors[0], PS);
	        }

	        changed = false;

	        return PS;
	    };
	}

	/**
	 * @method PreparedStatement.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the object's current state.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	PreparedStatement.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap = $npm.utils.messageGap(level + 1);
	    var ps = this.parse();
	    var lines = ['PreparedStatement {', gap + 'name: ' + JSON.stringify(this.name)];
	    if ($npm.utils.isText(ps.text)) {
	        lines.push(gap + 'text: "' + ps.text + '"');
	    }
	    if (this.values !== undefined) {
	        lines.push(gap + 'values: ' + JSON.stringify(this.values));
	    }
	    if (this.binary !== undefined) {
	        lines.push(gap + 'binary: ' + JSON.stringify(this.binary));
	    }
	    if (this.rowMode !== undefined) {
	        lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));
	    }
	    if (this.rows !== undefined) {
	        lines.push(gap + 'rows: ' + JSON.stringify(this.rows));
	    }
	    if (this.error) {
	        lines.push(gap + 'error: ' + this.error.toString(level + 1));
	    }
	    lines.push($npm.utils.messageGap(level) + '}');
	    return lines.join($npm.os.EOL);
	};

	module.exports = PreparedStatement;

/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    os: __webpack_require__(490),
	    utils: __webpack_require__(500),
	    errors: __webpack_require__(508),
	    QueryFile: __webpack_require__(506)
	};

	/**
	 * @constructor ParameterizedQuery
	 * @description
	 * **Alternative Syntax:** `ParameterizedQuery({text, values, ...})` &#8658; {@link ParameterizedQuery}
	 *
	 * Constructs a new {@link ParameterizedQuery} object.
	 *
	 * The alternative syntax supports advanced properties {@link ParameterizedQuery#binary binary} and {@link ParameterizedQuery#rowMode rowMode},
	 * which are passed into $[pg], but not used by the class.
	 *
	 * All properties can also be set after the object's construction.
	 *
	 * This type extends the basic `{text, values}` object, by replacing it, i.e. when the basic object is used
	 * with a query method, a new {@link ParameterizedQuery} object is created implicitly in its place.
	 *
	 * The type can be used in place of the `query` parameter, with any query method directly. And it never throws any error,
	 * leaving it for query methods to reject with {@link errors.ParameterizedQueryError ParameterizedQueryError}.
	 *
	 * The type is available from the library's root: `pgp.ParameterizedQuery`.
	 *
	 * @param {string|QueryFile} text
	 * A non-empty query string or a {@link QueryFile} object.
	 *
	 * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because _Parameterized Queries_ are formatted by the database server.
	 *
	 * @param {array} [values]
	 * Query formatting values. When it is not an `Array` and not `null`/`undefined`, it is automatically wrapped into an array.
	 *
	 * @returns {ParameterizedQuery}
	 *
	 * @see
	 * {@link errors.ParameterizedQueryError ParameterizedQueryError}
	 *
	 * @example
	 *
	 * var PQ = require('pg-promise').ParameterizedQuery;
	 *
	 * // Creating a complete Parameterized Query with parameters:
	 * var findUser = new PQ('SELECT * FROM Users WHERE id = $1', [123]);
	 *
	 * db.one(findUser)
	 *     .then(user=> {
	 *         // user found;
	 *     })
	 *     .catch(error=> {
	 *         // error;
	 *     });
	 *
	 * @example
	 *
	 * var PQ = require('pg-promise').ParameterizedQuery;
	 *
	 * // Creating a reusable Parameterized Query without values:
	 * var addUser = new PQ('INSERT INTO Users(name, age) VALUES($1, $2)');
	 *
	 * // setting values explicitly:
	 * addUser.values = ['John', 30];
	 *
	 * db.none(addUser)
	 *     .then(()=> {
	 *         // user added;
	 *     })
	 *     .catch(error=> {
	 *         // error;
	 *     });
	 *
	 * // setting values implicitly, by passing them into the query method:
	 * db.none(addUser, ['Mike', 25])
	 *     .then(()=> {
	 *         // user added;
	 *     })
	 *     .catch(error=> {
	 *         // error;
	 *     });
	 *     
	 */
	function ParameterizedQuery(text, values) {
	    if (!(this instanceof ParameterizedQuery)) {
	        return new ParameterizedQuery(text, values);
	    }

	    var currentError,
	        PQ = {},
	        changed = true,
	        state = {
	        text: text,
	        binary: undefined,
	        rowMode: undefined
	    };

	    function setValues(v) {
	        if (Array.isArray(v)) {
	            if (v.length) {
	                PQ.values = v;
	            } else {
	                delete PQ.values;
	            }
	        } else {
	            if ($npm.utils.isNull(v)) {
	                delete PQ.values;
	            } else {
	                PQ.values = [v];
	            }
	        }
	    }

	    setValues(values);

	    /**
	     * @name ParameterizedQuery#text
	     * @type {string|QueryFile}
	     * @description
	     * A non-empty query string or a {@link QueryFile} object.
	     */
	    Object.defineProperty(this, 'text', {
	        get: function get() {
	            return state.text;
	        },
	        set: function set(value) {
	            if (value !== state.text) {
	                state.text = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name ParameterizedQuery#values
	     * @type {array}
	     * @description
	     * Query formatting parameters, depending on the type:
	     *
	     * - `null` / `undefined` means the query has no formatting parameters
	     * - `Array` - it is an array of formatting parameters
	     * - None of the above, means it is a single formatting value, which
	     *   is then automatically wrapped into an array
	     */
	    Object.defineProperty(this, 'values', {
	        get: function get() {
	            return PQ.values;
	        },
	        set: function set(value) {
	            setValues(value);
	        }
	    });

	    /**
	     * @name ParameterizedQuery#binary
	     * @type {boolean}
	     * @description
	     * Activates binary result mode. The default is the text mode.
	     *
	     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}
	     */
	    Object.defineProperty(this, 'binary', {
	        get: function get() {
	            return state.binary;
	        },
	        set: function set(value) {
	            if (value !== state.binary) {
	                state.binary = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name ParameterizedQuery#rowMode
	     * @type {string}
	     * @description
	     * Changes the way data arrives to the client, with only one value supported by $[pg]:
	     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.
	     *    By default, rows arrive as objects.
	     */
	    Object.defineProperty(this, 'rowMode', {
	        get: function get() {
	            return state.rowMode;
	        },
	        set: function set(value) {
	            if (value !== state.rowMode) {
	                state.rowMode = value;
	                changed = true;
	            }
	        }
	    });

	    /**
	     * @name ParameterizedQuery#error
	     * @type {errors.ParameterizedQueryError}
	     * @readonly
	     * @description
	     * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise, it is `undefined`.
	     *
	     * This property is meant primarily for internal use by the library.
	     */
	    Object.defineProperty(this, 'error', {
	        get: function get() {
	            return currentError;
	        }
	    });

	    if ($npm.utils.isObject(text, ['text'])) {
	        state.text = text.text;
	        state.binary = text.binary;
	        state.rowMode = text.rowMode;
	        setValues(text.values);
	    }

	    /**
	     * @method ParameterizedQuery.parse
	     * @description
	     * Parses the current object and returns a simple `{text, values}`, if successful,
	     * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.
	     *
	     * This method is meant primarily for internal use by the library.
	     *
	     * @returns {{text, values}|errors.ParameterizedQueryError}
	     */
	    this.parse = function () {

	        var qf = state.text instanceof $npm.QueryFile ? state.text : null;

	        if (!changed && !qf) {
	            return PQ;
	        }

	        var errors = [],
	            values = PQ.values;
	        PQ = {
	            name: state.name
	        };
	        changed = true;
	        currentError = undefined;

	        if (qf) {
	            qf.prepare();
	            if (qf.error) {
	                PQ.text = state.text;
	                errors.push(qf.error);
	            } else {
	                PQ.text = qf.query;
	            }
	        } else {
	            PQ.text = state.text;
	        }
	        if (!$npm.utils.isText(PQ.text)) {
	            errors.push("Property 'text' must be a non-empty text string.");
	        }

	        if (!$npm.utils.isNull(values)) {
	            PQ.values = values;
	        }

	        if (state.binary !== undefined) {
	            PQ.binary = state.binary;
	        }

	        if (state.rowMode !== undefined) {
	            PQ.rowMode = state.rowMode;
	        }

	        if (errors.length) {
	            return currentError = new $npm.errors.ParameterizedQueryError(errors[0], PQ);
	        }

	        changed = false;

	        return PQ;
	    };
	}

	/**
	 * @method ParameterizedQuery.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the object's current state.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	ParameterizedQuery.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap = $npm.utils.messageGap(level + 1);
	    var pq = this.parse();
	    var lines = ['ParameterizedQuery {'];
	    if ($npm.utils.isText(pq.text)) {
	        lines.push(gap + 'text: "' + pq.text + '"');
	    }
	    if (this.values !== undefined) {
	        lines.push(gap + 'values: ' + JSON.stringify(this.values));
	    }
	    if (this.binary !== undefined) {
	        lines.push(gap + 'binary: ' + JSON.stringify(this.binary));
	    }
	    if (this.rowMode !== undefined) {
	        lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));
	    }
	    if (this.error !== undefined) {
	        lines.push(gap + 'error: ' + this.error.toString(level + 1));
	    }
	    lines.push($npm.utils.messageGap(level) + '}');
	    return lines.join($npm.os.EOL);
	};

	module.exports = ParameterizedQuery;

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    con: __webpack_require__(521).local,
	    result: __webpack_require__(494),
	    special: __webpack_require__(523),
	    context: __webpack_require__(524),
	    events: __webpack_require__(525),
	    utils: __webpack_require__(500),
	    connect: __webpack_require__(526),
	    query: __webpack_require__(527),
	    task: __webpack_require__(529)
	};

	var $arr = __webpack_require__(492);

	/**
	 * @class Database
	 * @description
	 *
	 * Represents the database protocol, extensible via event {@link event:extend extend}.
	 * This type is not available directly, it can only be created via the library's base call.
	 *
	 * **IMPORTANT:**
	 *
	 * For any given connection, you should only create a single {@link Database} object in a separate module,
	 * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}
	 * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a
	 * development environment (when `NODE_ENV` = `development`):
	 *
	 * `WARNING: Creating a duplicate database object for the same connection.`
	 *
	 * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object
	 * per connection details. See the example provided below.
	 *
	 * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.
	 *
	 * @param {String|Object} cn
	 * Database connection details, which can be:
	 *
	 * - a configuration object
	 * - a connection string
	 *
	 * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.
	 *
	 * @param {} [dc]
	 * Database Context.
	 *
	 * Any object or value to be propagated through the protocol, to allow implementations
	 * and event handling that depend on the database context.
	 *
	 * This is mainly to facilitate the use of multiple databases which may need separate protocol
	 * extensions, or different implementations within a single task / transaction callback,
	 * depending on the database context.
	 *
	 * @returns {Database}
	 * 
	 * @see
	 *
	 * {@link Database.query query},
	 * {@link Database.none none},
	 * {@link Database.one one},
	 * {@link Database.oneOrNone oneOrNone},
	 * {@link Database.many many},
	 * {@link Database.manyOrNone manyOrNone},
	 * {@link Database.any any},
	 * {@link Database.func func},
	 * {@link Database.proc proc},
	 * {@link Database.result result},
	 * {@link Database.map map},
	 * {@link Database.each each},
	 * {@link Database.stream stream},
	 * {@link Database.task task},
	 * {@link Database.tx tx},
	 * {@link Database.connect connect},
	 * {@link Database.$config $config},
	 * {@link event:extend extend}
	 *
	 * @example
	 * // Proper way to initialize and share the Database object
	 *
	 * // Loading and initializing the library:
	 * var pgp = require('pg-promise')({
	 *     // Initialization Options
	 * });
	 *
	 * // Preparing the connection details:
	 * var cn = "postgres://username:password@host:port/database";
	 *
	 * // Creating a new database instance from the connection details:
	 * var db = pgp(cn);
	 *
	 * // Exporting the database object for shared use:
	 * module.exports = db;
	 */
	function Database(cn, dc, config) {

	    checkForDuplicates(cn, config);
	    setErrorHandler(config);

	    var $p = config.promise;

	    /**
	     * @method Database.connect
	     *
	     * @description
	     * Acquires a new or existing connection, based on the current connection parameters.
	     *
	     * This method initiates a shared connection for executing a chain of queries against it.
	     * The connection must be released in the end of the chain by calling method `done()` on the connection object.
	     *
	     * This is an older, low-level approach to chaining queries on the same connection.
	     * A newer and safer approach is via methods {@link Database.task task} and {@link Database.tx tx} (for transactions),
	     * which allocate and release the shared connection automatically.
	     *
	     * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,
	     * you cannot call `client.end()` directly, or it will print an error into the console:
	     * `Abnormal client.end() call, due to invalid code or failed server connection.`
	     * You should only call method `done()` to release the connection.
	     *
	     * @param {object} [options]
	     * Connection options. **Added in v.4.3.4**
	     *
	     * @param {boolean} [options.direct=false]
	     * Creates the connection directly, through the {@link external:Client Client}, bypassing the connection pool.
	     *
	     * By default, all connections are acquired from the connection pool. If you set this option, the library will instead
	     * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.
	     *
	     * **WARNING:**
	     *
	     * Do not use this option for regular query execution, because it exclusively occupies one physical connection,
	     * and therefore cannot scale. This option is only suitable for global connection usage, such as database event listeners.
	     *
	     * @returns {external:Promise}
	     * A promise object that represents the connection result:
	     *  - resolves with the complete {@link Database} protocol, extended with:
	     *    - property `client` of type {@link external:Client Client} that represents the open connection
	     *    - method `done()` that must be called in the end, in order to release the connection
	     *  - rejects with the connection error when fails.
	     *
	     * @see
	     * {@link Database.task},
	     * {@link Database.tx}
	     *
	     * @example
	     *
	     * var sco; // shared connection object;
	     *
	     * db.connect()
	     *     .then(function (obj) {
	     *         // obj.client = new connected Client object;
	     *
	     *         sco = obj; // save the connection object;
	     *
	     *         // execute all the queries you need:
	     *         return sco.any('SELECT * FROM Users');
	     *     })
	     *     .then(function (data) {
	     *         // success
	     *     })
	     *     .catch(function (error) {
	     *         // error
	     *     })
	     *     .finally(function () {
	     *         // release the connection, if it was successful:
	     *         if (sco) {
	     *             sco.done();
	     *         }
	     *     });
	     *
	     */
	    this.connect = function (options) {
	        var ctx = createContext();
	        var self = {
	            // Generic query method;
	            query: function query(_query, values, qrm) {
	                if (!ctx.db) {
	                    throw new Error("Cannot execute a query on a disconnected client.");
	                }
	                return config.$npm.query.call(this, ctx, _query, values, qrm);
	            },
	            // Connection release method;
	            done: function done() {
	                if (!ctx.db) {
	                    throw new Error("Cannot invoke done() on a disconnected client.");
	                }
	                ctx.disconnect();
	            }
	        };
	        var method = options && options.direct ? 'direct' : 'pool';
	        return config.$npm.connect[method](ctx).then(function (db) {
	            ctx.connect(db);
	            self.client = db.client;
	            extend(ctx, self);
	            return self;
	        });
	    };

	    /**
	     * @method Database.query
	     *
	     * @description
	     * Executes a generic query request that expects the return data according to parameter `qrm`.
	     *
	     * @param {String|Object} query
	     * Query to be executed, which can any of the following types:
	     * - A non-empty query string
	     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	     * - {@link QueryFile} object
	     *
	     * @param {array|value} [values]
	     * Query formatting parameters.
	     *
	     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	     * - a single value - to replace all `$1` occurrences
	     * - an array of values - to replace all `$1`, `$2`, ... variables
	     * - an object - to apply $[Named Parameters] formatting
	     *
	     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	     * and `values` is not `null` or `undefined`, it is automatically set within such object,
	     * as an override for its internal `values`.
	     *
	     * @param {queryResult} [qrm=queryResult.any]
	     * {@link queryResult Query Result Mask}
	     *
	     * @returns {external:Promise}
	     * A promise object that represents the query result.
	     *
	     * When the query result is an array, it is extended with a hidden property `duration`
	     * - query duration in milliseconds.
	     */
	    this.query = function (query, values, qrm) {
	        var self = this,
	            ctx = createContext();
	        return config.$npm.connect.pool(ctx).then(function (db) {
	            ctx.connect(db);
	            return config.$npm.query.call(self, ctx, query, values, qrm);
	        }).then(function (data) {
	            ctx.disconnect();
	            return data;
	        }).catch(function (error) {
	            ctx.disconnect();
	            return $p.reject(error);
	        });
	    };

	    /**
	     * @member {object} Database.$config
	     * @readonly
	     * @description
	     * **Added in v.4.4.7**
	     *
	     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.
	     *
	     * Properties available in the object:
	     * - `pgp` - instance of the entire library after initialization
	     * - `options` - the library's {@link module:pg-promise Initialization Options} object
	     * - `promiseLib` - instance of the promise library that's used
	     * - `promise` - generic promise interface that uses `promiseLib` via 3 basic methods:
	     *   - `promise((resolve, reject)=>{})` - to create a new promise
	     *   - `promise.resolve(value)` - to resolve with a value
	     *   - `promise.reject(value)` - to reject with a value
	     * - `version` - this library's version _(added in 4.4.8)_
	     * - `$npm` _(hidden property)_ - internal module cache _(added in 4.5.1)_
	     */
	    $npm.utils.addReadProp(this, '$config', config, true);

	    extend(createContext(), this); // extending root protocol;

	    function createContext() {
	        return new $npm.context(cn, dc, config.options);
	    }

	    function singleValue(value, cb, thisArg) {
	        if (typeof cb === 'function') {
	            value = value.then(function (data) {
	                return cb.call(thisArg, data);
	            });
	        }
	        return value;
	    }

	    ////////////////////////////////////////////////////
	    // Injects additional methods into an access object,
	    // extending the protocol's base method 'query'.
	    function extend(ctx, obj) {

	        /**
	         * @method Database.none
	         * @description
	         * Executes a query that expects no data to be returned.
	         * If the query returns any kind of data, the method rejects.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - when no records are returned, it resolves with `null`
	         * - when any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}
	         * = `No return data was expected.`
	         */
	        obj.none = function (query, values) {
	            return obj.query.call(this, query, values, $npm.result.none);
	        };

	        /**
	         * @method Database.one
	         * @description
	         * Executes a query that expects exactly one row of data.
	         * When 0 or more than 1 rows are returned, the method rejects.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @param {function} [cb]
	         * **Added in 4.6.0**
	         *
	         * Value transformation callback, to allow in-line value change.
	         * When specified, the return value replaces the original resolved value.
	         *
	         * The function takes only one parameter - value resolved from the query.
	         *
	         * @param {} [thisArg]
	         * **Added in 4.6.0**
	         *
	         * Value to use as `this` when executing the transformation callback.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - when 1 row is returned, it resolves with that row as a single object;
	         * - when no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}
	         * = `No data returned from the query.`
	         * - when multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}
	         * = `Multiple rows were not expected.`
	         *
	         * @example
	         *
	         * // a query with in-line value transformation:
	         * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event=>event.id)
	         *     .then(data=> {
	         *         // data = a new event id, rather than an object with it
	         *     });
	         *
	         * @example
	         *
	         * // a query with in-line value transformation + conversion:
	         * db.one('SELECT count(*) FROM Users', null, value=>parseInt(value.count))
	         *     .then(data=> {
	         *         // data = a proper integer, rather than an object with a string
	         *     });
	         *
	         */
	        obj.one = function (query, values, cb, thisArg) {
	            var v = obj.query.call(this, query, values, $npm.result.one);
	            return singleValue(v, cb, thisArg);
	        };

	        /**
	         * @method Database.many
	         * @description
	         * Executes a query that expects one or more rows.
	         * When the query returns no data, the method rejects.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - when 1 or more rows are returned, it resolves with the array of rows
	         * - when no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}
	         * = `No data returned from the query.`
	         */
	        obj.many = function (query, values) {
	            return obj.query.call(this, query, values, $npm.result.many);
	        };

	        /**
	         * @method Database.oneOrNone
	         * @description
	         * Executes a query that expects 0 or 1 rows.
	         * When the query returns more than 1 row, the method rejects.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @param {function} [cb]
	         * **Added in 4.6.0**
	         *
	         * Value transformation callback, to allow in-line value change.
	         * When specified, the return value replaces the original resolved value.
	         *
	         * The function takes only one parameter - value resolved from the query.
	         *
	         * @param {} [thisArg]
	         * **Added in 4.6.0**
	         *
	         * Value to use as `this` when executing the transformation callback.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - when no rows are returned, it resolves with `null`
	         * - when 1 row is returned, it resolves with that row as a single object
	         * - when multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}
	         * = `Multiple rows were not expected.`
	         *
	         * @see
	         * {@link Database.one one},
	         * {@link Database.none none}
	         *
	         * @example
	         *
	         * // a query with in-line value transformation:
	         * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e ? e.id : null)
	         *     .then(data=> {
	         *         // data = the event id or null (rather than object or null)
	         *     });
	         *
	         */
	        obj.oneOrNone = function (query, values, cb, thisArg) {
	            var v = obj.query.call(this, query, values, $npm.result.one | $npm.result.none);
	            return singleValue(v, cb, thisArg);
	        };

	        /**
	         * @method Database.manyOrNone
	         * @description
	         * Executes a query that expects any number of rows.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - when no rows are returned, it resolves with an empty array
	         * - when 1 or more rows are returned, it resolves with the array of rows.
	         *
	         * @see {@link Database.any any}
	         *
	         */
	        obj.manyOrNone = function (query, values) {
	            return obj.query.call(this, query, values, $npm.result.many | $npm.result.none);
	        };

	        /**
	         * @method Database.any
	         * @description
	         * Executes a query that expects any number of rows.
	         *
	         * This is simply a shorter alias for method {@link Database.manyOrNone manyOrNone}.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - when no rows are returned, it resolves with an empty array
	         * - when 1 or more rows are returned, it resolves with the array of rows.
	         *
	         * @see
	         * {@link Database.manyOrNone manyOrNone},
	         * {@link Database.map map},
	         * {@link Database.each each}
	         *
	         */
	        obj.any = function (query, values) {
	            return obj.query.call(this, query, values, $npm.result.any);
	        };

	        /**
	         * @method Database.result
	         * @description
	         * Executes a query without any expectation for the return data, to resolve with the
	         * original $[Result] object when successful.
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @param {function} [cb]
	         * **Added in 4.6.2**
	         *
	         * Value transformation callback, to allow in-line value change.
	         * When specified, the return value replaces the original resolved value.
	         *
	         * The function takes only one parameter - value resolved from the query.
	         *
	         * @param {} [thisArg]
	         * **Added in 4.6.2**
	         *
	         * Value to use as `this` when executing the transformation callback.
	         *
	         * @returns {external:Promise}
	         * A promise object that represents the query result:
	         * - resolves with the original $[Result] object, extended with
	         *   property `duration` - query duration in milliseconds.
	         *
	         * @example
	         *
	         * // use of value transformation:
	         * // deleting rows and returning the number of rows deleted
	         * db.result('DELETE FROM Events WHERE id = $1', [123], r=>r.rowCount)
	         *     .then(data=> {
	         *         // data = number of rows that were deleted
	         *     });
	         *
	         * @example
	         *
	         * // use of value transformation:
	         * // getting only column details from a table
	         * db.result('SELECT * FROM Users LIMIT 0', null, r=>r.fields)
	         *     .then(data=> {
	         *         // data = array of column descriptors
	         *     });
	         *
	         */
	        obj.result = function (query, values, cb, thisArg) {
	            var v = obj.query.call(this, query, values, $npm.special.cache.resultQuery);
	            return singleValue(v, cb, thisArg);
	        };

	        /**
	         * @method Database.stream
	         * @description
	         * Custom data streaming, with the help of $[pg-query-stream].
	         *
	         * This method doesn't work with the $[Native Bindings], and if option `pgNative`
	         * is set, it will reject with `Streaming doesn't work with Native Bindings.`
	         *
	         * @param {QueryStream} qs
	         * Stream object of type $[QueryStream].
	         *
	         * @param {Database.streamInitCB} initCB
	         * Stream initialization callback.
	         *
	         * It is invoked with the same `this` context as the calling method.
	         *
	         * @returns {external:Promise}
	         * Result of the streaming operation.
	         *
	         * Once the streaming has finished successfully, the method resolves with
	         * `{processed, duration}`:
	         * - `processed` - total number of rows processed;
	         * - `duration` - streaming duration, in milliseconds.
	         *
	         * Possible rejections messages:
	         * - `Invalid or missing stream object.`
	         * - `Invalid stream state.`
	         * - `Invalid or missing stream initialization callback.`
	         */
	        obj.stream = function (qs, init) {
	            return obj.query.call(this, qs, init, $npm.special.cache.streamQuery);
	        };

	        /**
	         * @method Database.func
	         * @description
	         * Executes a query against a database function by its name: `SELECT * FROM funcName(values)`.
	         *
	         * @param {string} funcName
	         * Name of the function to be executed.
	         *
	         * @param {array|value} [values]
	         * Parameters for the function - one value or an array of values.
	         *
	         * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.
	         *
	         * @returns {external:Promise}
	         * Result of the query call, according to parameter `qrm`.
	         *
	         * @see
	         * {@link Database.query query},
	         * {@link Database.proc proc}
	         */
	        obj.func = function (funcName, values, qrm) {
	            return obj.query.call(this, {
	                funcName: funcName
	            }, values, qrm);
	        };

	        /**
	         * @method Database.proc
	         * @description
	         * Executes a query against a stored procedure via its name: `select * from procName(values)`,
	         * expecting back 0 or 1 rows.
	         *
	         * The method simply forwards into {@link Database.func func}`(procName, values, queryResult.one|queryResult.none)`.
	         *
	         * @param {string} procName
	         * Name of the stored procedure to be executed.
	         *
	         * @param {array|value} [values]
	         * Parameters for the procedure - one value or an array of values.
	         *
	         * @param {function} [cb]
	         * **Added in 4.6.0**
	         *
	         * Value transformation callback, to allow in-line value change.
	         * When specified, the return value replaces the original resolved value.
	         *
	         * The function takes only one parameter - value resolved from the query.
	         *
	         * @param {} [thisArg]
	         * **Added in 4.6.0**
	         *
	         * Value to use as `this` when executing the transformation callback.
	         *
	         * @returns {external:Promise}
	         * The same result as method {@link Database.oneOrNone oneOrNone}.
	         *
	         * @see
	         * {@link Database.oneOrNone oneOrNone},
	         * {@link Database.func func}
	         */
	        obj.proc = function (procName, values, cb, thisArg) {
	            var v = obj.func.call(this, procName, values, $npm.result.one | $npm.result.none);
	            return singleValue(v, cb, thisArg);
	        };

	        /**
	         * @method Database.map
	         * @description
	         * **Added in v.4.3.0**
	         *
	         * Creates a new array with the results of calling a provided function on every element in the array of rows
	         * resolved by method {@link Database.any any}.
	         *
	         * It is a convenience method to simplify the following code:
	         *
	         * ```js
	         * db.any(query, values)
	         *     .then(function(data) {
	         *         return data.map(function(row, index, data) {
	         *              // return a new element
	         *         });
	         *     });
	         * ```
	         *
	         * In addition to much shorter code, it offers the following benefits:
	         *
	         * - Use of a custom iterator has a much better performance than the standard {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}
	         * - Automatic `this` context through the database protocol
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} values
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @param {function} cb
	         * Function that produces an element of the new array, taking three arguments:
	         * - `row` - the current row being processed in the array
	         * - `index` - the index of the current row being processed in the array
	         * - `data` - the original array of rows resolved by method {@link Database.any any}
	         *
	         * @param {} [thisArg]
	         * Value to use as `this` when executing the callback.
	         *
	         * @returns {external:Promise}
	         * Resolves with the new array of values returned from the callback.
	         *
	         * @see
	         * {@link Database.any any},
	         * {@link Database.each each},
	         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}
	         *
	         * @example
	         *
	         * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)
	         *     .then(data => {
	         *         // data = array of active user id-s
	         *     })
	         *     .catch(error => {
	         *        // error
	         *     });
	         *
	         * @example
	         *
	         * db.tx(t => {
	         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {
	         *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);
	         *     }).then(t.batch);
	         * })
	         *     .then(data => {
	         *         // success
	         *     })
	         *     .catch(error => {
	         *         // error
	         *     });
	         *
	         * @example
	         *
	         * // Build a list of active users, each with the list of user events:
	         * db.task(t => {
	         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {
	         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)
	         *             .then(events=> {
	         *                 user.events = events;
	         *                 return user;
	         *             });
	         *     }).then(t.batch);
	         * })
	         *     .then(data => {
	         *         // success
	         *     })
	         *     .catch(error => {
	         *         // error
	         *     });
	         *
	         */
	        obj.map = function (query, values, cb, thisArg) {
	            return obj.any.call(this, query, values).then(function (data) {
	                return $arr.map(data, cb, thisArg);
	            });
	        };

	        /**
	         * @method Database.each
	         * @description
	         * **Added in v.4.3.0**
	         *
	         * Executes a provided function once per array element, for an array of rows resolved by method {@link Database.any any}.
	         *
	         * It is a convenience method to simplify the following code:
	         *
	         * ```js
	         * db.any(query, values)
	         *     .then(function(data) {
	         *         data.forEach(function(row, index, data) {
	         *              // process the row
	         *         });
	         *         return data;
	         *     });
	         * ```
	         *
	         * In addition to much shorter code, it offers the following benefits:
	         *
	         * - Use of a custom iterator has a much better performance than the regular {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}
	         * - Automatic `this` context through the database protocol
	         *
	         * @param {String|Object} query
	         * Query to be executed, which can any of the following types:
	         * - A non-empty query string
	         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object
	         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object
	         * - {@link QueryFile} object
	         *
	         * @param {array|value} [values]
	         * Query formatting parameters.
	         *
	         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:
	         * - a single value - to replace all `$1` occurrences
	         * - an array of values - to replace all `$1`, `$2`, ... variables
	         * - an object - to apply $[Named Parameters] formatting
	         *
	         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),
	         * and `values` is not `null` or `undefined`, it is automatically set within such object,
	         * as an override for its internal `values`.
	         *
	         * @param {function} cb
	         * Function to execute for each row, taking three arguments:
	         * - `row` - the current row being processed in the array
	         * - `index` - the index of the current row being processed in the array
	         * - `data` - the array of rows resolved by method {@link Database.any any}
	         *
	         * @param {} [thisArg]
	         * Value to use as `this` when executing the callback.
	         *
	         * @returns {external:Promise}
	         * Resolves with the original array of rows.
	         *
	         * @see
	         * {@link Database.any any},
	         * {@link Database.map map},
	         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}
	         *
	         * @example
	         *
	         * db.each('SELECT id, code, name FROM Events', null, row => {
	         *     row.code = parseInt(row.code);
	         * })
	         *     .then(data => {
	         *         // data = array of events, with 'code' converted into integer
	         *     })
	         *     .catch(error => {
	         *         // error
	         *     });
	         *
	         */
	        obj.each = function (query, values, cb, thisArg) {
	            return obj.any.call(this, query, values).then(function (data) {
	                $arr.forEach(data, cb, thisArg);
	                return data;
	            });
	        };

	        /**
	         * @method Database.task
	         * @description
	         * Executes a callback function (or $[ES6 generator]) with an automatically managed connection.
	         *
	         * This method should be used whenever executing more than one query at once, so the allocated connection
	         * is reused between all queries, and released only after the task has finished.
	         *
	         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods
	         * {@link Task.batch batch}, {@link Task.page page}, {@link Task.sequence sequence}, plus property {@link Task.ctx ctx} -
	         * the task context object.
	         *
	         * See class {@link Task} for more details.
	         *
	         * @param {} tag/cb
	         * When the method takes only one parameter, it must be the callback function (or $[ES6 generator]) for the task.
	         * However, when calling the method with 2 parameters, the first one is always the `tag` - traceable context for the
	         * task (see $[tags]).
	         *
	         * @param {function|generator} [cb]
	         * Task callback function (or $[ES6 generator]), if it is not `undefined`, or else the callback is expected to
	         * be passed in as the first parameter.
	         *
	         * @returns {external:Promise}
	         * Result from the callback function.
	         *
	         * @see
	         * {@link Task},
	         * {@link Database.tx tx},
	         * $[tags]
	         *
	         * @example
	         *
	         * // using the regular callback syntax:
	         * db.task(function(t) {
	         *         // t = this
	         *         // t.ctx = task context object
	         *
	         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')
	         *             .then(user=> {
	         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);
	         *             });
	         *     })
	         *     .then(function(data) {
	         *         // success
	         *         // data = as returned from the task's callback
	         *     })
	         *     .catch(function(error) {
	         *         // error
	         *     });
	         *
	         * @example
	         *
	         * // using the ES6 arrow syntax:
	         * db.task(t=> {
	         *         // t.ctx = task context object
	         *         
	         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')
	         *             .then(user=> {
	         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);
	         *             });
	         *     })
	         *     .then(data=> {
	         *         // success
	         *         // data = as returned from the task's callback
	         *     })
	         *     .catch(error=> {
	         *         // error
	         *     });
	         *
	         * @example
	         *
	         * // using an ES6 generator for the callback:
	         * db.task(function*(t) {
	         *         // t = this
	         *         // t.ctx = task context object
	         *
	         *         let user = yield t.one('SELECT id FROM Users WHERE name = $1', 'John');
	         *         return yield t.any('SELECT * FROM Events WHERE userId = $1', user.id);
	         *     })
	         *     .then(function(data) {
	         *         // success
	         *         // data = as returned from the task's callback
	         *     })
	         *     .catch(function(error) {
	         *         // error
	         *     });
	         *
	         */
	        obj.task = function (p1, p2) {
	            return taskProcessor.call(this, p1, p2, false);
	        };

	        /**
	         * @method Database.tx
	         * @description
	         * Executes a callback function (or $[ES6 generator]) as a transaction.
	         *
	         * A transaction simply wraps a regular {@link Database.task task} in automatic queries:
	         * - it executes `BEGIN` just before invoking the callback function
	         * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise
	         * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise
	         *
	         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods
	         * {@link Task.batch batch}, {@link Task.page page}, {@link Task.sequence sequence}, plus property {@link Task.ctx ctx} -
	         * the transaction context object.
	         *
	         * See class {@link Task} for more details.
	         *
	         * Note that transactions should be chosen over tasks only where they are necessary, because unlike regular tasks,
	         * transactions are blocking operations, and must be used with caution.
	         *
	         * @param {} tag/cb
	         * When the method takes only one parameter, it must be the callback function (or $[ES6 generator]) for the transaction.
	         * However, when calling the method with 2 parameters, the first one is always the `tag` - traceable context for the
	         * transaction (see $[tags]).
	         *
	         * @param {function|generator} [cb]
	         * Transaction callback function (or $[ES6 generator]), if it is not `undefined`, or else the callback is expected to be
	         * passed in as the first parameter.
	         *
	         * @returns {external:Promise}
	         * Result from the callback function.
	         *
	         * @see
	         * {@link Task},
	         * {@link Database.task},
	         * $[tags]
	         *
	         * @example
	         *
	         * // using the regular callback syntax:
	         * db.tx(function(t) {
	         *         // t = this
	         *         // t.ctx = transaction context object
	         *
	         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])
	         *             .then(user=> {
	         *                 return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);
	         *             });
	         *     })
	         *     .then(function(data) {
	         *         // success
	         *         // data = as returned from the transaction's callback
	         *     })
	         *     .catch(function(error) {
	         *         // error
	         *     });
	         *
	         * @example
	         *
	         * // using the ES6 arrow syntax:
	         * db.tx(t=> {
	         *         // t.ctx = transaction context object
	         *         
	         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])
	         *             .then(user=> {
	         *                 return t.batch([
	         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),
	         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])
	         *                 ]);
	         *             });
	         *     })
	         *     .then(data=> {
	         *         // success
	         *         // data = as returned from the transaction's callback
	         *     })
	         *     .catch(error=> {
	         *         // error
	         *     });
	         *
	         * @example
	         *
	         * // using an ES6 generator for the callback:
	         * db.tx(function*(t) {
	         *         // t = this
	         *         // t.ctx = transaction context object
	         *
	         *         let user = yield t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);
	         *         return yield t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);
	         *     })
	         *     .then(function(data) {
	         *         // success
	         *         // data = as returned from the transaction's callback
	         *     })
	         *     .catch(function(error) {
	         *         // error
	         *     });
	         *
	         */
	        obj.tx = function (p1, p2) {
	            return taskProcessor.call(this, p1, p2, true);
	        };

	        // Task method;
	        // Resolves with result from the callback function;
	        function taskProcessor(p1, p2, isTX) {

	            var tag,
	                // tag object/value;
	            taskCtx = ctx.clone(); // task context object;

	            if (isTX) {
	                taskCtx.txLevel = taskCtx.txLevel >= 0 ? taskCtx.txLevel + 1 : 0;
	            }

	            if (this !== obj) {
	                taskCtx.context = this; // calling context object;
	            }

	            taskCtx.cb = p1; // callback function;

	            // allow inserting a tag in front of the callback
	            // function, for better code readability;
	            if (p2 !== undefined) {
	                tag = p1; // overriding any default tag;
	                taskCtx.cb = p2;
	            }

	            var cb = taskCtx.cb;

	            if (typeof cb !== 'function') {
	                return $p.reject(new TypeError("Callback function is required for the " + (isTX ? "transaction." : "task.")));
	            }

	            if (tag === undefined) {
	                if (cb.tag !== undefined) {
	                    // use the default tag associated with the task:
	                    tag = cb.tag;
	                } else {
	                    if (cb.name) {
	                        tag = cb.name; // use the function name as tag;
	                    }
	                }
	            }

	            var tsk = new config.$npm.task(taskCtx, tag, isTX, config);

	            extend(taskCtx, tsk);

	            if (taskCtx.db) {
	                // reuse existing connection;
	                $npm.utils.addReadProp(tsk.ctx, 'isFresh', taskCtx.db.isFresh);
	                return config.$npm.task.exec(taskCtx, tsk, isTX, config);
	            }

	            // connection required;
	            return config.$npm.connect.pool(taskCtx).then(function (db) {
	                taskCtx.connect(db);
	                $npm.utils.addReadProp(tsk.ctx, 'isFresh', db.isFresh);
	                return config.$npm.task.exec(taskCtx, tsk, isTX, config);
	            }).then(function (data) {
	                taskCtx.disconnect();
	                return data;
	            }).catch(function (error) {
	                taskCtx.disconnect();
	                return $p.reject(error);
	            });
	        }

	        // lock all default properties to read-only,
	        // to prevent override by the client.
	        $npm.utils.lock(obj, false, ctx.options);

	        // extend the protocol;
	        $npm.events.extend(ctx.options, obj, ctx.dc);

	        // freeze the protocol permanently;
	        $npm.utils.lock(obj, true, ctx.options);
	    }
	}

	var jsHandled,
	    nativeHandled,
	    dbObjects = {};

	function checkForDuplicates(cn, config) {
	    var cnKey = JSON.stringify(cn);
	    if (cnKey in dbObjects) {
	        if (!config.options.noWarnings) {
	            $npm.con.warn("WARNING: Creating a duplicate database object for the same connection.\n%s\n", $npm.utils.getLocalStack(5));
	        }
	    } else {
	        dbObjects[cnKey] = true;
	    }
	}

	function setErrorHandler(config) {
	    // we do not do code coverage specific to Native Bindings:
	    // istanbul ignore if
	    if (config.options.pgNative) {
	        if (!nativeHandled) {
	            config.pgp.pg.on('error', onError);
	            nativeHandled = true;
	        }
	    } else {
	        if (!jsHandled) {
	            config.pgp.pg.on('error', onError);
	            jsHandled = true;
	        }
	    }
	}

	// this event only happens when the connection is lost physically,
	// which cannot be tested automatically; removing from coverage:
	// istanbul ignore next
	function onError(err, client) {
	    var ctx = client.$ctx;
	    $npm.events.error(ctx.options, err, {
	        cn: $npm.utils.getSafeConnection(ctx.cn),
	        dc: ctx.dc
	    });
	}

	module.exports = function (config) {
	    var npm = config.$npm;
	    npm.connect = npm.connect || $npm.connect(config);
	    npm.query = npm.query || $npm.query(config);
	    npm.task = npm.task || $npm.task(config);
	    return Database;
	};

	/**
	 * @callback Database.streamInitCB
	 * @description
	 * Stream initialization callback, used by {@link Database.stream}.
	 *
	 * @param {external:Stream} stream
	 * Stream object to initialize streaming.
	 *
	 * @example
	 * var QueryStream = require('pg-query-stream');
	 * var JSONStream = require('JSONStream');
	 *
	 * // you can also use pgp.as.format(query, values, options)
	 * // to format queries properly, via pg-promise;
	 * var qs = new QueryStream('select * from users');
	 *
	 * db.stream(qs, function (stream) {
	 *         // initiate streaming into the console:
	 *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);
	 *     })
	 *     .then(function (data) {
	 *         console.log("Total rows processed:", data.processed,
	 *           "Duration in milliseconds:", data.duration);
	 *     })
	 *     .catch(function (error) {
	 *         // error;
	 *     });
	 */

	/**
	 * @external Stream
	 * @see https://nodejs.org/api/stream.html
	 */

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Writer = __webpack_require__(522);

	function getLocal() {
	    return new Writer();
	}

	var glb = new Writer();

	function getGlobal() {
	    console.log = function () {
	        glb.log.apply(glb, arguments);
	    };
	    console.error = function () {
	        glb.error.apply(glb, arguments);
	    };
	    console.warn = function () {
	        glb.warn.apply(glb, arguments);
	    };
	    return glb;
	}

	var exp = module.exports = new Writer(true);

	Object.defineProperty(exp, 'local', {
	    get: getLocal,
	    enumerable: true
	});

	Object.defineProperty(exp, 'global', {
	    get: getGlobal,
	    enumerable: true
	});

	Object.freeze(exp);

/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var util = __webpack_require__(263);

	var $log = console.log;

	function colorize(value, color, isMsg) {
	    value = isMsg && typeof value === 'string' ? value : util.inspect(value);
	    return "\x1b[" + color + 'm' + value + "\x1b[0m";
	}

	function format(values, color) {
	    if (process.stdout.isTTY) {
	        if (values.length && typeof values[0] === 'string') {
	            return [colorize(util.format.apply(null, values), color, true)];
	        }
	        return Object.keys(values).map(function (key) {
	            return colorize(values[key], color);
	        });
	    }
	    return values;
	}

	function Writer(noLock) {

	    var self = this;

	    this.log = function () {
	        var args = self.log.bright ? format(arguments, 97) : arguments;
	        $log.apply(null, args);
	    };

	    this.error = function () {
	        $log.apply(null, format(arguments, self.error.bright ? 91 : 31));
	    };

	    this.warn = function () {
	        $log.apply(null, format(arguments, self.warn.bright ? 93 : 33));
	    };

	    this.write = function (values, color) {
	        if (color !== parseInt(color) || color < 0 || color > 256) {
	            $log.apply(null, values);
	        } else {
	            $log.apply(null, format(values, color));
	        }
	    };

	    setBright('log');
	    setBright('error');
	    setBright('warn');

	    if (!noLock) {
	        Object.freeze(this);
	    }

	    function setBright(name) {
	        Object.defineProperty(self[name], 'bright', {
	            value: false,
	            writable: true
	        });
	        Object.seal(self[name]);
	    }
	}

	module.exports = Writer;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 523 */
/***/ function(module, exports) {

	'use strict';

	/////////////////////////////
	// Special Query type;

	function SpecialQuery(type) {
	    this.isStream = type === 'stream';
	    this.isResult = type === 'result';
	}

	var cache = {
	    resultQuery: new SpecialQuery('result'),
	    streamQuery: new SpecialQuery('stream')
	};

	module.exports = {
	    SpecialQuery: SpecialQuery,
	    cache: cache
	};

/***/ },
/* 524 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * @constructor ConnectionContext
	 * @private
	 * @summary Connection context object.
	 * @param {object} cn
	 * @param {} dc
	 * @param {object} options
	 * @param {object} db
	 * @param {number} txLevel
	 */

	function ConnectionContext(cn, dc, options, db, txLevel) {

	    this.cn = cn; // connection details;
	    this.dc = dc; // database context;
	    this.options = options; // library options;
	    this.db = db; // database session;
	    this.txLevel = txLevel; // transaction level;

	    this.connect = function (db) {
	        this.db = db;
	    };

	    this.disconnect = function () {
	        if (this.db) {
	            this.db.done();
	            this.db = null;
	        }
	    };

	    this.clone = function () {
	        return new ConnectionContext(this.cn, this.dc, this.options, this.db, this.txLevel);
	    };
	}

	/**
	 * Connection Context
	 * @module context
	 * @author Vitaly Tomilov
	 * @private
	 */
	module.exports = ConnectionContext;

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    con: __webpack_require__(521).local,
	    main: __webpack_require__(454),
	    utils: __webpack_require__(500)
	};

	/////////////////////////////////
	// Client notification helpers;
	var $events = {

	    /**
	     * @event connect
	     * @description
	     * Global notification of acquiring a new database connection from the connection pool,
	     * i.e. a virtual connection.
	     *
	     * However, for direct calls to method {@link Database.connect} with parameter `{direct: true}`,
	     * this event represents a physical connection.
	     *
	     * The library will suppress any error thrown by the handler and write it into the console.
	     *
	     * @param {external:Client} client
	     * $[pg.Client] object that represents the connection.
	     *
	     * @param {} dc
	     * Database Context that was used when creating the database object (see {@link Database}).
	     *
	     * @param {boolean} isFresh
	     * **Added in v.4.4.4**
	     *
	     * It indicates when it is a fresh physical connection:
	     * - `true` - the physical connection just has been allocated
	     * - `false` - the connection has been used previously
	     *
	     * **NOTE:**
	     *
	     * This parameter is always `true` for direct connections (created by calling {@link Database.connect}
	     * with parameter `{direct: true}`).
	     *
	     * @example
	     *
	     * var options = {
	     *
	     *     // pg-promise initialization options...
	     *
	     *     connect: function (client, dc, isFresh) {
	     *         var cp = client.connectionParameters;
	     *         console.log("Connected to database:", cp.database);
	     *     }
	     *
	     * };
	     */
	    connect: function connect(ctx, client, isFresh) {
	        if (ctx.options.connect instanceof Function) {
	            try {
	                ctx.options.connect(client, ctx.dc, isFresh);
	            } catch (e) {
	                // have to silence errors here;
	                // cannot allow unhandled errors while connecting to the database,
	                // as it will break the connection logic;
	                $events.unexpected('connect', e);
	            }
	        }
	    },

	    /**
	     * @event disconnect
	     * @description
	     * Global notification of releasing a database connection back to the connection pool,
	     * i.e. releasing the virtual connection.
	     *
	     * However, when releasing a direct connection (created by calling {@link Database.connect} with parameter
	     * `{direct: true}`), this event represents a physical disconnection.
	     *
	     * The library will suppress any error thrown by the handler and write it into the console.
	     *
	     * @param {external:Client} client - $[pg.Client] object that represents connection with the database.
	     *
	     * @param {} dc - Database Context that was used when creating the database object (see {@link Database}).
	     *
	     * @example
	     *
	     * var options = {
	     *
	     *     // pg-promise initialization options...
	     *
	     *     disconnect: function(client, dc) {
	     *        var cp = client.connectionParameters;
	     *        console.log("Disconnecting from database:", cp.database);
	     *     }
	     *
	     * };
	     */
	    disconnect: function disconnect(ctx, client) {
	        if (ctx.options.disconnect instanceof Function) {
	            try {
	                ctx.options.disconnect(client, ctx.dc);
	            } catch (e) {
	                // have to silence errors here;
	                // cannot allow unhandled errors while disconnecting from the database,
	                // as it will break the disconnection logic;
	                $events.unexpected('disconnect', e);
	            }
	        }
	    },

	    /**
	     * @event query
	     * @description
	     *
	     * Global notification of a query that's about to execute.
	     *
	     * Notification happens just before the query execution. And if the handler throws an error, the query execution
	     * will be rejected with that error.
	     *
	     * @param {object} e - Event Context Object.
	     *
	     * This is a shared-type object that's passed in with the following events: {@link event:query query},
	     * {@link event:receive receive}, {@link event:error error}, {@link event:task task} and {@link event:transact transact}.
	     *
	     * @param {String|Object} e.cn
	     *
	     * Set only for event {@link event:error error}, and only when the error is connection-related.
	     *
	     * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.
	     *
	     * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection
	     * can be logged safely, without exposing the password.
	     *
	     * @param {} e.dc
	     * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.
	     *
	     * @param {String|Object} e.query
	     *
	     * Query string/object that was passed into the query method. This property is only set during events {@link event:query query}
	     * and {@link event:receive receive}.
	     *
	     * @param {external:Client} e.client
	     *
	     * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}
	     * when it is connection-related.
	     *
	     * @param {} e.params - Formatting parameters for the query.
	     *
	     * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only
	     * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value
	     * to the event logging:
	     * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.
	     * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events
	     * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer
	     * handles the query formatting.
	     *
	     * When this parameter is not set, it means one of the two things:
	     * - there were no parameters passed into the query method;
	     * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.
	     *
	     * @param {object} e.ctx
	     * _Task/Transaction Context_ object. See {@link Task.ctx} for details.
	     *
	     * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events
	     * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when the event occurred
	     * while executing a task or transaction.
	     *
	     */
	    query: function query(options, context) {
	        if (options.query instanceof Function) {
	            try {
	                options.query(context);
	            } catch (e) {
	                // throwing an error during event 'query'
	                // will result in a reject for the request.
	                return e instanceof Error ? e : new $npm.utils.InternalError(e);
	            }
	        }
	    },

	    /**
	     * @event receive
	     * @description
	     * Global notification of any data received from the database, coming from a regular query or from a stream.
	     *
	     * The event is fired before the data reaches the client, and only when receiving 1 or more records.
	     *
	     * This event notification serves two purposes:
	     *  - Providing selective data logging for debugging;
	     *  - Pre-processing data before it reaches the client.
	     *
	     * **NOTES:**
	     * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`
	     *   validation for regular queries, which is executed right after this notification.
	     * - When adding data pre-processing, you should consider possible performance penalty this may bring.
	     * - If the event handler throws an error, the original request will be rejected with that error.
	     *
	     * @param {array} data
	     * A non-empty array of received data objects/rows.
	     *
	     * If any of those objects are modified during notification, the client will receive the modified data.
	     *
	     * @param {object} result
	     * - original $[Result] object, if the data comes from a regular query, in which case `data = result.rows`.
	     * - `undefined` when the data comes from a stream.
	     *
	     * @param {object} e
	     * Event Context Object.
	     *
	     * This type of object is used by several events. See event {@link event:query query} for its complete documentation.
	     *
	     * @example
	     *
	     * // Example below shows the fastest way to camelize column names:
	     *
	     * var options = {
	     *     receive: function (data, result, e) {
	     *         camelizeColumns(data);
	     *     }
	     * };
	     *
	     * function camelizeColumns(data) {
	     *     var template = data[0];
	     *     for (var prop in template) {
	     *         var camel = pgp.utils.camelize(prop);
	     *         if (!(camel in template)) {
	     *             for (var i = 0; i < data.length; i++) {
	     *                 var d = data[i];
	     *                 d[camel] = d[prop];
	     *                 delete d[prop];
	     *             }
	     *         }
	     *     }
	     * }
	     */
	    receive: function receive(options, data, result, context) {
	        if (options.receive instanceof Function) {
	            try {
	                options.receive(data, result, context);
	            } catch (e) {
	                // throwing an error during event 'receive'
	                // will result in a reject for the request.
	                return e instanceof Error ? e : new $npm.utils.InternalError(e);
	            }
	        }
	    },

	    /**
	     * @event task
	     * @description
	     * Global notification of a task start / finish events.
	     *
	     * The library will suppress any error thrown by the handler and write it into the console.
	     *
	     * @param {object} e - Event Context Object.
	     *
	     * This type of object is used by several events. See event {@link event:query query}
	     * for its complete documentation.
	     *
	     * @example
	     *
	     * var options = {
	     *     task: function (e) {
	     *         if (e.ctx.finish) {
	     *             // this is a task->finish event;
	     *             console.log("Finish Time:", e.ctx.finish);
	     *             if (e.ctx.success) {
	     *                 // e.ctx.result = resolved data;
	     *             } else {
	     *                 // e.ctx.result = error/rejection reason;
	     *             }
	     *         } else {
	     *             // this is a task->start event;
	     *             console.log("Start Time:", e.ctx.start);
	     *         }
	     *     }
	     * };
	     *
	     */
	    task: function task(options, context) {
	        if (options.task instanceof Function) {
	            try {
	                options.task(context);
	            } catch (e) {
	                // silencing the error, to avoid breaking the task;
	                $events.unexpected('task', e);
	            }
	        }
	    },

	    /**
	     * @event transact
	     * @description
	     * Global notification of a transaction start / finish events.
	     *
	     * The library will suppress any error thrown by the handler and write it into the console.
	     *
	     * @param {object} e - Event Context Object.
	     *
	     * This type of object is used by several events. See event {@link event:query query}
	     * for its complete documentation.
	     *
	     * @example
	     *
	     * var options = {
	     *     transact: function (e) {
	     *         if (e.ctx.finish) {
	     *             // this is a transaction->finish event;
	     *             console.log("Finish Time:", e.ctx.finish);
	     *             if (e.ctx.success) {
	     *                 // e.ctx.result = resolved data;
	     *             } else {
	     *                 // e.ctx.result = error/rejection reason;
	     *             }
	     *         } else {
	     *             // this is a transaction->start event;
	     *             console.log("Start Time:", e.ctx.start);
	     *         }
	     *     }
	     * };
	     *
	     */
	    transact: function transact(options, context) {
	        if (options.transact instanceof Function) {
	            try {
	                options.transact(context);
	            } catch (e) {
	                // silencing the error, to avoid breaking the transaction;
	                $events.unexpected('transact', e);
	            }
	        }
	    },

	    /**
	     * @event error
	     * @description
	     * Global notification of every error encountered by this library.
	     *
	     * The library will suppress any error thrown by the handler and write it into the console.
	     *
	     * @param {} err
	     * The error encountered, of the same value and type as it was reported.
	     *
	     * @param {object} e
	     * Event Context Object.
	     *
	     * This type of object is used by several events. See event {@link event:query query}
	     * for its complete documentation.
	     *
	     * @example
	     * var options = {
	     *
	     *     // pg-promise initialization options...
	     *
	     *     error: function (err, e) {
	     *
	     *         // e.dc = Database Context
	     *
	     *         if (e.cn) {
	     *             // this is a connection-related error
	     *             // cn = safe connection details passed into the library:
	     *             //      if password is present, it is masked by #
	     *         }
	     *
	     *         if (e.query) {
	     *             // query string is available
	     *             if (e.params) {
	     *                 // query parameters are available
	     *             }
	     *         }
	     *
	     *         if (e.ctx) {
	     *             // occurred inside a task or transaction
	     *         }
	     *       }
	     *
	     * };
	     *
	     */
	    error: function error(options, err, context) {
	        if (options.error instanceof Function) {
	            try {
	                options.error(err, context);
	            } catch (e) {
	                // have to silence errors here;
	                // throwing unhandled errors while handling an error
	                // notification is simply not acceptable.
	                $events.unexpected('error', e);
	            }
	        }
	    },

	    /**
	     * @event extend
	     * @description
	     * Extends database protocol with custom methods and properties.
	     *
	     * Override this event to extend the existing access layer with your own functions and
	     * properties best suited for your application.
	     *
	     * The extension thus becomes available across all access layers:
	     *
	     * - Within the root/default database protocol;
	     * - Inside transactions, including nested ones;
	     * - Inside tasks, including nested ones.
	     *
	     * All pre-defined methods and properties are read-only, so you will get an error,
	     * if you try overriding them.
	     *
	     * The library will suppress any error thrown by the handler and write it into the console.
	     *
	     * @param {object} obj - Protocol object to be extended.
	     *
	     * @param {} dc - Database Context that was used when creating the database object.
	     *
	     * @example
	     *
	     * // In the example below we extend the protocol with function `addImage`
	     * // that will insert one binary image and resolve with the new record id.
	     *
	     * var options = {
	     *     extend: function (obj, dc) {
	     *         // obj = this;
	     *         // dc = database context;
	     *         obj.addImage = function (data) {
	     *             return obj.one("insert into images(data) values($1) returning id", '\\x' + data);
	     *         }
	     *     }
	     * };
	     *
	     * @example
	     *
	     * // It is best to extend the protocol by adding whole entity repositories to it
	     * // as shown in the following example.
	     *
	     * // Users repository;
	     * function repUsers(obj, dc) {
	     *     // NOTE: You can change the implementation based on `dc`;
	     *     return {
	     *         add: function (name, active) {
	     *             return obj.none("insert into users values($1, $2)", [name, active]);
	     *         },
	     *         delete: function (id) {
	     *             return obj.none("delete from users where id = $1", id);
	     *         }
	     *     }
	     * }
	     *
	     * // Overriding 'extend' event;
	     * var options = {
	     *     extend: function (obj, dc) {
	     *         // obj = this;
	     *         // dc = database context;
	     *         this.users = repUsers(this, dc);
	     *         // You can set different repositories based on `dc`
	     *     }
	     * };
	     *
	     * // Usage example:
	     * db.users.add("John", true)
	     *     .then(function () {
	     *         // user added successfully;
	     *     })
	     *     .catch(function (error) {
	     *         // failed to add the user;
	     *     });
	     *
	     */
	    extend: function extend(options, obj, dc) {
	        if (options.extend instanceof Function) {
	            try {
	                options.extend.call(obj, obj, dc);
	            } catch (e) {
	                // have to silence errors here;
	                // the result of throwing unhandled errors while
	                // extending the protocol would be unpredictable.
	                $events.unexpected('extend', e);
	            }
	        }
	    },

	    /**
	     * @event unexpected
	     * @param {string} event - unhandled event name.
	     * @param {String|Error} e - unhandled error.
	     * @private
	     */
	    unexpected: function unexpected(event, e) {
	        // If you should ever get here, your app is definitely broken, and you need to fix
	        // your event handler to prevent unhandled errors during event notifications.
	        //
	        // Console output is suppressed when running tests, to avoid polluting test output
	        // with error messages that are intentional and of no value to the test.

	        /* istanbul ignore if */
	        if (!$npm.main.suppressErrors) {
	            var stack = e instanceof Error ? e.stack : new Error().stack;
	            $npm.con.error("Unexpected error in '%s' event handler.\n%s\n", event, stack);
	        }
	    }
	};

	module.exports = $events;

/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    con: __webpack_require__(521).local,
	    utils: __webpack_require__(500),
	    events: __webpack_require__(525)
	};

	function poolConnect(ctx, config) {
	    return config.promise(function (resolve, reject) {
	        config.pgp.pg.connect(ctx.cn, function (err, client, _done) {
	            if (err) {
	                $npm.events.error(ctx.options, err, {
	                    cn: $npm.utils.getSafeConnection(ctx.cn),
	                    dc: ctx.dc
	                });
	                reject(err);
	            } else {
	                var isFresh = !client.$used;
	                if (isFresh) {
	                    $npm.utils.addReadProp(client, '$used', true, true);
	                }
	                setCtx(client, ctx);
	                var end = lockClientEnd(client);
	                resolve({
	                    isFresh: isFresh,
	                    client: client,
	                    done: function done() {
	                        client.end = end;
	                        _done();
	                        $npm.events.disconnect(ctx, client);
	                    }
	                });
	                $npm.events.connect(ctx, client, isFresh);
	            }
	        });
	    });
	}

	function directConnect(ctx, config) {
	    return config.promise(function (resolve, reject) {
	        var client = new config.pgp.pg.Client(ctx.cn);
	        client.connect(function (err) {
	            if (err) {
	                $npm.events.error(ctx.options, err, {
	                    cn: $npm.utils.getSafeConnection(ctx.cn),
	                    dc: ctx.dc
	                });
	                reject(err);
	            } else {
	                setCtx(client, ctx);
	                var end = lockClientEnd(client);
	                resolve({
	                    isFresh: true,
	                    client: client,
	                    done: function done() {
	                        client.end = end;
	                        client.end();
	                        $npm.events.disconnect(ctx, client);
	                    }
	                });
	                $npm.events.connect(ctx, client, true);
	            }
	        });
	    });
	}

	function lockClientEnd(client) {
	    var end = client.end;
	    client.end = function () {
	        // This call can happen only in the following two cases:
	        // 1. the client made the call directly, against the library's documentation (invalid code)
	        // 2. connection with the server broke while under heavy communications, and the connection
	        //    pool is trying to terminate all clients forcefully.
	        $npm.con.error("Abnormal client.end() call, due to invalid code or failed server connection.\n%s\n", $npm.utils.getLocalStack(3));
	        end.call(client);
	    };
	    return end;
	}

	function setCtx(client, ctx) {
	    Object.defineProperty(client, '$ctx', {
	        value: ctx,
	        writable: true
	    });
	}

	module.exports = function (config) {
	    return {
	        pool: function pool(ctx) {
	            return poolConnect(ctx, config);
	        },
	        direct: function direct(ctx) {
	            return directConnect(ctx, config);
	        }
	    };
	};

/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    utils: __webpack_require__(500),
	    special: __webpack_require__(523),
	    queryFile: __webpack_require__(506),
	    formatting: __webpack_require__(496),
	    result: __webpack_require__(494),
	    errors: __webpack_require__(508),
	    events: __webpack_require__(525),
	    stream: __webpack_require__(528),
	    types: __webpack_require__(517)
	};

	var QueryResultError = $npm.errors.QueryResultError,
	    InternalError = $npm.utils.InternalError,
	    ExternalQuery = $npm.types.ExternalQuery,
	    PreparedStatement = $npm.types.PreparedStatement,
	    ParameterizedQuery = $npm.types.ParameterizedQuery,
	    SpecialQuery = $npm.special.SpecialQuery,
	    qrec = $npm.errors.queryResultErrorCode;

	var badMask = $npm.result.one | $npm.result.many; // the combination isn't supported;

	//////////////////////////////
	// Generic query method;
	function $query(ctx, query, values, qrm, config) {

	    var isResult,
	        $p = config.promise;

	    if (qrm instanceof SpecialQuery) {
	        if (qrm.isStream) {
	            return $npm.stream.call(this, ctx, query, values, config);
	        }
	        isResult = qrm.isResult;
	    }

	    var error,
	        isFunc,
	        opt = ctx.options,
	        pgFormatting = opt.pgFormatting,
	        capSQL = opt.capSQL,
	        params = pgFormatting ? values : undefined;

	    if (!query) {
	        error = new TypeError("Empty or undefined query.");
	    }

	    if (!error && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
	        if (query instanceof $npm.queryFile) {
	            query.prepare();
	            if (query.error) {
	                error = query.error;
	                query = query.file;
	            } else {
	                query = query.query;
	            }
	        } else {
	            if ('funcName' in query) {
	                isFunc = true;
	                query = query.funcName; // query is a function name;
	            } else {
	                if (query instanceof ExternalQuery) {
	                    pgFormatting = true;
	                } else {
	                    if ('name' in query) {
	                        query = new PreparedStatement(query);
	                        pgFormatting = true;
	                    } else {
	                        if ('text' in query) {
	                            query = new ParameterizedQuery(query);
	                            pgFormatting = true;
	                        }
	                    }
	                }
	                if (query instanceof ExternalQuery && !$npm.utils.isNull(values)) {
	                    query.values = values;
	                }
	            }
	        }
	    }

	    if (!error) {
	        if (!pgFormatting && !$npm.utils.isText(query)) {
	            error = new TypeError(isFunc ? "Invalid function name." : "Invalid query format.");
	        }
	        if (query instanceof ExternalQuery) {
	            var qp = query.parse();
	            if (qp instanceof Error) {
	                error = qp;
	            } else {
	                query = qp;
	            }
	        }
	    }

	    if (!error && !isResult) {
	        if ($npm.utils.isNull(qrm)) {
	            qrm = $npm.result.any; // default query result;
	        } else {
	            if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {
	                error = new TypeError("Invalid Query Result Mask specified.");
	            }
	        }
	    }

	    if (!error && (!pgFormatting || isFunc)) {
	        try {
	            // use 'pg-promise' implementation of values formatting;
	            if (isFunc) {
	                query = $npm.formatting.formatFunction(query, values, capSQL);
	            } else {
	                query = $npm.formatting.formatQuery(query, values);
	            }
	        } catch (e) {
	            if (isFunc) {
	                var prefix = capSQL ? 'SELECT * FROM' : 'select * from';
	                query = prefix + ' ' + query + '(...)';
	            }
	            error = e instanceof Error ? e : new $npm.utils.InternalError(e);
	            params = values;
	        }
	    }

	    return $p(function (resolve, reject) {

	        if (notifyReject()) {
	            return;
	        }
	        error = $npm.events.query(opt, getContext());
	        if (notifyReject()) {
	            return;
	        }
	        var start = Date.now();
	        try {
	            ctx.db.client.query(query, params, function (err, result) {
	                var data;
	                if (!err) {
	                    $npm.utils.addReadProp(result, 'duration', Date.now() - start);
	                    $npm.utils.addReadProp(result.rows, 'duration', result.duration, true);
	                    if (result.rows.length) {
	                        err = $npm.events.receive(opt, result.rows, result, getContext());
	                        err = err || error;
	                    }
	                }
	                if (err) {
	                    error = err;
	                } else {
	                    if (isResult) {
	                        data = result; // raw object requested (Result type);
	                    } else {
	                        data = result.rows;
	                        var len = data.length;
	                        if (len) {
	                            if (len > 1 && qrm & $npm.result.one) {
	                                // one row was expected, but returned multiple;
	                                error = new QueryResultError(qrec.multiple, result, query, params);
	                            } else {
	                                if (!(qrm & ($npm.result.one | $npm.result.many))) {
	                                    // no data should have been returned;
	                                    error = new QueryResultError(qrec.notEmpty, result, query, params);
	                                } else {
	                                    if (!(qrm & $npm.result.many)) {
	                                        data = data[0];
	                                    }
	                                }
	                            }
	                        } else {
	                            // no data returned;
	                            if (qrm & $npm.result.none) {
	                                if (qrm & $npm.result.one) {
	                                    data = null;
	                                } else {
	                                    data = qrm & $npm.result.many ? data : null;
	                                }
	                            } else {
	                                error = new QueryResultError(qrec.noData, result, query, params);
	                            }
	                        }
	                    }
	                }
	                if (!notifyReject()) {
	                    resolve(data);
	                }
	            });
	        } catch (e) {
	            // this can only happen as a result of an internal failure within node-postgres,
	            // like during a sudden loss of communications, which is impossible to reproduce
	            // automatically, so removing it from the test coverage:
	            // istanbul ignore next
	            error = e;
	        }

	        function getContext() {
	            var client;
	            if (ctx.db) {
	                client = ctx.db.client;
	            } else {
	                error = new Error("Loose request outside an expired connection.");
	            }
	            return {
	                client: client,
	                dc: ctx.dc,
	                query: query,
	                params: params,
	                ctx: ctx.ctx
	            };
	        }

	        notifyReject();

	        function notifyReject() {
	            var context = getContext();
	            if (error) {
	                if (error instanceof InternalError) {
	                    error = error.error;
	                }
	                $npm.events.error(opt, error, context);
	                reject(error);
	                return true;
	            }
	        }
	    });
	}

	module.exports = function (config) {
	    return function (ctx, query, values, qrm) {
	        return $query.call(this, ctx, query, values, qrm, config);
	    };
	};

/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    events: __webpack_require__(525),
	    utils: __webpack_require__(500)
	};

	////////////////////////////////////////////
	// Streams query data into any destination,
	// with the help of pg-query-stream library.
	function $stream(ctx, qs, initCB, config) {

	    var $p = config.promise;

	    // istanbul ignore next:
	    // we do not provide code coverage for the Native Bindings specifics
	    if (ctx.options.pgNative) {
	        return $p.reject(new Error("Streaming doesn't work with Native Bindings."));
	    }
	    if (!$npm.utils.isObject(qs, ['state', '_reading'])) {
	        // stream object wasn't passed in correctly;
	        return $p.reject(new TypeError("Invalid or missing stream object."));
	    }
	    if (qs._reading || qs.state !== 'initialized') {
	        // stream object is in the wrong state;
	        return $p.reject(new Error("Invalid stream state."));
	    }
	    if (typeof initCB !== 'function') {
	        // parameter `initCB` must be passed as the initialization callback;
	        return $p.reject(new TypeError("Invalid or missing stream initialization callback."));
	    }
	    var error = $npm.events.query(ctx.options, getContext());
	    if (error) {
	        error = getError(error);
	        $npm.events.error(ctx.options, error, getContext());
	        return $p.reject(error);
	    }
	    var stream,
	        fetch,
	        start,
	        nRows = 0;
	    try {
	        stream = ctx.db.client.query(qs);
	        fetch = stream._fetch;
	        stream._fetch = function (size, func) {
	            fetch.call(stream, size, function (err, rows) {
	                if (!err && rows.length) {
	                    nRows += rows.length;
	                    var context = getContext();
	                    if (!error) {
	                        error = $npm.events.receive(ctx.options, rows, undefined, context);
	                    }
	                    if (error) {
	                        stream.close();
	                    }
	                }
	                return func(err, rows);
	            });
	        };
	        start = Date.now();
	        initCB.call(this, stream); // the stream must be initialized during the call;
	    } catch (err) {
	        error = err;
	    }
	    if (error) {
	        // error thrown by initCB();
	        stream._fetch = fetch;
	        error = getError(error);
	        $npm.events.error(ctx.options, error, getContext());
	        return $p.reject(error);
	    }
	    return $p(function (resolve, reject) {
	        stream.once('end', function () {
	            stream._fetch = fetch;
	            if (error) {
	                onError(error);
	            } else {
	                resolve({
	                    processed: nRows, // total number of rows processed;
	                    duration: Date.now() - start // duration, in milliseconds;
	                });
	            }
	        });
	        stream.once('error', function (err) {
	            stream._fetch = fetch;
	            onError(err);
	        });
	        function onError(e) {
	            e = getError(e);
	            $npm.events.error(ctx.options, e, getContext());
	            reject(e);
	        }
	    });

	    function getError(e) {
	        return e instanceof $npm.utils.InternalError ? e.error : e;
	    }

	    function getContext() {
	        var client;
	        if (ctx.db) {
	            client = ctx.db.client;
	        } else {
	            error = new Error("Loose request outside an expired connection.");
	        }
	        return {
	            client: client,
	            dc: ctx.dc,
	            query: qs.text,
	            params: qs.values,
	            ctx: ctx.ctx
	        };
	    }
	}

	module.exports = $stream;

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    spex: __webpack_require__(530),
	    utils: __webpack_require__(500),
	    mode: __webpack_require__(516),
	    events: __webpack_require__(525),
	    query: __webpack_require__(527),
	    async: __webpack_require__(543)
	};

	/**
	 * @interface Task
	 * @extends Database
	 * @description
	 * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.
	 * The type isn't available directly, it can only be created via methods {@link Database.task} and {@link Database.tx}.
	 *
	 * When executing more than one request at a time, one should allocate and release the connection only once,
	 * while executing all the required queries within the same connection session. More importantly, a transaction
	 * can only work within a single connection.
	 *
	 * This is an interface for tasks/transactions to implement a connection session, during which you can
	 * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.
	 *
	 * @see
	 * {@link Task.ctx ctx},
	 * {@link Task.batch batch},
	 * {@link Task.sequence sequence},
	 * {@link Task.page page}
	 *
	 * @example
	 * db.task(function (t) {
	 *       // this = t = task protocol context;
	 *       // this.ctx = task config + state context;
	 *       return t.one("select * from users where id=$1", 123)
	 *           .then(function (user) {
	 *               return t.any("select * from events where login=$1", user.name);
	 *           });
	 *   })
	 * .then(function (events) {
	 *       // success;
	 *   })
	 * .catch(function (error) {
	 *       // error;
	 *   });
	 *
	 */
	function Task(ctx, tag, isTX, config) {

	    /**
	     * @member {object} Task.ctx
	     * @description
	     * Task/Transaction Context object - contains individual properties for each task/transaction.
	     *
	     * ```js
	     * db.task(t => {
	     *    // t.ctx = task context object
	     * });
	     * ```
	     *
	     * ```js
	     * db.tx(t => {
	     *    // t.ctx = transaction context object
	     * });
	     * ```
	     *
	     * Properties `context`, `dc`, `isTX`, `tag`, `start` and `isFresh` are set before the callback,
	     * while properties `finish`, `success` and `result` are set after the callback has returned.
	     *
	     *
	     * @property {object} context
	     * If the operation was invoked with an object context - `task.call(obj,...)` or
	     * `tx.call(obj,...)`, this property is set with the context object that was passed in.
	     *
	     * @property {} dc
	     * _Database Context_ that was used when creating the database object. See {@link Database}.
	     *
	     * @property {boolean} isTX
	     * Indicates whether this task represents a transaction.
	     *
	     * @property {} tag
	     * Tag value as it was passed into the task. See methods {@link Database.task task} and {@link Database.tx tx}.
	     *
	     * @property {date} start
	     * Date/Time of when this task or transaction started the execution.
	     *
	     * @property {boolean} isFresh
	     * **Added in v.4.6.5**
	     *
	     * Indicates when a fresh physical connection is being used.
	     *
	     * @property {date} finish
	     * Data/Time of when the operation has finished.
	     *
	     * @property {boolean} success
	     * Once the operation has finished, this property indicates whether it was successful.
	     *
	     * @property {} result
	     * Once the operation has finished, this property contains the result, depending on property `success`:
	     * - data resolved by the operation, if `success` = `true`
	     * - error / rejection reason, if `success` = `false`
	     *
	     * @see event {@link event:query query}
	     */
	    this.ctx = ctx.ctx = {}; // task context object;

	    $npm.utils.addReadProp(this.ctx, 'isTX', isTX);

	    if ('context' in ctx) {
	        $npm.utils.addReadProp(this.ctx, 'context', ctx.context);
	    }

	    $npm.utils.addReadProp(this.ctx, 'tag', tag);
	    $npm.utils.addReadProp(this.ctx, 'dc', ctx.dc);

	    // generic query method;
	    this.query = function (query, values, qrm) {
	        if (!ctx.db) {
	            throw new Error("Unexpected call outside of " + (isTX ? "transaction." : "task."));
	        }
	        return config.$npm.query.call(this, ctx, query, values, qrm);
	    };

	    /**
	     * @method Task.batch
	     * @description
	     * **Alternative Syntax:** `batch(values, {cb})` &#8658; `Promise`
	     *
	     * Settles a predefined array of mixed values by redirecting to method $[spex.batch].
	     *
	     * For complete method documentation see $[spex.batch].
	     * @param {array} values
	     * @param {function} [cb]
	     * @returns {external:Promise}
	     */
	    this.batch = function (values, cb) {
	        return config.$npm.spex.batch.call(this, values, cb);
	    };

	    /**
	     * @method Task.page
	     * @description
	     * **Alternative Syntax:** `page(source, {dest, limit})` &#8658; `Promise`
	     *
	     * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].
	     *
	     * For complete method documentation see $[spex.page].
	     * @param {function} source
	     * @param {function} [dest]
	     * @param {number} [limit=0]
	     * @returns {external:Promise}
	     */
	    this.page = function (source, dest, limit) {
	        return config.$npm.spex.page.call(this, source, dest, limit);
	    };

	    /**
	     * @method Task.sequence
	     * @description
	     * **Alternative Syntax:** `sequence(source, {dest, limit, track})` &#8658; `Promise`
	     *
	     * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].
	     *
	     * For complete method documentation see $[spex.sequence].
	     * @param {function} source
	     * @param {function} [dest]
	     * @param {number} [limit=0]
	     * @param {boolean} [track=false]
	     * @returns {external:Promise}
	     */
	    this.sequence = function (source, dest, limit, track) {
	        return config.$npm.spex.sequence.call(this, source, dest, limit, track);
	    };
	}

	//////////////////////////
	// Executes a task;
	Task.exec = function (ctx, obj, isTX, config) {

	    var $p = config.promise;

	    // callback invocation helper;
	    function callback() {
	        var result,
	            cb = ctx.cb;
	        if (cb.constructor.name === 'GeneratorFunction') {
	            cb = config.$npm.async(cb);
	        }
	        try {
	            result = cb.call(obj, obj); // invoking the callback function;
	        } catch (err) {
	            $npm.events.error(ctx.options, err, {
	                client: ctx.db.client,
	                dc: ctx.dc,
	                ctx: ctx.ctx
	            });
	            return $p.reject(err); // reject with the error;
	        }
	        if (result && result.then instanceof Function) {
	            return result; // result is a valid promise object;
	        }
	        return $p.resolve(result);
	    }

	    // updates the task context and notifies the client;
	    function update(start, success, result) {
	        var c = ctx.ctx;
	        if (start) {
	            $npm.utils.addReadProp(c, 'start', new Date());
	        } else {
	            c.finish = new Date();
	            c.success = success;
	            c.result = result;
	            $npm.utils.lock(c, true);
	        }
	        (isTX ? $npm.events.transact : $npm.events.task)(ctx.options, {
	            client: ctx.db.client,
	            dc: ctx.dc,
	            ctx: c
	        });
	    }

	    var cbData,
	        cbReason,
	        success,
	        spName,
	        // Save-Point Name;
	    capSQL = ctx.options.capSQL; // capitalize sql;

	    update(true);

	    if (isTX) {
	        // executing a transaction;
	        spName = "level_" + ctx.txLevel;
	        return begin().then(function () {
	            return callback().then(function (data) {
	                cbData = data; // save callback data;
	                success = true;
	                return commit();
	            }, function (reason) {
	                cbReason = reason; // save callback failure reason;
	                return rollback();
	            }).then(function () {
	                if (success) {
	                    update(false, true, cbData);
	                    return cbData;
	                } else {
	                    update(false, false, cbReason);
	                    return $p.reject(cbReason);
	                }
	            },
	            // istanbul ignore next: either `commit` or `rollback` has failed, which is
	            // impossible to replicate in a test environment, so skipping from the test;
	            function (reason) {
	                update(false, false, reason);
	                return $p.reject(reason);
	            });
	        },
	        // istanbul ignore next: `begin` has failed, which is impossible
	        // to replicate in a test environment, so skipping from the test;
	        function (reason) {
	            update(false, false, reason);
	            return $p.reject(reason);
	        });
	    }

	    function begin() {
	        if (!ctx.txLevel && ctx.cb.txMode instanceof $npm.mode.TransactionMode) {
	            return exec(ctx.cb.txMode.begin(capSQL), 'savepoint');
	        }
	        return exec('begin', 'savepoint');
	    }

	    function commit() {
	        return exec('commit', 'release savepoint');
	    }

	    function rollback() {
	        return exec('rollback', 'rollback to savepoint');
	    }

	    function exec(top, nested) {
	        if (ctx.txLevel) {
	            return obj.none((capSQL ? nested.toUpperCase() : nested) + ' ' + spName);
	        }
	        return obj.none(capSQL ? top.toUpperCase() : top);
	    }

	    // executing a task;
	    return callback().then(function (data) {
	        update(false, true, data);
	        return data;
	    }).catch(function (error) {
	        update(false, false, error);
	        return $p.reject(error);
	    });
	};

	module.exports = function (config) {
	    var npm = config.$npm;

	    // istanbul ignore next:
	    // we keep 'npm.query' initialization here, even though it is always
	    // pre-initialized by the 'database' module, for integrity purpose. 
	    npm.query = npm.query || $npm.query(config);

	    npm.async = npm.async || $npm.async(config);
	    npm.spex = npm.spex || $npm.spex(config.promiseLib);
	    return Task;
	};

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var $npm = {
	    utils: __webpack_require__(531),
	    batch: __webpack_require__(533),
	    page: __webpack_require__(535),
	    sequence: __webpack_require__(537),
	    stream: __webpack_require__(539),
	    errors: __webpack_require__(541)
	};

	/**
	 * @module spex
	 * @summary Specialized Promise Extensions
	 * @author Vitaly Tomilov
	 *
	 * @description
	 * Attaches to an external promise library and provides additional methods built solely
	 * on the basic promise operations:
	 *  - construct a new promise with a callback function
	 *  - resolve a promise with some result data
	 *  - reject a promise with a reason
	 *
	 * ### usage
	 * For any third-party promise library:
	 * ```js
	 * var promise = require('bluebird');
	 * var spex = require('spex')(promise);
	 * ```
	 * For ES6 promises:
	 * ```js
	 * var spex = require('spex')(Promise);
	 * ```
	 *
	 * @param {Object|Function} promiseLib
	 * Instance of a promise library to be used by this module.
	 *
	 * Some implementations use `Promise` constructor to create a new promise, while
	 * others use the module's function for it. Both types are supported the same.
	 *
	 * Alternatively, an object of type {@link PromiseAdapter} can be passed in, which provides
	 * compatibility with any promise library outside of the standard.
	 *
	 * Passing in a promise library that cannot be recognized will throw
	 * `Invalid promise library specified.`
	 *
	 * @returns {Object}
	 * Namespace with all supported methods.
	 *
	 * @see {@link PromiseAdapter}, {@link batch}, {@link page}, {@link sequence}, {@link stream}
	 */
	function main(promiseLib) {

	    var spex = {},
	        // library instance;
	    promise = parsePromiseLib(promiseLib); // promise library parsing;

	    var config = {
	        spex: spex,
	        promise: promise,
	        utils: $npm.utils(promise)
	    };

	    spex.errors = $npm.errors;
	    spex.batch = $npm.batch(config);
	    spex.page = $npm.page(config);
	    spex.sequence = $npm.sequence(config);
	    spex.stream = $npm.stream(config);

	    config.utils.extend(spex, '$p', promise);

	    Object.freeze(spex);

	    return spex;
	}

	//////////////////////////////////////////
	// Parses and validates a promise library;
	function parsePromiseLib(lib) {
	    if (lib) {
	        var promise;
	        if (lib instanceof main.PromiseAdapter) {
	            promise = function promise(func) {
	                return lib.create(func);
	            };
	            promise.resolve = lib.resolve;
	            promise.reject = lib.reject;
	            return promise;
	        }
	        var t = typeof lib === 'undefined' ? 'undefined' : _typeof(lib);
	        if (t === 'function' || t === 'object') {
	            var root = lib.Promise instanceof Function ? lib.Promise : lib;
	            promise = function promise(func) {
	                return new root(func);
	            };
	            promise.resolve = root.resolve;
	            promise.reject = root.reject;
	            if (promise.resolve instanceof Function && promise.reject instanceof Function) {
	                return promise;
	            }
	        }
	    }
	    throw new TypeError("Invalid promise library specified.");
	}

	main.PromiseAdapter = __webpack_require__(542);
	Object.freeze(main);

	module.exports = main;

	/**
	 * @external Error
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
	 */

	/**
	 * @external TypeError
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError
	 */

	/**
	 * @external Promise
	 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
	 */

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var stat = __webpack_require__(532);

	module.exports = function ($p) {

	    var exp = {
	        formatError: stat.formatError,
	        isPromise: stat.isPromise,
	        isReadableStream: stat.isReadableStream,
	        messageGap: stat.messageGap,
	        extend: stat.extend,
	        resolve: resolve,
	        wrap: wrap
	    };

	    return exp;

	    //////////////////////////////////////////
	    // Checks if the function is a generator,
	    // and if so - wraps it up into a promise;
	    function wrap(func) {
	        if (func instanceof Function) {
	            if (func.constructor.name === 'GeneratorFunction') {
	                return asyncAdapter(func);
	            }
	            return func;
	        }
	        return null;
	    }

	    /////////////////////////////////////////////////////
	    // Resolves a mixed value into the actual value,
	    // consistent with the way mixed values are defined:
	    // https://github.com/vitaly-t/spex/wiki/Mixed-Values
	    function resolve(value, params, onSuccess, onError) {

	        var self = this,
	            delayed = false;

	        function loop() {
	            while (value instanceof Function) {
	                if (value.constructor.name === 'GeneratorFunction') {
	                    value = asyncAdapter(value);
	                }
	                try {
	                    value = params ? value.apply(self, params) : value.call(self);
	                } catch (e) {
	                    onError(e, false); // false means 'threw an error'
	                    return;
	                }
	            }
	            if (exp.isPromise(value)) {
	                value.then(function (data) {
	                    delayed = true;
	                    value = data;
	                    loop();
	                    return null; // this dummy return is just to prevent Bluebird warnings;
	                }).catch(function (error) {
	                    onError(error, true); // true means 'rejected'
	                });
	            } else {
	                onSuccess(value, delayed);
	            }
	        }

	        loop();
	    }

	    // Generator-to-Promise adapter;
	    // Based on: https://www.promisejs.org/generators/#both
	    function asyncAdapter(generator) {
	        return function () {
	            var g = generator.apply(this, arguments);

	            function handle(result) {
	                if (result.done) {
	                    return $p.resolve(result.value);
	                }
	                return $p.resolve(result.value).then(function (res) {
	                    return handle(g.next(res));
	                }, function (err) {
	                    return handle(g.throw(err));
	                });
	            }

	            return handle(g.next());
	        };
	    }
	};

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var stream = __webpack_require__(239);
	var util = __webpack_require__(263);

	/////////////////////////////////////
	// Checks if the value is a promise;
	function isPromise(value) {
	    return value && value.then instanceof Function;
	}

	////////////////////////////////////////////
	// Checks object for being a readable stream;

	function isReadableStream(obj) {
	    return obj instanceof stream.Stream && typeof obj._read === 'function' && _typeof(obj._readableState) === 'object';
	}

	////////////////////////////////////////////////////////////
	// Sets an object property as read-only and non-enumerable.
	function extend(obj, name, value) {
	    Object.defineProperty(obj, name, {
	        value: value,
	        configurable: false,
	        enumerable: false,
	        writable: false
	    });
	}

	///////////////////////////////////////////
	// Returns a space gap for console output;
	function messageGap(level) {
	    return Array(1 + level * 4).join(' ');
	}

	function formatError(error, level) {
	    var names = ['BatchError', 'PageError', 'SequenceError'];
	    var msg = util.inspect(error);
	    if (error instanceof Error) {
	        if (names.indexOf(error.name) === -1) {
	            var gap = messageGap(level);
	            msg = msg.split('\n').map(function (line, index) {
	                return (index ? gap : '') + line;
	            }).join('\n');
	        } else {
	            msg = error.toString(level);
	        }
	    }
	    return msg;
	}

	module.exports = {
	    formatError: formatError,
	    isPromise: isPromise,
	    isReadableStream: isReadableStream,
	    messageGap: messageGap,
	    extend: extend
	};

/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var BatchError = __webpack_require__(534);

	/**
	 * @method batch
	 * @description
	 * **Alternative Syntax:**
	 * `batch(values, {cb})` &#8658; `Promise`
	 *
	 * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.
	 *
	 * The method resolves with an array of results, the same as the standard $[promise.all],
	 * while providing comprehensive error details in case of a reject, in the form of
	 * type {@link errors.BatchError BatchError}.
	 *
	 * @param {Array} values
	 * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.
	 *
	 * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =
	 * `Method 'batch' requires an array of values.`
	 *
	 * @param {Function|generator} [cb]
	 * Optional callback (or generator) to receive the result for each settled value.
	 *
	 * Callback Parameters:
	 *  - `index` = index of the value in the source array
	 *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)
	 *  - `result` = resolved data, if `success`=`true`, or else the rejection reason
	 *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)
	 *
	 * The function inherits `this` context from the calling method.
	 *
	 * It can optionally return a promise to indicate that notifications are handled asynchronously.
	 * And if the returned promise resolves, it signals a successful handling, while any resolved
	 * data is ignored.
	 *
	 * If the function returns a rejected promise or throws an error, the entire method rejects
	 * with {@link errors.BatchError BatchError} where the corresponding value in property `data`
	 * is set to `{success, result, origin}`:
	 *  - `success` = `false`
	 *  - `result` = the rejection reason or the error thrown by the notification callback
	 *  - `origin` = the original data passed into the callback as object `{success, result}`
	 *
	 * @returns {external:Promise}
	 *
	 * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].
	 * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds
	 * spent resolving all the data.
	 *
	 * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:
	 *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}
	 *  - notification callback `cb` returned a rejected promise or threw an error
	 *
	 */
	function batch(values, cb, config) {

	    var $p = config.promise,
	        $utils = config.utils;

	    if (!Array.isArray(values)) {
	        return $p.reject(new TypeError("Method 'batch' requires an array of values."));
	    }

	    if (!values.length) {
	        var empty = [];
	        $utils.extend(empty, 'duration', 0);
	        return $p.resolve(empty);
	    }

	    cb = $utils.wrap(cb);
	    var self = this,
	        start = Date.now();
	    return $p(function (resolve, reject) {
	        var cbTime,
	            errors = [],
	            remaining = values.length,
	            result = new Array(remaining);
	        values.forEach(function (item, i) {
	            $utils.resolve.call(self, item, null, function (data) {
	                result[i] = data;
	                step(i, true, data);
	            }, function (reason) {
	                result[i] = { success: false, result: reason };
	                errors.push(i);
	                step(i, false, reason);
	            });
	        });
	        function step(idx, pass, data) {
	            if (cb) {
	                var cbResult,
	                    cbNow = Date.now(),
	                    cbDelay = idx ? cbNow - cbTime : undefined;
	                cbTime = cbNow;
	                try {
	                    cbResult = cb.call(self, idx, pass, data, cbDelay);
	                } catch (e) {
	                    setError(e);
	                }
	                if ($utils.isPromise(cbResult)) {
	                    cbResult.then(check).catch(function (error) {
	                        setError(error);
	                        check();
	                    });
	                } else {
	                    check();
	                }
	            } else {
	                check();
	            }

	            function setError(e) {
	                var r = pass ? { success: false } : result[idx];
	                if (pass) {
	                    result[idx] = r;
	                    errors.push(idx);
	                }
	                r.result = e;
	                r.origin = { success: pass, result: data };
	            }

	            function check() {
	                if (! --remaining) {
	                    if (errors.length) {
	                        errors.sort();
	                        if (errors.length < result.length) {
	                            for (var i = 0, k = 0; i < result.length; i++) {
	                                if (i === errors[k]) {
	                                    k++;
	                                } else {
	                                    result[i] = { success: true, result: result[i] };
	                                }
	                            }
	                        }
	                        reject(new BatchError(result, errors, Date.now() - start));
	                    } else {
	                        $utils.extend(result, 'duration', Date.now() - start);
	                        resolve(result);
	                    }
	                }
	                return null; // this dummy return is just to prevent Bluebird warnings;
	            }
	        }
	    });
	}

	module.exports = function (config) {
	    return function (values, cb) {
	        if (cb && (typeof cb === 'undefined' ? 'undefined' : _typeof(cb)) === 'object') {
	            return batch.call(this, values, cb.cb, config);
	        } else {
	            return batch.call(this, values, cb, config);
	        }
	    };
	};

/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    u: __webpack_require__(263),
	    os: __webpack_require__(490),
	    utils: __webpack_require__(532)
	};

	/**
	 * @interface errors.BatchError
	 * @augments external:Error
	 * @description
	 * This type represents all errors rejected by method {@link batch}, except for {@link external:TypeError TypeError}
	 * when the method receives invalid input parameters.
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `BatchError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * It represents the message of the first error encountered in the batch, and is a safe
	 * version of using `first.message`.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {array} data
	 * Array of objects `{success, result, [origin]}`:
	 * - `success` = true/false, indicates whether the corresponding value in the input array was resolved.
	 * - `result` = resolved data, if `success`=`true`, or else the rejection reason.
	 * - `origin` - set only when failed as a result of an unsuccessful call into the notification callback
	 *    (parameter `cb` of method {@link batch})
	 *
	 * The array has the same size as the input one that was passed into method {@link batch}, providing direct mapping.
	 *
	 * @property {} stat
	 * Resolution Statistics.
	 *
	 * @property {number} stat.total
	 * Total number of elements in the batch.
	 *
	 * @property {number} stat.succeeded
	 * Number of resolved values in the batch.
	 *
	 * @property {number} stat.failed
	 * Number of rejected values in the batch.
	 *
	 * @property {number} stat.duration
	 * Time in milliseconds it took to settle all values.
	 *
	 * @property {} first
	 * The very first error within the batch, with support for nested batch results, it is also the same error
	 * as $[promise.all] would provide.
	 *
	 * @see {@link batch}
	 *
	 */
	function BatchError(result, errors, duration) {

	    this.data = result;

	    /**
	     * @method errors.BatchError.getErrors
	     * @description
	     * Returns the complete list of errors only.
	     *
	     * It supports nested batch results, presented as a sub-array.
	     *
	     * @returns {array}
	     */
	    this.getErrors = function () {
	        var err = new Array(errors.length);
	        for (var i = 0; i < errors.length; i++) {
	            err[i] = result[errors[i]].result;
	            if (err[i] instanceof BatchError) {
	                err[i] = err[i].getErrors();
	            }
	        }
	        $npm.utils.extend(err, '$isErrorList', true);
	        return err;
	    };

	    var e = this.getErrors(),
	        first = e[0];

	    while (first && first.$isErrorList) {
	        first = first[0];
	    }

	    // we do not show it within the inspect, because when the error
	    // happens for a nested result, the output becomes a mess.
	    this.first = first;

	    if (first instanceof Error) {
	        this.message = first.message;
	    } else {
	        if (typeof first !== 'string') {
	            first = $npm.u.inspect(first);
	        }
	        this.message = first;
	    }

	    this.stat = {
	        total: result.length,
	        succeeded: result.length - e.length,
	        failed: e.length,
	        duration: duration
	    };

	    Error.captureStackTrace(this, BatchError);
	}

	$npm.u.inherits(BatchError, Error);
	BatchError.prototype.name = 'BatchError';

	/**
	 * @method errors.BatchError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * The output is an abbreviated version of the error, because the complete error
	 * is often too much for displaying or even logging, as a batch can be of any size.
	 * Therefore, only errors are rendered from the `data` property, alongside their indexes,
	 * and only up to the first 5, to avoid polluting the screen or the log file.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	BatchError.prototype.toString = function (level) {
	    level = level > 0 ? parseInt(level) : 0;
	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        gap2 = $npm.utils.messageGap(level + 2),
	        lines = ['BatchError {', gap1 + 'stat: { total: ' + this.stat.total + ', succeeded: ' + this.stat.succeeded + ', failed: ' + this.stat.failed + ', duration: ' + this.stat.duration + ' }', gap1 + 'errors: ['];

	    // In order to avoid polluting the error log or the console, 
	    // we limit the log output to the top 5 errors:
	    var counter = 0,
	        maxErrors = 5;
	    this.data.forEach(function (d, index) {
	        if (!d.success && counter < maxErrors) {
	            lines.push(gap2 + index + ': ' + $npm.utils.formatError(d.result, level + 2));
	            counter++;
	        }
	    });
	    lines.push(gap1 + ']');
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	BatchError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = BatchError;

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var PageError = __webpack_require__(536);

	/**
	 * @method page
	 * @description
	 * **Alternative Syntax:**
	 * `page(source, {dest, limit})` &#8658; `Promise`
	 *
	 * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.
	 *
	 * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,
	 * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.
	 *
	 * @param {Function|generator} source
	 * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).
	 * Returning or resolving with `undefined` ends the sequence, and the method resolves.
	 *
	 * The function inherits `this` context from the calling method.
	 *
	 * Parameters:
	 *  - `index` = index of the page being requested
	 *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)
	 *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)
	 *
	 * If the function throws an error or returns a rejected promise, the method rejects with
	 * {@link errors.PageError PageError}, which will have property `source` set.
	 *
	 * And if the function returns or resolves with anything other than an array or `undefined`,
	 * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to
	 * `Unexpected data returned from the source.`
	 *
	 * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`
	 *
	 * @param {Function|generator} [dest]
	 * Optional destination function (or generator), to receive a resolved {@link batch} of data
	 * for each page, process it and respond as required.
	 *
	 * Parameters:
	 *  - `index` = page index in the sequence
	 *  - `data` = page data resolved as a {@link batch}
	 *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)
	 *
	 * The function inherits `this` context from the calling method.
	 *
	 * It can optionally return a promise object, if notifications are handled asynchronously.
	 * And if a promise is returned, the method will not request another page from the `source`
	 * function until the promise has been resolved.
	 *
	 * If the function throws an error or returns a rejected promise, the sequence terminates,
	 * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.
	 *
	 * @param {Number} [limit=0]
	 * Limits the maximum number of pages to be requested from the `source`. If the value is greater
	 * than 0, the method will successfully resolve once the specified limit has been reached.
	 *
	 * When `limit` isn't specified (default), the sequence is unlimited, and it will continue
	 * till one of the following occurs:
	 *  - `source` returns or resolves with `undefined` or an invalid value (non-array)
	 *  - either `source` or `dest` functions throw an error or return a rejected promise
	 *
	 * @returns {external:Promise}
	 *
	 * When successful, the method resolves with object `{pages, total, duration}`:
	 *  - `pages` = number of pages resolved
	 *  - `total` = the sum of all page sizes (total number of values resolved)
	 *  - `duration` = number of milliseconds consumed by the method
	 *
	 * When the method fails, it rejects with {@link errors.PageError PageError}.
	 *
	 */
	function page(source, dest, limit, config) {

	    var $p = config.promise,
	        $spex = config.spex,
	        $utils = config.utils;

	    if (typeof source !== 'function') {
	        return $p.reject(new TypeError("Parameter 'source' must be a function."));
	    }

	    limit = limit > 0 ? parseInt(limit) : 0;
	    source = $utils.wrap(source);
	    dest = $utils.wrap(dest);

	    var self = this,
	        request,
	        srcTime,
	        destTime,
	        start = Date.now(),
	        total = 0;

	    return $p(function (resolve, reject) {

	        function loop(idx) {
	            var srcNow = Date.now(),
	                srcDelay = idx ? srcNow - srcTime : undefined;
	            srcTime = srcNow;
	            $utils.resolve.call(self, source, [idx, request, srcDelay], function (value) {
	                if (value === undefined) {
	                    success();
	                } else {
	                    if (value instanceof Array) {
	                        $spex.batch(value).then(function (data) {
	                            request = data;
	                            total += data.length;
	                            if (dest) {
	                                var destResult,
	                                    destNow = Date.now(),
	                                    destDelay = idx ? destNow - destTime : undefined;
	                                destTime = destNow;
	                                try {
	                                    destResult = dest.call(self, idx, data, destDelay);
	                                } catch (err) {
	                                    fail({
	                                        error: err,
	                                        dest: data
	                                    }, 4, dest.name);
	                                    return;
	                                }
	                                if ($utils.isPromise(destResult)) {
	                                    destResult.then(next).catch(function (error) {
	                                        fail({
	                                            error: error,
	                                            dest: data
	                                        }, 3, dest.name);
	                                    });
	                                } else {
	                                    next();
	                                }
	                            } else {
	                                next();
	                            }
	                            return null; // this dummy return is just to prevent Bluebird warnings;
	                        }).catch(function (error) {
	                            fail({
	                                error: error
	                            }, 0);
	                        });
	                    } else {
	                        fail({
	                            error: new Error("Unexpected data returned from the source."),
	                            source: request
	                        }, 5, source.name);
	                    }
	                }
	            }, function (reason, isRej) {
	                fail({
	                    error: reason,
	                    source: request
	                }, isRej ? 1 : 2, source.name);
	            });

	            function next() {
	                if (limit === ++idx) {
	                    success();
	                } else {
	                    loop(idx);
	                }
	                return null; // this dummy return is just to prevent Bluebird warnings;
	            }

	            function success() {
	                resolve({
	                    pages: idx,
	                    total: total,
	                    duration: Date.now() - start
	                });
	            }

	            function fail(reason, code, cbName) {
	                reason.index = idx;
	                reject(new PageError(reason, code, cbName, Date.now() - start));
	            }
	        }

	        loop(0);
	    });
	}

	module.exports = function (config) {
	    return function (source, dest, limit) {
	        if (dest && (typeof dest === 'undefined' ? 'undefined' : _typeof(dest)) === 'object') {
	            return page.call(this, source, dest.dest, dest.limit, config);
	        } else {
	            return page.call(this, source, dest, limit, config);
	        }
	    };
	};

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    u: __webpack_require__(263),
	    os: __webpack_require__(490),
	    utils: __webpack_require__(532)
	};

	var errorReasons = {
	    0: "Page with index %d rejected.",
	    1: "Source %s returned a rejection at index %d.",
	    2: "Source %s threw an error at index %d.",
	    3: "Destination %s returned a rejection at index %d.",
	    4: "Destination %s threw an error at index %d.",
	    5: "Source %s returned a non-array value at index %d."
	};

	/**
	 * @interface errors.PageError
	 * @augments external:Error
	 * @description
	 * This type represents all errors rejected by method {@link page}, except for {@link external:TypeError TypeError}
	 * when the method receives invalid input parameters.
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `PageError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {} error
	 * The error that was thrown, or the rejection reason.
	 *
	 * @property {number} index
	 * Index of the element in the sequence for which the error/rejection occurred.
	 *
	 * @property {number} duration
	 * Duration (in milliseconds) of processing until the error/rejection occurred.
	 *
	 * @property {string} reason
	 * Textual explanation of why the method failed.
	 *
	 * @property {} source
	 * Resolved `data` parameter that was passed into the `source` function.
	 *
	 * It is only set when the error/rejection occurred inside the `source` function.
	 *
	 * @property {} dest
	 * Resolved `data` parameter that was passed into the `dest` function.
	 *
	 * It is only set when the error/rejection occurred inside the `dest` function.
	 *
	 * @see
	 * {@link page},
	 * {@link batch}
	 *
	 */
	function PageError(e, code, cbName, duration) {

	    this.index = e.index;
	    this.duration = duration;
	    this.error = e.error;

	    if ('source' in e) {
	        this.source = e.source;
	    }

	    if ('dest' in e) {
	        this.dest = e.dest;
	    }

	    if (this.error instanceof Error) {
	        this.message = this.error.message;
	    } else {
	        this.message = this.error;
	        if (typeof this.message !== 'string') {
	            this.message = $npm.u.inspect(this.message);
	        }
	    }

	    if (code) {
	        cbName = cbName ? "'" + cbName + "'" : '<anonymous>';
	        this.reason = $npm.u.format(errorReasons[code], cbName, e.index);
	    } else {
	        this.reason = $npm.u.format(errorReasons[code], e.index);
	    }

	    Error.captureStackTrace(this, PageError);
	}

	$npm.u.inherits(PageError, Error);
	PageError.prototype.name = 'PageError';

	/**
	 * @method errors.PageError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	PageError.prototype.toString = function (level) {

	    level = level > 0 ? parseInt(level) : 0;

	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        lines = ['PageError {', gap1 + 'message: ' + JSON.stringify(this.message), gap1 + 'reason: ' + this.reason, gap1 + 'index: ' + this.index, gap1 + 'duration: ' + this.duration];

	    lines.push(gap1 + 'error: ' + $npm.utils.formatError(this.error, level + 1));
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	PageError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = PageError;

/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var SequenceError = __webpack_require__(538);

	/**
	 * @method sequence
	 * @description
	 * **Alternative Syntax:**
	 * `sequence(source, {dest, limit, track})` &#8658; `Promise`
	 *
	 * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.
	 *
	 * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,
	 * till either no more values left in the sequence or an error/reject occurs.
	 *
	 * It supports both [linked and detached sequencing]{@tutorial sequencing}.
	 *
	 * @param {Function|generator} source
	 * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving
	 * with `undefined` ends the sequence, and the method resolves.
	 *
	 * Parameters:
	 *  - `index` = current request index in the sequence
	 *  - `data` = resolved data from the previous call (`undefined` when `index=0`)
	 *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)
	 *
	 * The function inherits `this` context from the calling method.
	 *
	 * If the function throws an error or returns a rejected promise, the sequence terminates,
	 * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.
	 *
	 * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`
	 *
	 * @param {Function|generator} [dest]
	 * Optional destination function (or generator), to receive resolved data for each index,
	 * process it and respond as required.
	 *
	 * Parameters:
	 *  - `index` = index of the resolved data in the sequence
	 *  - `data` = the data resolved
	 *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)
	 *
	 * The function inherits `this` context from the calling method.
	 *
	 * It can optionally return a promise object, if data processing is done asynchronously.
	 * If a promise is returned, the method will not request another value from the `source` function,
	 * until the promise has been resolved (the resolved value is ignored).
	 *
	 * If the function throws an error or returns a rejected promise, the sequence terminates,
	 * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.
	 *
	 * @param {Number} [limit=0]
	 * Limits the maximum size of the sequence. If the value is greater than 0, the method will
	 * successfully resolve once the specified limit has been reached.
	 *
	 * When `limit` isn't specified (default), the sequence is unlimited, and it will continue
	 * till one of the following occurs:
	 *  - `source` either returns or resolves with `undefined`
	 *  - either `source` or `dest` functions throw an error or return a rejected promise
	 *
	 * @param {Boolean} [track=false]
	 * Changes the type of data to be resolved by this method. By default, it is `false`
	 * (see the return result). When set to be `true`, the method tracks/collects all resolved data
	 * into an array internally, and resolves with that array once the method has finished successfully.
	 *
	 * It must be used with caution, as to the size of the sequence, because accumulating data for
	 * a very large sequence can result in consuming too much memory.
	 *
	 * @returns {external:Promise}
	 *
	 * When successful, the resolved data depends on parameter `track`. When `track` is `false`
	 * (default), the method resolves with object `{total, duration}`:
	 *  - `total` = number of values resolved by the sequence
	 *  - `duration` = number of milliseconds consumed by the method
	 *
	 * When `track` is `true`, the method resolves with an array of all the data that has been resolved,
	 * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with
	 * a hidden read-only property `duration` - number of milliseconds consumed by the method.
	 *
	 * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.
	 */
	function sequence(source, dest, limit, track, config) {

	    var $p = config.promise,
	        $utils = config.utils;

	    if (typeof source !== 'function') {
	        return $p.reject(new TypeError("Parameter 'source' must be a function."));
	    }

	    limit = limit > 0 ? parseInt(limit) : 0;
	    source = $utils.wrap(source);
	    dest = $utils.wrap(dest);

	    var self = this,
	        data,
	        srcTime,
	        destTime,
	        result = [],
	        start = Date.now();

	    return $p(function (resolve, reject) {

	        function loop(idx) {
	            var srcNow = Date.now(),
	                srcDelay = idx ? srcNow - srcTime : undefined;
	            srcTime = srcNow;
	            $utils.resolve.call(self, source, [idx, data, srcDelay], function (value, delayed) {
	                data = value;
	                if (data === undefined) {
	                    success();
	                } else {
	                    if (track) {
	                        result.push(data);
	                    }
	                    if (dest) {
	                        var destResult,
	                            destNow = Date.now(),
	                            destDelay = idx ? destNow - destTime : undefined;
	                        destTime = destNow;
	                        try {
	                            destResult = dest.call(self, idx, data, destDelay);
	                        } catch (e) {
	                            fail({
	                                error: e,
	                                dest: data
	                            }, 3, dest.name);
	                            return;
	                        }
	                        if ($utils.isPromise(destResult)) {
	                            destResult.then(function () {
	                                next(true);
	                                return null; // this dummy return is just to prevent Bluebird warnings;
	                            }).catch(function (error) {
	                                fail({
	                                    error: error,
	                                    dest: data
	                                }, 2, dest.name);
	                            });
	                        } else {
	                            next(delayed);
	                        }
	                    } else {
	                        next(delayed);
	                    }
	                }
	            }, function (reason, isRej) {
	                fail({
	                    error: reason,
	                    source: data
	                }, isRej ? 0 : 1, source.name);
	            });

	            function next(delayed) {
	                if (limit === ++idx) {
	                    success();
	                } else {
	                    if (delayed) {
	                        loop(idx);
	                    } else {
	                        $p.resolve().then(function () {
	                            loop(idx);
	                            return null; // this dummy return is just to prevent Bluebird warnings;
	                        });
	                    }
	                }
	            }

	            function success() {
	                var length = Date.now() - start;
	                if (track) {
	                    $utils.extend(result, 'duration', length);
	                } else {
	                    result = {
	                        total: idx,
	                        duration: length
	                    };
	                }
	                resolve(result);
	            }

	            function fail(reason, code, cbName) {
	                reason.index = idx;
	                reject(new SequenceError(reason, code, cbName, Date.now() - start));
	            }
	        }

	        loop(0);
	    });
	}

	module.exports = function (config) {
	    return function (source, dest, limit, track) {
	        if (dest && (typeof dest === 'undefined' ? 'undefined' : _typeof(dest)) === 'object') {
	            return sequence.call(this, source, dest.dest, dest.limit, dest.track, config);
	        } else {
	            return sequence.call(this, source, dest, limit, track, config);
	        }
	    };
	};

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    u: __webpack_require__(263),
	    os: __webpack_require__(490),
	    utils: __webpack_require__(532)
	};

	var errorReasons = {
	    0: "Source %s returned a rejection at index %d.",
	    1: "Source %s threw an error at index %d.",
	    2: "Destination %s returned a rejection at index %d.",
	    3: "Destination %s threw an error at index %d."
	};

	/**
	 * @interface errors.SequenceError
	 * @augments external:Error
	 * @description
	 * This type represents all errors rejected by method {@link sequence}, except for {@link external:TypeError TypeError}
	 * when the method receives invalid input parameters.
	 *
	 * @property {string} name
	 * Standard {@link external:Error Error} property - error type name = `SequenceError`.
	 *
	 * @property {string} message
	 * Standard {@link external:Error Error} property - the error message.
	 *
	 * @property {string} stack
	 * Standard {@link external:Error Error} property - the stack trace.
	 *
	 * @property {} error
	 * The error that was thrown or the rejection reason.
	 *
	 * @property {number} index
	 * Index of the element in the sequence for which the error/rejection occurred.
	 *
	 * @property {number} duration
	 * Duration (in milliseconds) of processing until the error/rejection occurred.
	 *
	 * @property {string} reason
	 * Textual explanation of why the method failed.
	 *
	 * @property {} source
	 * Resolved `data` parameter that was passed into the `source` function.
	 *
	 * It is only set when the error/rejection occurred inside the `source` function.
	 *
	 * @property {} dest
	 * Resolved `data` parameter that was passed into the `dest` function.
	 *
	 * It is only set when the error/rejection occurred inside the `dest` function.
	 *
	 * @see {@link sequence}
	 *
	 */
	function SequenceError(e, code, cbName, duration) {

	    this.index = e.index;
	    this.duration = duration;
	    this.error = e.error;

	    if (this.error instanceof Error) {
	        this.message = this.error.message;
	    } else {
	        this.message = this.error;
	        if (typeof this.message !== 'string') {
	            this.message = $npm.u.inspect(this.message);
	        }
	    }

	    if ('source' in e) {
	        this.source = e.source;
	    } else {
	        this.dest = e.dest;
	    }

	    cbName = cbName ? "'" + cbName + "'" : '<anonymous>';
	    this.reason = $npm.u.format(errorReasons[code], cbName, e.index);

	    Error.captureStackTrace(this, SequenceError);
	}

	$npm.u.inherits(SequenceError, Error);
	SequenceError.prototype.name = 'SequenceError';

	/**
	 * @method errors.SequenceError.toString
	 * @description
	 * Creates a well-formatted multi-line string that represents the error.
	 *
	 * It is called automatically when writing the object into the console.
	 *
	 * @param {number} [level=0]
	 * Nested output level, to provide visual offset.
	 *
	 * @returns {string}
	 */
	SequenceError.prototype.toString = function (level) {

	    level = level > 0 ? parseInt(level) : 0;

	    var gap0 = $npm.utils.messageGap(level),
	        gap1 = $npm.utils.messageGap(level + 1),
	        lines = ['SequenceError {', gap1 + 'message: ' + JSON.stringify(this.message), gap1 + 'reason: ' + this.reason, gap1 + 'index: ' + this.index, gap1 + 'duration: ' + this.duration];

	    lines.push(gap1 + 'error: ' + $npm.utils.formatError(this.error, level + 1));
	    lines.push(gap0 + '}');
	    return lines.join($npm.os.EOL);
	};

	SequenceError.prototype.inspect = function () {
	    return this.toString();
	};

	module.exports = SequenceError;

/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    read: __webpack_require__(540)
	};

	/**
	 * @namespace stream
	 * @description
	 * Namespace with methods that implement stream operations, and {@link stream.read read} is the only method currently supported.
	 *
	 * **Synchronous Stream Processing**
	 *
	 * ```javascript
	 * var stream = require('spex')(Promise).stream;
	 * var fs = require('fs');
	 *
	 * var rs = fs.createReadStream('values.txt');
	 *
	 * function receiver(index, data, delay) {
	 *    console.log("RECEIVED:", index, data, delay);
	 * }
	 *
	 * stream.read(rs, receiver)
	 * .then(function (data) {
	 *        console.log("DATA:", data);
	 *    })
	 * .catch(function (error) {
	 *        console.log("ERROR:", error);
	 *    });
	 * ```
	 *
	 * **Asynchronous Stream Processing**
	 *
	 * ```javascript
	 * var stream = require('spex')(Promise).stream;
	 * var fs = require('fs');
	 *
	 * var rs = fs.createReadStream('values.txt');
	 *
	 * function receiver(index, data, delay) {
	 *    return new Promise(function (resolve) {
	 *        console.log("RECEIVED:", index, data, delay);
	 *        resolve();
	 *    });
	 * }
	 *
	 * stream.read(rs, receiver)
	 * .then(function (data) {
	 *        console.log("DATA:", data);
	 *    })
	 * .catch(function (error) {
	 *        console.log("ERROR:", error);
	 *    });
	 * ```
	 *
	 * @property {function} stream.read
	 * Consumes and processes data from a $[Readable] stream.
	 *
	 */
	module.exports = function (config) {
	    var res = {
	        read: $npm.read(config)
	    };
	    Object.freeze(res);
	    return res;
	};

/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * @method stream.read
	 * @description
	 * **Alternative Syntax:**
	 * `read(stream, receiver, {closable, readSize})` &#8658; `Promise`
	 *
	 * Consumes and processes data from a $[Readable] stream.
	 *
	 * It reads the entire stream, using **paused mode**, with support for both synchronous
	 * and asynchronous data processing.
	 *
	 * **NOTE:** Once the method has finished, the onus is on the caller to release the stream
	 * according to its protocol.
	 *
	 * @param {Object} stream
	 * $[Readable] stream object.
	 *
	 * Passing in anything else will throw `Readable stream is required.`
	 *
	 * @param {Function|generator} receiver
	 * Data processing callback (or generator).
	 *
	 * Passing in anything else will throw `Invalid stream receiver.`
	 *
	 * Parameters:
	 *  - `index` = index of the call made to the function
	 *  - `data` = array of all data reads from the stream's buffer
	 *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)
	 *
	 * The function is called with the same `this` context as the calling method.
	 *
	 * It can optionally return a promise object, if data processing is asynchronous.
	 * And if a promise is returned, the method will not read data from the stream again,
	 * until the promise has been resolved.
	 *
	 * If the function throws an error or returns a rejected promise, the method rejects
	 * with the same error / rejection reason.
	 *
	 * @param {Boolean} [closable=false]
	 * Instructs the method to resolve on event `close` supported by the stream,
	 * as opposed to event `end` that's used by default.
	 *
	 * @param {Number} [readSize]
	 *
	 * When the value is greater than 0, it sets the read size from the stream's buffer
	 * when the next data is available. By default, the method uses as few reads as possible
	 * to get all the data currently available in the buffer.
	 *
	 * @returns {external:Promise}
	 *
	 * When finished successfully, resolves with object `{calls, reads, length, duration}`:
	 *  - `calls` = number of calls made into the `receiver`
	 *  - `reads` = number of successful reads from the stream
	 *  - `length` = total length for all the data reads from the stream
	 *  - `duration` = number of milliseconds consumed by the method
	 *
	 * When it fails, the method rejects with the error/reject specified,
	 * which can happen as a result of:
	 *  - event `error` emitted by the stream
	 *  - receiver throws an error or returns a rejected promise
	 */

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function read(stream, receiver, closable, readSize, config) {

	    var $p = config.promise,
	        $utils = config.utils;

	    if (!$utils.isReadableStream(stream)) {
	        return $p.reject(new TypeError("Readable stream is required."));
	    }

	    if (typeof receiver !== 'function') {
	        return $p.reject(new TypeError("Invalid stream receiver."));
	    }

	    readSize = readSize > 0 ? parseInt(readSize) : null;
	    receiver = $utils.wrap(receiver);

	    var self = this,
	        reads = 0,
	        length = 0,
	        start = Date.now(),
	        index = 0,
	        cbTime,
	        ready,
	        waiting,
	        stop;

	    return $p(function (resolve, reject) {

	        function onReadable() {
	            ready = true;
	            process();
	        }

	        function onEnd() {
	            if (!closable) {
	                success();
	            }
	        }

	        function onClose() {
	            success();
	        }

	        function onError(error) {
	            fail(error);
	        }

	        stream.on('readable', onReadable);
	        stream.on('end', onEnd);
	        stream.on('close', onClose);
	        stream.on('error', onError);

	        function process() {
	            if (!ready || stop || waiting) {
	                return;
	            }
	            ready = false;
	            waiting = true;
	            var page,
	                data = [];
	            do {
	                page = stream.read(readSize);
	                if (page) {
	                    data.push(page);
	                    // istanbul ignore next: requires a unique stream that
	                    // creates objects without property `length` defined.
	                    length += page.length || 0;
	                    reads++;
	                }
	            } while (page);

	            if (!data.length) {
	                waiting = false;
	                return;
	            }

	            var result,
	                cbNow = Date.now(),
	                cbDelay = index ? cbNow - cbTime : undefined;
	            cbTime = cbNow;
	            try {
	                result = receiver.call(self, index++, data, cbDelay);
	            } catch (e) {
	                fail(e);
	                return;
	            }

	            if ($utils.isPromise(result)) {
	                result.then(function () {
	                    waiting = false;
	                    process();
	                    return null; // this dummy return is just to prevent Bluebird warnings;
	                }).catch(function (error) {
	                    fail(error);
	                });
	            } else {
	                waiting = false;
	                process();
	            }
	        }

	        function success() {
	            cleanup();
	            resolve({
	                calls: index,
	                reads: reads,
	                length: length,
	                duration: Date.now() - start
	            });
	        }

	        function fail(error) {
	            stop = true;
	            cleanup();
	            reject(error);
	        }

	        function cleanup() {
	            stream.removeListener('readable', onReadable);
	            stream.removeListener('close', onClose);
	            stream.removeListener('error', onError);
	            stream.removeListener('end', onEnd);
	        }
	    });
	}

	module.exports = function (config) {
	    return function (stream, receiver, closable, readSize) {
	        if (closable && (typeof closable === 'undefined' ? 'undefined' : _typeof(closable)) === 'object') {
	            return read.call(this, stream, receiver, closable.closable, closable.readSize, config);
	        } else {
	            return read.call(this, stream, receiver, closable, readSize, config);
	        }
	    };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $npm = {
	    BatchError: __webpack_require__(534),
	    PageError: __webpack_require__(536),
	    SequenceError: __webpack_require__(538)
	};

	/**
	 * @namespace errors
	 * @description
	 * Namespace for all custom error types supported by the library.
	 *
	 * In addition to the custom error type used by each method (regular error), they can also reject with
	 * {@link external:TypeError TypeError} when receiving invalid input parameters.
	 *
	 * @property {function} BatchError
	 * {@link errors.BatchError BatchError} interface.
	 *
	 * Represents regular errors that can be reported by method {@link batch}.
	 *
	 * @property {function} PageError
	 * {@link errors.PageError PageError} interface.
	 *
	 * Represents regular errors that can be reported by method {@link page}.
	 *
	 * @property {function} SequenceError
	 * {@link errors.SequenceError SequenceError} interface.
	 *
	 * Represents regular errors that can be reported by method {@link sequence}.
	 *
	 */
	module.exports = {
	    BatchError: $npm.BatchError,
	    PageError: $npm.PageError,
	    SequenceError: $npm.SequenceError
	};

	Object.freeze(module.exports);

/***/ },
/* 542 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * @class PromiseAdapter
	 * @description
	 * Adapter for the primary promise operations.
	 * 
	 * Provides compatibility with promise libraries that cannot be recognized automatically,
	 * via functions that implement the primary operations with promises:
	 *
	 *  - construct a new promise with a callback function
	 *  - resolve a promise with some result data
	 *  - reject a promise with a reason
	 *
	 * #### Example
	 *
	 * Below is an example of setting up a [client-side]{@tutorial client} adapter for AngularJS $q.
	 *
	 * ```js
	 * var spexLib = require('spex'); // or include client-side spex.js
	 *
	 * var adapter = new spexLib.PromiseAdapter(
	 *    function (cb) {
	 *        return $q(cb); // creating a new promise;
	 *    }, function (data) {
	 *        return $q.when(data); // resolving a promise;
	 *    }, function (reason) {
	 *        return $q.reject(reason); // rejecting a promise;
	 *    });
	 *
	 * var spex = spexLib(adapter);
	 * ```
	 * Please note that AngularJS 1.4.1 or later no longer requires a promise adapter.
	 *
	 * @param {Function} create
	 * A function that takes a callback parameter and returns a new promise object.
	 * The callback parameter is expected to be `function(resolve, reject)`.
	 *
	 * Passing in anything other than a function will throw `Adapter requires a function to create a promise.`
	 *
	 * @param {Function} resolve
	 * A function that takes an optional data parameter and resolves a promise with it.
	 *
	 * Passing in anything other than a function will throw `Adapter requires a function to resolve a promise.`
	 *
	 * @param {Function} reject
	 * A function that takes an optional error parameter and rejects a promise with it.
	 *
	 * Passing in anything other than a function will throw `Adapter requires a function to reject a promise.`
	 *
	 * @see {@tutorial client}
	 * 
	 * @returns {PromiseAdapter}
	 */

	function PromiseAdapter(create, resolve, reject) {

	    if (!(this instanceof PromiseAdapter)) {
	        return new PromiseAdapter(create, resolve, reject);
	    }

	    this.create = create;
	    this.resolve = resolve;
	    this.reject = reject;

	    if (typeof create !== 'function') {
	        throw new TypeError('Adapter requires a function to create a promise.');
	    }

	    if (typeof resolve !== 'function') {
	        throw new TypeError('Adapter requires a function to resolve a promise.');
	    }

	    if (typeof reject !== 'function') {
	        throw new TypeError('Adapter requires a function to reject a promise.');
	    }
	}

	module.exports = PromiseAdapter;

/***/ },
/* 543 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * ES6 generators
	 * @module async
	 * @author Vitaly Tomilov
	 * @private
	 */

	module.exports = function (config) {

	    /////////////////////////////////
	    // Generator-to-Promise adapter;
	    //
	    // Based on: https://www.promisejs.org/generators/#both
	    return function (generator) {
	        var $p = config.promise;
	        return function () {
	            var g = generator.apply(this, arguments);

	            function handle(result) {
	                if (result.done) {
	                    return $p.resolve(result.value);
	                }
	                return $p.resolve(result.value).then(function (res) {
	                    return handle(g.next(res));
	                }, function (err) {
	                    return handle(g.throw(err));
	                });
	            }

	            return handle(g.next());
	        };
	    };
	};

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _lodash = __webpack_require__(449);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _bcryptNodejs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"bcrypt-nodejs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	var _bcryptNodejs2 = _interopRequireDefault(_bcryptNodejs);

	var _dbConnect = __webpack_require__(452);

	var _dbConnect2 = _interopRequireDefault(_dbConnect);

	var _queries = __webpack_require__(450);

	var _queries2 = _interopRequireDefault(_queries);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var userSchema = {
	  columns: {
	    name: 'string',
	    username: 'string',
	    password: 'string',
	    facebookId: 'number',
	    facebookAccessToken: 'string'
	  },
	  tableName: 'users'
	};

	var User = function (_DB) {
	  _inherits(User, _DB);

	  function User(dbConnection, userSchema) {
	    _classCallCheck(this, User);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(User).call(this, dbConnection, userSchema));
	  }

	  _createClass(User, [{
	    key: 'generateHash',
	    value: function generateHash(password) {
	      return _bcryptNodejs2.default.hashSync(password, _bcryptNodejs2.default.genSaltSync(10));
	    }
	  }, {
	    key: 'isValidPassword',
	    value: function isValidPassword(password, id) {
	      return this.find({ id: id }).then(function (user) {
	        return [_bcryptNodejs2.default.compareSync(password, user[0].password), user];
	      }).catch(function (err) {
	        return console.log(err);
	      });
	    }
	  }]);

	  return User;
	}(_queries2.default);

	exports.default = new User(_dbConnect2.default, userSchema);

/***/ },
/* 545 */,
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.facebookAuthConfig = undefined;

	var _passportFacebook = __webpack_require__(547);

	var _passport = __webpack_require__(437);

	var _passport2 = _interopRequireDefault(_passport);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var FACEBOOK_CALLBACK = 'http://localhost:' + process.env.PORT + '/auth/facebook/callback';
	// import { FACEBOOK_APP_ID, FACEBOOK_APP_SECRET, FACEBOOK_CALLBACK } from '../config/fb';


	var FB = {
	  APP_ID: process.env.FACEBOOK_APP_ID,
	  APP_SECRET: process.env.FACEBOOK_APP_SECRET,
	  CALLBACK: process.env.PORT ? 'http://localhost:' + process.env.PORT + '/auth/facebook/callback' : 'http://localhost:8000/auth/facebook/callback'
	};

	var facebookAuthConfig = exports.facebookAuthConfig = function facebookAuthConfig(User) {
	  _passport2.default.use(new _passportFacebook.Strategy({
	    clientID: FB.APP_ID,
	    clientSecret: FB.APP_SECRET,
	    callbackURL: FB.CALLBACK,
	    enableProof: true,
	    profileFields: ['id', 'emails', 'name']
	  }, function (accessToken, refreshToken, profile, done) {
	    process.nextTick(function () {
	      return User.findOrCreate({
	        name: profile.name.givenName,
	        facebookId: profile.id,
	        facebookAccessToken: accessToken
	      }).then(function (user) {
	        return done(null, user);
	      }).catch(function (err) {
	        return done(err, null);
	      });
	    });
	  }));
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Load modules.
	var Strategy = __webpack_require__(548);

	// Expose Strategy.
	exports = module.exports = Strategy;

	// Exports.
	exports.Strategy = Strategy;

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Load modules.
	var OAuth2Strategy = __webpack_require__(549),
	    util = __webpack_require__(263),
	    uri = __webpack_require__(216),
	    crypto = __webpack_require__(256),
	    Profile = __webpack_require__(564),
	    InternalOAuthError = __webpack_require__(549).InternalOAuthError,
	    FacebookAuthorizationError = __webpack_require__(565),
	    FacebookTokenError = __webpack_require__(566),
	    FacebookGraphAPIError = __webpack_require__(567);

	/**
	 * `Strategy` constructor.
	 *
	 * The Facebook authentication strategy authenticates requests by delegating to
	 * Facebook using the OAuth 2.0 protocol.
	 *
	 * Applications must supply a `verify` callback which accepts an `accessToken`,
	 * `refreshToken` and service-specific `profile`, and then calls the `cb`
	 * callback supplying a `user`, which should be set to `false` if the
	 * credentials are not valid.  If an exception occured, `err` should be set.
	 *
	 * Options:
	 *   - `clientID`      your Facebook application's App ID
	 *   - `clientSecret`  your Facebook application's App Secret
	 *   - `callbackURL`   URL to which Facebook will redirect the user after granting authorization
	 *
	 * Examples:
	 *
	 *     passport.use(new FacebookStrategy({
	 *         clientID: '123-456-789',
	 *         clientSecret: 'shhh-its-a-secret'
	 *         callbackURL: 'https://www.example.net/auth/facebook/callback'
	 *       },
	 *       function(accessToken, refreshToken, profile, cb) {
	 *         User.findOrCreate(..., function (err, user) {
	 *           cb(err, user);
	 *         });
	 *       }
	 *     ));
	 *
	 * @constructor
	 * @param {object} options
	 * @param {function} verify
	 * @access public
	 */
	function Strategy(options, verify) {
	  options = options || {};
	  options.authorizationURL = options.authorizationURL || 'https://www.facebook.com/dialog/oauth';
	  options.tokenURL = options.tokenURL || 'https://graph.facebook.com/oauth/access_token';
	  options.scopeSeparator = options.scopeSeparator || ',';

	  OAuth2Strategy.call(this, options, verify);
	  this.name = 'facebook';
	  this._profileURL = options.profileURL || 'https://graph.facebook.com/v2.5/me';
	  this._profileFields = options.profileFields || null;
	  this._enableProof = options.enableProof;
	  this._clientSecret = options.clientSecret;
	}

	// Inherit from `OAuth2Strategy`.
	util.inherits(Strategy, OAuth2Strategy);

	/**
	 * Authenticate request by delegating to Facebook using OAuth 2.0.
	 *
	 * @param {http.IncomingMessage} req
	 * @param {object} options
	 * @access protected
	 */
	Strategy.prototype.authenticate = function (req, options) {
	  // Facebook doesn't conform to the OAuth 2.0 specification, with respect to
	  // redirecting with error codes.
	  //
	  //   FIX: https://github.com/jaredhanson/passport-oauth/issues/16
	  if (req.query && req.query.error_code && !req.query.error) {
	    return this.error(new FacebookAuthorizationError(req.query.error_message, parseInt(req.query.error_code, 10)));
	  }

	  OAuth2Strategy.prototype.authenticate.call(this, req, options);
	};

	/**
	 * Return extra Facebook-specific parameters to be included in the authorization
	 * request.
	 *
	 * Options:
	 *  - `display`  Display mode to render dialog, { `page`, `popup`, `touch` }.
	 *
	 * @param {object} options
	 * @return {object}
	 * @access protected
	 */
	Strategy.prototype.authorizationParams = function (options) {
	  var params = {};

	  // https://developers.facebook.com/docs/reference/dialogs/oauth/
	  if (options.display) {
	    params.display = options.display;
	  }

	  // https://developers.facebook.com/docs/facebook-login/reauthentication/
	  if (options.authType) {
	    params.auth_type = options.authType;
	  }
	  if (options.authNonce) {
	    params.auth_nonce = options.authNonce;
	  }

	  return params;
	};

	/**
	 * Retrieve user profile from Facebook.
	 *
	 * This function constructs a normalized profile, with the following properties:
	 *
	 *   - `provider`         always set to `facebook`
	 *   - `id`               the user's Facebook ID
	 *   - `username`         the user's Facebook username
	 *   - `displayName`      the user's full name
	 *   - `name.familyName`  the user's last name
	 *   - `name.givenName`   the user's first name
	 *   - `name.middleName`  the user's middle name
	 *   - `gender`           the user's gender: `male` or `female`
	 *   - `profileUrl`       the URL of the profile for the user on Facebook
	 *   - `emails`           the proxied or contact email address granted by the user
	 *
	 * @param {string} accessToken
	 * @param {function} done
	 * @access protected
	 */
	Strategy.prototype.userProfile = function (accessToken, done) {
	  var url = uri.parse(this._profileURL);
	  if (this._enableProof) {
	    // Secure API call by adding proof of the app secret.  This is required when
	    // the "Require AppSecret Proof for Server API calls" setting has been
	    // enabled.  The proof is a SHA256 hash of the access token, using the app
	    // secret as the key.
	    //
	    // For further details, refer to:
	    // https://developers.facebook.com/docs/reference/api/securing-graph-api/    
	    var proof = crypto.createHmac('sha256', this._clientSecret).update(accessToken).digest('hex');
	    url.search = (url.search ? url.search + '&' : '') + 'appsecret_proof=' + proof;
	  }
	  if (this._profileFields) {
	    var fields = this._convertProfileFields(this._profileFields);
	    if (fields !== '') {
	      url.search = (url.search ? url.search + '&' : '') + 'fields=' + fields;
	    }
	  }
	  url = uri.format(url);

	  this._oauth2.get(url, accessToken, function (err, body, res) {
	    var json;

	    if (err) {
	      if (err.data) {
	        try {
	          json = JSON.parse(err.data);
	        } catch (_) {}
	      }

	      if (json && json.error && _typeof(json.error) == 'object') {
	        return done(new FacebookGraphAPIError(json.error.message, json.error.type, json.error.code, json.error.error_subcode, json.error.fbtrace_id));
	      }
	      return done(new InternalOAuthError('Failed to fetch user profile', err));
	    }

	    try {
	      json = JSON.parse(body);
	    } catch (ex) {
	      return done(new Error('Failed to parse user profile'));
	    }

	    var profile = Profile.parse(json);
	    profile.provider = 'facebook';
	    profile._raw = body;
	    profile._json = json;

	    done(null, profile);
	  });
	};

	/**
	 * Parse error response from Facebook OAuth 2.0 token endpoint.
	 *
	 * @param {string} body
	 * @param {number} status
	 * @return {Error}
	 * @access protected
	 */
	Strategy.prototype.parseErrorResponse = function (body, status) {
	  var json = JSON.parse(body);
	  if (json.error && _typeof(json.error) == 'object') {
	    return new FacebookTokenError(json.error.message, json.error.type, json.error.code, json.error.error_subcode, json.error.fbtrace_id);
	  }
	  return OAuth2Strategy.prototype.parseErrorResponse.call(this, body, status);
	};

	/**
	 * Convert Facebook profile to a normalized profile.
	 *
	 * @param {object} profileFields
	 * @return {string}
	 * @access protected
	 */
	Strategy.prototype._convertProfileFields = function (profileFields) {
	  var map = {
	    'id': 'id',
	    'username': 'username',
	    'displayName': 'name',
	    'name': ['last_name', 'first_name', 'middle_name'],
	    'gender': 'gender',
	    'birthday': 'birthday',
	    'profileUrl': 'link',
	    'emails': 'email',
	    'photos': 'picture'
	  };

	  var fields = [];

	  profileFields.forEach(function (f) {
	    // return raw Facebook profile field to support the many fields that don't
	    // map cleanly to Portable Contacts
	    if (typeof map[f] === 'undefined') {
	      return fields.push(f);
	    };

	    if (Array.isArray(map[f])) {
	      Array.prototype.push.apply(fields, map[f]);
	    } else {
	      fields.push(map[f]);
	    }
	  });

	  return fields.join(',');
	};

	// Expose constructor.
	module.exports = Strategy;

/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Load modules.
	var Strategy = __webpack_require__(550),
	    AuthorizationError = __webpack_require__(561),
	    TokenError = __webpack_require__(562),
	    InternalOAuthError = __webpack_require__(563);

	// Expose Strategy.
	exports = module.exports = Strategy;

	// Exports.
	exports.Strategy = Strategy;

	exports.AuthorizationError = AuthorizationError;
	exports.TokenError = TokenError;
	exports.InternalOAuthError = InternalOAuthError;

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Load modules.
	var passport = __webpack_require__(441),
	    url = __webpack_require__(216),
	    util = __webpack_require__(263),
	    utils = __webpack_require__(551),
	    OAuth2 = __webpack_require__(552).OAuth2,
	    NullStateStore = __webpack_require__(558),
	    SessionStateStore = __webpack_require__(559),
	    AuthorizationError = __webpack_require__(561),
	    TokenError = __webpack_require__(562),
	    InternalOAuthError = __webpack_require__(563);

	/**
	 * Creates an instance of `OAuth2Strategy`.
	 *
	 * The OAuth 2.0 authentication strategy authenticates requests using the OAuth
	 * 2.0 framework.
	 *
	 * OAuth 2.0 provides a facility for delegated authentication, whereby users can
	 * authenticate using a third-party service such as Facebook.  Delegating in
	 * this manner involves a sequence of events, including redirecting the user to
	 * the third-party service for authorization.  Once authorization has been
	 * granted, the user is redirected back to the application and an authorization
	 * code can be used to obtain credentials.
	 *
	 * Applications must supply a `verify` callback, for which the function
	 * signature is:
	 *
	 *     function(accessToken, refreshToken, profile, done) { ... }
	 *
	 * The verify callback is responsible for finding or creating the user, and
	 * invoking `done` with the following arguments:
	 *
	 *     done(err, user, info);
	 *
	 * `user` should be set to `false` to indicate an authentication failure.
	 * Additional `info` can optionally be passed as a third argument, typically
	 * used to display informational messages.  If an exception occured, `err`
	 * should be set.
	 *
	 * Options:
	 *
	 *   - `authorizationURL`  URL used to obtain an authorization grant
	 *   - `tokenURL`          URL used to obtain an access token
	 *   - `clientID`          identifies client to service provider
	 *   - `clientSecret`      secret used to establish ownership of the client identifer
	 *   - `callbackURL`       URL to which the service provider will redirect the user after obtaining authorization
	 *   - `passReqToCallback` when `true`, `req` is the first argument to the verify callback (default: `false`)
	 *
	 * Examples:
	 *
	 *     passport.use(new OAuth2Strategy({
	 *         authorizationURL: 'https://www.example.com/oauth2/authorize',
	 *         tokenURL: 'https://www.example.com/oauth2/token',
	 *         clientID: '123-456-789',
	 *         clientSecret: 'shhh-its-a-secret'
	 *         callbackURL: 'https://www.example.net/auth/example/callback'
	 *       },
	 *       function(accessToken, refreshToken, profile, done) {
	 *         User.findOrCreate(..., function (err, user) {
	 *           done(err, user);
	 *         });
	 *       }
	 *     ));
	 *
	 * @constructor
	 * @param {Object} options
	 * @param {Function} verify
	 * @api public
	 */
	function OAuth2Strategy(options, verify) {
	  if (typeof options == 'function') {
	    verify = options;
	    options = undefined;
	  }
	  options = options || {};

	  if (!verify) {
	    throw new TypeError('OAuth2Strategy requires a verify callback');
	  }
	  if (!options.authorizationURL) {
	    throw new TypeError('OAuth2Strategy requires a authorizationURL option');
	  }
	  if (!options.tokenURL) {
	    throw new TypeError('OAuth2Strategy requires a tokenURL option');
	  }
	  if (!options.clientID) {
	    throw new TypeError('OAuth2Strategy requires a clientID option');
	  }

	  passport.Strategy.call(this);
	  this.name = 'oauth2';
	  this._verify = verify;

	  // NOTE: The _oauth2 property is considered "protected".  Subclasses are
	  //       allowed to use it when making protected resource requests to retrieve
	  //       the user profile.
	  this._oauth2 = new OAuth2(options.clientID, options.clientSecret, '', options.authorizationURL, options.tokenURL, options.customHeaders);

	  this._callbackURL = options.callbackURL;
	  this._scope = options.scope;
	  this._scopeSeparator = options.scopeSeparator || ' ';
	  this._key = options.sessionKey || 'oauth2:' + url.parse(options.authorizationURL).hostname;

	  if (options.store) {
	    this._stateStore = options.store;
	  } else {
	    if (options.state) {
	      this._stateStore = new SessionStateStore({ key: this._key });
	    } else {
	      this._stateStore = new NullStateStore();
	    }
	  }
	  this._trustProxy = options.proxy;
	  this._passReqToCallback = options.passReqToCallback;
	  this._skipUserProfile = options.skipUserProfile === undefined ? false : options.skipUserProfile;
	}

	// Inherit from `passport.Strategy`.
	util.inherits(OAuth2Strategy, passport.Strategy);

	/**
	 * Authenticate request by delegating to a service provider using OAuth 2.0.
	 *
	 * @param {Object} req
	 * @api protected
	 */
	OAuth2Strategy.prototype.authenticate = function (req, options) {
	  options = options || {};
	  var self = this;

	  if (req.query && req.query.error) {
	    if (req.query.error == 'access_denied') {
	      return this.fail({ message: req.query.error_description });
	    } else {
	      return this.error(new AuthorizationError(req.query.error_description, req.query.error, req.query.error_uri));
	    }
	  }

	  var callbackURL = options.callbackURL || this._callbackURL;
	  if (callbackURL) {
	    var parsed = url.parse(callbackURL);
	    if (!parsed.protocol) {
	      // The callback URL is relative, resolve a fully qualified URL from the
	      // URL of the originating request.
	      callbackURL = url.resolve(utils.originalURL(req, { proxy: this._trustProxy }), callbackURL);
	    }
	  }

	  var meta = {
	    authorizationURL: this._oauth2._authorizeUrl,
	    tokenURL: this._oauth2._accessTokenUrl,
	    clientID: this._oauth2._clientId
	  };

	  if (req.query && req.query.code) {
	    var loaded = function loaded(err, ok, state) {
	      if (err) {
	        return self.error(err);
	      }
	      if (!ok) {
	        return self.fail(state, 403);
	      }

	      var code = req.query.code;

	      var params = self.tokenParams(options);
	      params.grant_type = 'authorization_code';
	      if (callbackURL) {
	        params.redirect_uri = callbackURL;
	      }

	      self._oauth2.getOAuthAccessToken(code, params, function (err, accessToken, refreshToken, params) {
	        if (err) {
	          return self.error(self._createOAuthError('Failed to obtain access token', err));
	        }

	        self._loadUserProfile(accessToken, function (err, profile) {
	          if (err) {
	            return self.error(err);
	          }

	          function verified(err, user, info) {
	            if (err) {
	              return self.error(err);
	            }
	            if (!user) {
	              return self.fail(info);
	            }

	            info = info || {};
	            if (state) {
	              info.state = state;
	            }
	            self.success(user, info);
	          }

	          try {
	            if (self._passReqToCallback) {
	              var arity = self._verify.length;
	              if (arity == 6) {
	                self._verify(req, accessToken, refreshToken, params, profile, verified);
	              } else {
	                // arity == 5
	                self._verify(req, accessToken, refreshToken, profile, verified);
	              }
	            } else {
	              var arity = self._verify.length;
	              if (arity == 5) {
	                self._verify(accessToken, refreshToken, params, profile, verified);
	              } else {
	                // arity == 4
	                self._verify(accessToken, refreshToken, profile, verified);
	              }
	            }
	          } catch (ex) {
	            return self.error(ex);
	          }
	        });
	      });
	    };

	    var state = req.query.state;
	    try {
	      var arity = this._stateStore.verify.length;
	      if (arity == 4) {
	        this._stateStore.verify(req, state, meta, loaded);
	      } else {
	        // arity == 3
	        this._stateStore.verify(req, state, loaded);
	      }
	    } catch (ex) {
	      return this.error(ex);
	    }
	  } else {
	    var params = this.authorizationParams(options);
	    params.response_type = 'code';
	    if (callbackURL) {
	      params.redirect_uri = callbackURL;
	    }
	    var scope = options.scope || this._scope;
	    if (scope) {
	      if (Array.isArray(scope)) {
	        scope = scope.join(this._scopeSeparator);
	      }
	      params.scope = scope;
	    }

	    var state = options.state;
	    if (state) {
	      params.state = state;
	      var location = this._oauth2.getAuthorizeUrl(params);
	      this.redirect(location);
	    } else {
	      var stored = function stored(err, state) {
	        if (err) {
	          return self.error(err);
	        }

	        if (state) {
	          params.state = state;
	        }
	        var location = self._oauth2.getAuthorizeUrl(params);
	        self.redirect(location);
	      };

	      try {
	        var arity = this._stateStore.store.length;
	        if (arity == 3) {
	          this._stateStore.store(req, meta, stored);
	        } else {
	          // arity == 2
	          this._stateStore.store(req, stored);
	        }
	      } catch (ex) {
	        return this.error(ex);
	      }
	    }
	  }
	};

	/**
	 * Retrieve user profile from service provider.
	 *
	 * OAuth 2.0-based authentication strategies can overrride this function in
	 * order to load the user's profile from the service provider.  This assists
	 * applications (and users of those applications) in the initial registration
	 * process by automatically submitting required information.
	 *
	 * @param {String} accessToken
	 * @param {Function} done
	 * @api protected
	 */
	OAuth2Strategy.prototype.userProfile = function (accessToken, done) {
	  return done(null, {});
	};

	/**
	 * Return extra parameters to be included in the authorization request.
	 *
	 * Some OAuth 2.0 providers allow additional, non-standard parameters to be
	 * included when requesting authorization.  Since these parameters are not
	 * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication
	 * strategies can overrride this function in order to populate these parameters
	 * as required by the provider.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @api protected
	 */
	OAuth2Strategy.prototype.authorizationParams = function (options) {
	  return {};
	};

	/**
	 * Return extra parameters to be included in the token request.
	 *
	 * Some OAuth 2.0 providers allow additional, non-standard parameters to be
	 * included when requesting an access token.  Since these parameters are not
	 * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication
	 * strategies can overrride this function in order to populate these parameters
	 * as required by the provider.
	 *
	 * @return {Object}
	 * @api protected
	 */
	OAuth2Strategy.prototype.tokenParams = function (options) {
	  return {};
	};

	/**
	 * Parse error response from OAuth 2.0 endpoint.
	 *
	 * OAuth 2.0-based authentication strategies can overrride this function in
	 * order to parse error responses received from the token endpoint, allowing the
	 * most informative message to be displayed.
	 *
	 * If this function is not overridden, the body will be parsed in accordance
	 * with RFC 6749, section 5.2.
	 *
	 * @param {String} body
	 * @param {Number} status
	 * @return {Error}
	 * @api protected
	 */
	OAuth2Strategy.prototype.parseErrorResponse = function (body, status) {
	  var json = JSON.parse(body);
	  if (json.error) {
	    return new TokenError(json.error_description, json.error, json.error_uri);
	  }
	  return null;
	};

	/**
	 * Load user profile, contingent upon options.
	 *
	 * @param {String} accessToken
	 * @param {Function} done
	 * @api private
	 */
	OAuth2Strategy.prototype._loadUserProfile = function (accessToken, done) {
	  var self = this;

	  function loadIt() {
	    return self.userProfile(accessToken, done);
	  }
	  function skipIt() {
	    return done(null);
	  }

	  if (typeof this._skipUserProfile == 'function' && this._skipUserProfile.length > 1) {
	    // async
	    this._skipUserProfile(accessToken, function (err, skip) {
	      if (err) {
	        return done(err);
	      }
	      if (!skip) {
	        return loadIt();
	      }
	      return skipIt();
	    });
	  } else {
	    var skip = typeof this._skipUserProfile == 'function' ? this._skipUserProfile() : this._skipUserProfile;
	    if (!skip) {
	      return loadIt();
	    }
	    return skipIt();
	  }
	};

	/**
	 * Create an OAuth error.
	 *
	 * @param {String} message
	 * @param {Object|Error} err
	 * @api private
	 */
	OAuth2Strategy.prototype._createOAuthError = function (message, err) {
	  var e;
	  if (err.statusCode && err.data) {
	    try {
	      e = this.parseErrorResponse(err.data, err.statusCode);
	    } catch (_) {}
	  }
	  if (!e) {
	    e = new InternalOAuthError(message, err);
	  }
	  return e;
	};

	// Expose constructor.
	module.exports = OAuth2Strategy;

/***/ },
/* 551 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Reconstructs the original URL of the request.
	 *
	 * This function builds a URL that corresponds the original URL requested by the
	 * client, including the protocol (http or https) and host.
	 *
	 * If the request passed through any proxies that terminate SSL, the
	 * `X-Forwarded-Proto` header is used to detect if the request was encrypted to
	 * the proxy, assuming that the proxy has been flagged as trusted.
	 *
	 * @param {http.IncomingMessage} req
	 * @param {Object} [options]
	 * @return {String}
	 * @api private
	 */
	exports.originalURL = function (req, options) {
	  options = options || {};
	  var app = req.app;
	  if (app && app.get && app.get('trust proxy')) {
	    options.proxy = true;
	  }
	  var trustProxy = options.proxy;

	  var proto = (req.headers['x-forwarded-proto'] || '').toLowerCase(),
	      tls = req.connection.encrypted || trustProxy && 'https' == proto.split(/\s*,\s*/)[0],
	      host = trustProxy && req.headers['x-forwarded-host'] || req.headers.host,
	      protocol = tls ? 'https' : 'http',
	      path = req.url || '';
	  return protocol + '://' + host + path;
	};

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.OAuth = __webpack_require__(553).OAuth;
	exports.OAuthEcho = __webpack_require__(553).OAuthEcho;
	exports.OAuth2 = __webpack_require__(557).OAuth2;

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var crypto = __webpack_require__(256),
	    sha1 = __webpack_require__(554),
	    http = __webpack_require__(293),
	    https = __webpack_require__(555),
	    URL = __webpack_require__(216),
	    querystring = __webpack_require__(220),
	    OAuthUtils = __webpack_require__(556);

	exports.OAuth = function (requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, nonceSize, customHeaders) {
	  this._isEcho = false;

	  this._requestUrl = requestUrl;
	  this._accessUrl = accessUrl;
	  this._consumerKey = consumerKey;
	  this._consumerSecret = this._encodeData(consumerSecret);
	  if (signatureMethod == "RSA-SHA1") {
	    this._privateKey = consumerSecret;
	  }
	  this._version = version;
	  if (authorize_callback === undefined) {
	    this._authorize_callback = "oob";
	  } else {
	    this._authorize_callback = authorize_callback;
	  }

	  if (signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1") throw new Error("Un-supported signature method: " + signatureMethod);
	  this._signatureMethod = signatureMethod;
	  this._nonceSize = nonceSize || 32;
	  this._headers = customHeaders || { "Accept": "*/*",
	    "Connection": "close",
	    "User-Agent": "Node authentication" };
	  this._clientOptions = this._defaultClientOptions = { "requestTokenHttpMethod": "POST",
	    "accessTokenHttpMethod": "POST",
	    "followRedirects": true };
	  this._oauthParameterSeperator = ",";
	};

	exports.OAuthEcho = function (realm, verify_credentials, consumerKey, consumerSecret, version, signatureMethod, nonceSize, customHeaders) {
	  this._isEcho = true;

	  this._realm = realm;
	  this._verifyCredentials = verify_credentials;
	  this._consumerKey = consumerKey;
	  this._consumerSecret = this._encodeData(consumerSecret);
	  if (signatureMethod == "RSA-SHA1") {
	    this._privateKey = consumerSecret;
	  }
	  this._version = version;

	  if (signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1") throw new Error("Un-supported signature method: " + signatureMethod);
	  this._signatureMethod = signatureMethod;
	  this._nonceSize = nonceSize || 32;
	  this._headers = customHeaders || { "Accept": "*/*",
	    "Connection": "close",
	    "User-Agent": "Node authentication" };
	  this._oauthParameterSeperator = ",";
	};

	exports.OAuthEcho.prototype = exports.OAuth.prototype;

	exports.OAuth.prototype._getTimestamp = function () {
	  return Math.floor(new Date().getTime() / 1000);
	};

	exports.OAuth.prototype._encodeData = function (toEncode) {
	  if (toEncode == null || toEncode == "") return "";else {
	    var result = encodeURIComponent(toEncode);
	    // Fix the mismatch between OAuth's  RFC3986's and Javascript's beliefs in what is right and wrong ;)
	    return result.replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
	  }
	};

	exports.OAuth.prototype._decodeData = function (toDecode) {
	  if (toDecode != null) {
	    toDecode = toDecode.replace(/\+/g, " ");
	  }
	  return decodeURIComponent(toDecode);
	};

	exports.OAuth.prototype._getSignature = function (method, url, parameters, tokenSecret) {
	  var signatureBase = this._createSignatureBase(method, url, parameters);
	  return this._createSignature(signatureBase, tokenSecret);
	};

	exports.OAuth.prototype._normalizeUrl = function (url) {
	  var parsedUrl = URL.parse(url, true);
	  var port = "";
	  if (parsedUrl.port) {
	    if (parsedUrl.protocol == "http:" && parsedUrl.port != "80" || parsedUrl.protocol == "https:" && parsedUrl.port != "443") {
	      port = ":" + parsedUrl.port;
	    }
	  }

	  if (!parsedUrl.pathname || parsedUrl.pathname == "") parsedUrl.pathname = "/";

	  return parsedUrl.protocol + "//" + parsedUrl.hostname + port + parsedUrl.pathname;
	};

	// Is the parameter considered an OAuth parameter
	exports.OAuth.prototype._isParameterNameAnOAuthParameter = function (parameter) {
	  var m = parameter.match('^oauth_');
	  if (m && m[0] === "oauth_") {
	    return true;
	  } else {
	    return false;
	  }
	};

	// build the OAuth request authorization header
	exports.OAuth.prototype._buildAuthorizationHeaders = function (orderedParameters) {
	  var authHeader = "OAuth ";
	  if (this._isEcho) {
	    authHeader += 'realm="' + this._realm + '",';
	  }

	  for (var i = 0; i < orderedParameters.length; i++) {
	    // Whilst the all the parameters should be included within the signature, only the oauth_ arguments
	    // should appear within the authorization header.
	    if (this._isParameterNameAnOAuthParameter(orderedParameters[i][0])) {
	      authHeader += "" + this._encodeData(orderedParameters[i][0]) + "=\"" + this._encodeData(orderedParameters[i][1]) + "\"" + this._oauthParameterSeperator;
	    }
	  }

	  authHeader = authHeader.substring(0, authHeader.length - this._oauthParameterSeperator.length);
	  return authHeader;
	};

	// Takes an object literal that represents the arguments, and returns an array
	// of argument/value pairs.
	exports.OAuth.prototype._makeArrayOfArgumentsHash = function (argumentsHash) {
	  var argument_pairs = [];
	  for (var key in argumentsHash) {
	    if (argumentsHash.hasOwnProperty(key)) {
	      var value = argumentsHash[key];
	      if (Array.isArray(value)) {
	        for (var i = 0; i < value.length; i++) {
	          argument_pairs[argument_pairs.length] = [key, value[i]];
	        }
	      } else {
	        argument_pairs[argument_pairs.length] = [key, value];
	      }
	    }
	  }
	  return argument_pairs;
	};

	// Sorts the encoded key value pairs by encoded name, then encoded value
	exports.OAuth.prototype._sortRequestParams = function (argument_pairs) {
	  // Sort by name, then value.
	  argument_pairs.sort(function (a, b) {
	    if (a[0] == b[0]) {
	      return a[1] < b[1] ? -1 : 1;
	    } else return a[0] < b[0] ? -1 : 1;
	  });

	  return argument_pairs;
	};

	exports.OAuth.prototype._normaliseRequestParams = function (args) {
	  var argument_pairs = this._makeArrayOfArgumentsHash(args);
	  // First encode them #3.4.1.3.2 .1
	  for (var i = 0; i < argument_pairs.length; i++) {
	    argument_pairs[i][0] = this._encodeData(argument_pairs[i][0]);
	    argument_pairs[i][1] = this._encodeData(argument_pairs[i][1]);
	  }

	  // Then sort them #3.4.1.3.2 .2
	  argument_pairs = this._sortRequestParams(argument_pairs);

	  // Then concatenate together #3.4.1.3.2 .3 & .4
	  var args = "";
	  for (var i = 0; i < argument_pairs.length; i++) {
	    args += argument_pairs[i][0];
	    args += "=";
	    args += argument_pairs[i][1];
	    if (i < argument_pairs.length - 1) args += "&";
	  }
	  return args;
	};

	exports.OAuth.prototype._createSignatureBase = function (method, url, parameters) {
	  url = this._encodeData(this._normalizeUrl(url));
	  parameters = this._encodeData(parameters);
	  return method.toUpperCase() + "&" + url + "&" + parameters;
	};

	exports.OAuth.prototype._createSignature = function (signatureBase, tokenSecret) {
	  if (tokenSecret === undefined) var tokenSecret = "";else tokenSecret = this._encodeData(tokenSecret);
	  // consumerSecret is already encoded
	  var key = this._consumerSecret + "&" + tokenSecret;

	  var hash = "";
	  if (this._signatureMethod == "PLAINTEXT") {
	    hash = key;
	  } else if (this._signatureMethod == "RSA-SHA1") {
	    key = this._privateKey || "";
	    hash = crypto.createSign("RSA-SHA1").update(signatureBase).sign(key, 'base64');
	  } else {
	    if (crypto.Hmac) {
	      hash = crypto.createHmac("sha1", key).update(signatureBase).digest("base64");
	    } else {
	      hash = sha1.HMACSHA1(key, signatureBase);
	    }
	  }
	  return hash;
	};
	exports.OAuth.prototype.NONCE_CHARS = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

	exports.OAuth.prototype._getNonce = function (nonceSize) {
	  var result = [];
	  var chars = this.NONCE_CHARS;
	  var char_pos;
	  var nonce_chars_length = chars.length;

	  for (var i = 0; i < nonceSize; i++) {
	    char_pos = Math.floor(Math.random() * nonce_chars_length);
	    result[i] = chars[char_pos];
	  }
	  return result.join('');
	};

	exports.OAuth.prototype._createClient = function (port, hostname, method, path, headers, sslEnabled) {
	  var options = {
	    host: hostname,
	    port: port,
	    path: path,
	    method: method,
	    headers: headers
	  };
	  var httpModel;
	  if (sslEnabled) {
	    httpModel = https;
	  } else {
	    httpModel = http;
	  }
	  return httpModel.request(options);
	};

	exports.OAuth.prototype._prepareParameters = function (oauth_token, oauth_token_secret, method, url, extra_params) {
	  var oauthParameters = {
	    "oauth_timestamp": this._getTimestamp(),
	    "oauth_nonce": this._getNonce(this._nonceSize),
	    "oauth_version": this._version,
	    "oauth_signature_method": this._signatureMethod,
	    "oauth_consumer_key": this._consumerKey
	  };

	  if (oauth_token) {
	    oauthParameters["oauth_token"] = oauth_token;
	  }

	  var sig;
	  if (this._isEcho) {
	    sig = this._getSignature("GET", this._verifyCredentials, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
	  } else {
	    if (extra_params) {
	      for (var key in extra_params) {
	        if (extra_params.hasOwnProperty(key)) oauthParameters[key] = extra_params[key];
	      }
	    }
	    var parsedUrl = URL.parse(url, false);

	    if (parsedUrl.query) {
	      var key2;
	      var extraParameters = querystring.parse(parsedUrl.query);
	      for (var key in extraParameters) {
	        var value = extraParameters[key];
	        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
	          // TODO: This probably should be recursive
	          for (key2 in value) {
	            oauthParameters[key + "[" + key2 + "]"] = value[key2];
	          }
	        } else {
	          oauthParameters[key] = value;
	        }
	      }
	    }

	    sig = this._getSignature(method, url, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
	  }

	  var orderedParameters = this._sortRequestParams(this._makeArrayOfArgumentsHash(oauthParameters));
	  orderedParameters[orderedParameters.length] = ["oauth_signature", sig];
	  return orderedParameters;
	};

	exports.OAuth.prototype._performSecureRequest = function (oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback) {
	  var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);

	  if (!post_content_type) {
	    post_content_type = "application/x-www-form-urlencoded";
	  }
	  var parsedUrl = URL.parse(url, false);
	  if (parsedUrl.protocol == "http:" && !parsedUrl.port) parsedUrl.port = 80;
	  if (parsedUrl.protocol == "https:" && !parsedUrl.port) parsedUrl.port = 443;

	  var headers = {};
	  var authorization = this._buildAuthorizationHeaders(orderedParameters);
	  if (this._isEcho) {
	    headers["X-Verify-Credentials-Authorization"] = authorization;
	  } else {
	    headers["Authorization"] = authorization;
	  }

	  headers["Host"] = parsedUrl.host;

	  for (var key in this._headers) {
	    if (this._headers.hasOwnProperty(key)) {
	      headers[key] = this._headers[key];
	    }
	  }

	  // Filter out any passed extra_params that are really to do with OAuth
	  for (var key in extra_params) {
	    if (this._isParameterNameAnOAuthParameter(key)) {
	      delete extra_params[key];
	    }
	  }

	  if ((method == "POST" || method == "PUT") && post_body == null && extra_params != null) {
	    // Fix the mismatch between the output of querystring.stringify() and this._encodeData()
	    post_body = querystring.stringify(extra_params).replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
	  }

	  if (post_body) {
	    if (Buffer.isBuffer(post_body)) {
	      headers["Content-length"] = post_body.length;
	    } else {
	      headers["Content-length"] = Buffer.byteLength(post_body);
	    }
	  } else {
	    headers["Content-length"] = 0;
	  }

	  headers["Content-Type"] = post_content_type;

	  var path;
	  if (!parsedUrl.pathname || parsedUrl.pathname == "") parsedUrl.pathname = "/";
	  if (parsedUrl.query) path = parsedUrl.pathname + "?" + parsedUrl.query;else path = parsedUrl.pathname;

	  var request;
	  if (parsedUrl.protocol == "https:") {
	    request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers, true);
	  } else {
	    request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers);
	  }

	  var clientOptions = this._clientOptions;
	  if (callback) {
	    var data = "";
	    var self = this;

	    // Some hosts *cough* google appear to close the connection early / send no content-length header
	    // allow this behaviour.
	    var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(parsedUrl.hostname);
	    var callbackCalled = false;
	    var passBackControl = function passBackControl(response) {
	      if (!callbackCalled) {
	        callbackCalled = true;
	        if (response.statusCode >= 200 && response.statusCode <= 299) {
	          callback(null, data, response);
	        } else {
	          // Follow 301 or 302 redirects with Location HTTP header
	          if ((response.statusCode == 301 || response.statusCode == 302) && clientOptions.followRedirects && response.headers && response.headers.location) {
	            self._performSecureRequest(oauth_token, oauth_token_secret, method, response.headers.location, extra_params, post_body, post_content_type, callback);
	          } else {
	            callback({ statusCode: response.statusCode, data: data }, data, response);
	          }
	        }
	      }
	    };

	    request.on('response', function (response) {
	      response.setEncoding('utf8');
	      response.on('data', function (chunk) {
	        data += chunk;
	      });
	      response.on('end', function () {
	        passBackControl(response);
	      });
	      response.on('close', function () {
	        if (allowEarlyClose) {
	          passBackControl(response);
	        }
	      });
	    });

	    request.on("error", function (err) {
	      if (!callbackCalled) {
	        callbackCalled = true;
	        callback(err);
	      }
	    });

	    if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
	      request.write(post_body);
	    }
	    request.end();
	  } else {
	    if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
	      request.write(post_body);
	    }
	    return request;
	  }

	  return;
	};

	exports.OAuth.prototype.setClientOptions = function (options) {
	  var key,
	      mergedOptions = {},
	      hasOwnProperty = Object.prototype.hasOwnProperty;

	  for (key in this._defaultClientOptions) {
	    if (!hasOwnProperty.call(options, key)) {
	      mergedOptions[key] = this._defaultClientOptions[key];
	    } else {
	      mergedOptions[key] = options[key];
	    }
	  }

	  this._clientOptions = mergedOptions;
	};

	exports.OAuth.prototype.getOAuthAccessToken = function (oauth_token, oauth_token_secret, oauth_verifier, callback) {
	  var extraParams = {};
	  if (typeof oauth_verifier == "function") {
	    callback = oauth_verifier;
	  } else {
	    extraParams.oauth_verifier = oauth_verifier;
	  }

	  this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null, function (error, data, response) {
	    if (error) callback(error);else {
	      var results = querystring.parse(data);
	      var oauth_access_token = results["oauth_token"];
	      delete results["oauth_token"];
	      var oauth_access_token_secret = results["oauth_token_secret"];
	      delete results["oauth_token_secret"];
	      callback(null, oauth_access_token, oauth_access_token_secret, results);
	    }
	  });
	};

	// Deprecated
	exports.OAuth.prototype.getProtectedResource = function (url, method, oauth_token, oauth_token_secret, callback) {
	  this._performSecureRequest(oauth_token, oauth_token_secret, method, url, null, "", null, callback);
	};

	exports.OAuth.prototype.delete = function (url, oauth_token, oauth_token_secret, callback) {
	  return this._performSecureRequest(oauth_token, oauth_token_secret, "DELETE", url, null, "", null, callback);
	};

	exports.OAuth.prototype.get = function (url, oauth_token, oauth_token_secret, callback) {
	  return this._performSecureRequest(oauth_token, oauth_token_secret, "GET", url, null, "", null, callback);
	};

	exports.OAuth.prototype._putOrPost = function (method, url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
	  var extra_params = null;
	  if (typeof post_content_type == "function") {
	    callback = post_content_type;
	    post_content_type = null;
	  }
	  if (typeof post_body != "string" && !Buffer.isBuffer(post_body)) {
	    post_content_type = "application/x-www-form-urlencoded";
	    extra_params = post_body;
	    post_body = null;
	  }
	  return this._performSecureRequest(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback);
	};

	exports.OAuth.prototype.put = function (url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
	  return this._putOrPost("PUT", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
	};

	exports.OAuth.prototype.post = function (url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
	  return this._putOrPost("POST", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
	};

	/**
	 * Gets a request token from the OAuth provider and passes that information back
	 * to the calling code.
	 *
	 * The callback should expect a function of the following form:
	 *
	 * function(err, token, token_secret, parsedQueryString) {}
	 *
	 * This method has optional parameters so can be called in the following 2 ways:
	 *
	 * 1) Primary use case: Does a basic request with no extra parameters
	 *  getOAuthRequestToken( callbackFunction )
	 *
	 * 2) As above but allows for provision of extra parameters to be sent as part of the query to the server.
	 *  getOAuthRequestToken( extraParams, callbackFunction )
	 *
	 * N.B. This method will HTTP POST verbs by default, if you wish to override this behaviour you will
	 * need to provide a requestTokenHttpMethod option when creating the client.
	 *
	 **/
	exports.OAuth.prototype.getOAuthRequestToken = function (extraParams, callback) {
	  if (typeof extraParams == "function") {
	    callback = extraParams;
	    extraParams = {};
	  }
	  // Callbacks are 1.0A related
	  if (this._authorize_callback) {
	    extraParams["oauth_callback"] = this._authorize_callback;
	  }
	  this._performSecureRequest(null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, extraParams, null, null, function (error, data, response) {
	    if (error) callback(error);else {
	      var results = querystring.parse(data);

	      var oauth_token = results["oauth_token"];
	      var oauth_token_secret = results["oauth_token_secret"];
	      delete results["oauth_token"];
	      delete results["oauth_token_secret"];
	      callback(null, oauth_token, oauth_token_secret, results);
	    }
	  });
	};

	exports.OAuth.prototype.signUrl = function (url, oauth_token, oauth_token_secret, method) {

	  if (method === undefined) {
	    var method = "GET";
	  }

	  var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
	  var parsedUrl = URL.parse(url, false);

	  var query = "";
	  for (var i = 0; i < orderedParameters.length; i++) {
	    query += orderedParameters[i][0] + "=" + this._encodeData(orderedParameters[i][1]) + "&";
	  }
	  query = query.substring(0, query.length - 1);

	  return parsedUrl.protocol + "//" + parsedUrl.host + parsedUrl.pathname + "?" + query;
	};

	exports.OAuth.prototype.authHeader = function (url, oauth_token, oauth_token_secret, method) {
	  if (method === undefined) {
	    var method = "GET";
	  }

	  var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
	  return this._buildAuthorizationHeaders(orderedParameters);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 554 */
/***/ function(module, exports) {

	"use strict";

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS 180-1
	 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	/*
	 * Configurable variables. You may need to tweak these to be compatible with
	 * the server-side, but the defaults work in most cases.
	 */
	var hexcase = 1; /* hex output format. 0 - lowercase; 1 - uppercase        */
	var b64pad = "="; /* base-64 pad character. "=" for strict RFC compliance   */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_sha1(s) {
	  return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
	}
	function b64_sha1(s) {
	  return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
	}
	function any_sha1(s, e) {
	  return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
	}
	function hex_hmac_sha1(k, d) {
	  return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
	}
	function b64_hmac_sha1(k, d) {
	  return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
	}
	function any_hmac_sha1(k, d, e) {
	  return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
	}

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function sha1_vm_test() {
	  return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
	}

	/*
	 * Calculate the SHA1 of a raw string
	 */
	function rstr_sha1(s) {
	  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
	}

	/*
	 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
	 */
	function rstr_hmac_sha1(key, data) {
	  var bkey = rstr2binb(key);
	  if (bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

	  var ipad = Array(16),
	      opad = Array(16);
	  for (var i = 0; i < 16; i++) {
	    ipad[i] = bkey[i] ^ 0x36363636;
	    opad[i] = bkey[i] ^ 0x5C5C5C5C;
	  }

	  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
	  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
	}

	/*
	 * Convert a raw string to a hex string
	 */
	function rstr2hex(input) {
	  try {
	    hexcase;
	  } catch (e) {
	    hexcase = 0;
	  }
	  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
	  var output = "";
	  var x;
	  for (var i = 0; i < input.length; i++) {
	    x = input.charCodeAt(i);
	    output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);
	  }
	  return output;
	}

	/*
	 * Convert a raw string to a base-64 string
	 */
	function rstr2b64(input) {
	  try {
	    b64pad;
	  } catch (e) {
	    b64pad = '';
	  }
	  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	  var output = "";
	  var len = input.length;
	  for (var i = 0; i < len; i += 3) {
	    var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
	    for (var j = 0; j < 4; j++) {
	      if (i * 8 + j * 6 > input.length * 8) output += b64pad;else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);
	    }
	  }
	  return output;
	}

	/*
	 * Convert a raw string to an arbitrary string encoding
	 */
	function rstr2any(input, encoding) {
	  var divisor = encoding.length;
	  var remainders = Array();
	  var i, q, x, quotient;

	  /* Convert to an array of 16-bit big-endian values, forming the dividend */
	  var dividend = Array(Math.ceil(input.length / 2));
	  for (i = 0; i < dividend.length; i++) {
	    dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
	  }

	  /*
	   * Repeatedly perform a long division. The binary array forms the dividend,
	   * the length of the encoding is the divisor. Once computed, the quotient
	   * forms the dividend for the next step. We stop when the dividend is zero.
	   * All remainders are stored for later use.
	   */
	  while (dividend.length > 0) {
	    quotient = Array();
	    x = 0;
	    for (i = 0; i < dividend.length; i++) {
	      x = (x << 16) + dividend[i];
	      q = Math.floor(x / divisor);
	      x -= q * divisor;
	      if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;
	    }
	    remainders[remainders.length] = x;
	    dividend = quotient;
	  }

	  /* Convert the remainders to the output string */
	  var output = "";
	  for (i = remainders.length - 1; i >= 0; i--) {
	    output += encoding.charAt(remainders[i]);
	  } /* Append leading zero equivalents */
	  var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
	  for (i = output.length; i < full_length; i++) {
	    output = encoding[0] + output;
	  }return output;
	}

	/*
	 * Encode a string as utf-8.
	 * For efficiency, this assumes the input is valid utf-16.
	 */
	function str2rstr_utf8(input) {
	  var output = "";
	  var i = -1;
	  var x, y;

	  while (++i < input.length) {
	    /* Decode utf-16 surrogate pairs */
	    x = input.charCodeAt(i);
	    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
	    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
	      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
	      i++;
	    }

	    /* Encode output as utf-8 */
	    if (x <= 0x7F) output += String.fromCharCode(x);else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
	  }
	  return output;
	}

	/*
	 * Encode a string as utf-16
	 */
	function str2rstr_utf16le(input) {
	  var output = "";
	  for (var i = 0; i < input.length; i++) {
	    output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);
	  }return output;
	}

	function str2rstr_utf16be(input) {
	  var output = "";
	  for (var i = 0; i < input.length; i++) {
	    output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);
	  }return output;
	}

	/*
	 * Convert a raw string to an array of big-endian words
	 * Characters >255 have their high-byte silently ignored.
	 */
	function rstr2binb(input) {
	  var output = Array(input.length >> 2);
	  for (var i = 0; i < output.length; i++) {
	    output[i] = 0;
	  }for (var i = 0; i < input.length * 8; i += 8) {
	    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;
	  }return output;
	}

	/*
	 * Convert an array of big-endian words to a string
	 */
	function binb2rstr(input) {
	  var output = "";
	  for (var i = 0; i < input.length * 32; i += 8) {
	    output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);
	  }return output;
	}

	/*
	 * Calculate the SHA-1 of an array of big-endian words, and a bit length
	 */
	function binb_sha1(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << 24 - len % 32;
	  x[(len + 64 >> 9 << 4) + 15] = len;

	  var w = Array(80);
	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;
	  var e = -1009589776;

	  for (var i = 0; i < x.length; i += 16) {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	    var olde = e;

	    for (var j = 0; j < 80; j++) {
	      if (j < 16) w[j] = x[i + j];else w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
	      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
	      e = d;
	      d = c;
	      c = bit_rol(b, 30);
	      b = a;
	      a = t;
	    }

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	    e = safe_add(e, olde);
	  }
	  return Array(a, b, c, d, e);
	}

	/*
	 * Perform the appropriate triplet combination function for the current
	 * iteration
	 */
	function sha1_ft(t, b, c, d) {
	  if (t < 20) return b & c | ~b & d;
	  if (t < 40) return b ^ c ^ d;
	  if (t < 60) return b & c | b & d | c & d;
	  return b ^ c ^ d;
	}

	/*
	 * Determine the appropriate additive constant for the current iteration
	 */
	function sha1_kt(t) {
	  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y) {
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xFFFF;
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}

	exports.HMACSHA1 = function (key, data) {
	  return b64_hmac_sha1(key, data);
	};

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var http = __webpack_require__(293);

	var https = module.exports;

	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};

	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    return http.request.call(this, params, cb);
	};

/***/ },
/* 556 */
/***/ function(module, exports) {

	"use strict";

	// Returns true if this is a host that closes *before* it ends?!?!
	module.exports.isAnEarlyCloseHost = function (hostName) {
	  return hostName && hostName.match(".*google(apis)?.com$");
	};

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var querystring = __webpack_require__(220),
	    crypto = __webpack_require__(256),
	    https = __webpack_require__(555),
	    http = __webpack_require__(293),
	    URL = __webpack_require__(216),
	    OAuthUtils = __webpack_require__(556);

	exports.OAuth2 = function (clientId, clientSecret, baseSite, authorizePath, accessTokenPath, customHeaders) {
	  this._clientId = clientId;
	  this._clientSecret = clientSecret;
	  this._baseSite = baseSite;
	  this._authorizeUrl = authorizePath || "/oauth/authorize";
	  this._accessTokenUrl = accessTokenPath || "/oauth/access_token";
	  this._accessTokenName = "access_token";
	  this._authMethod = "Bearer";
	  this._customHeaders = customHeaders || {};
	  this._useAuthorizationHeaderForGET = false;
	};

	// This 'hack' method is required for sites that don't use
	// 'access_token' as the name of the access token (for requests).
	// ( http://tools.ietf.org/html/draft-ietf-oauth-v2-16#section-7 )
	// it isn't clear what the correct value should be atm, so allowing
	// for specific (temporary?) override for now.
	exports.OAuth2.prototype.setAccessTokenName = function (name) {
	  this._accessTokenName = name;
	};

	// Sets the authorization method for Authorization header.
	// e.g. Authorization: Bearer <token>  # "Bearer" is the authorization method.
	exports.OAuth2.prototype.setAuthMethod = function (authMethod) {
	  this._authMethod = authMethod;
	};

	// If you use the OAuth2 exposed 'get' method (and don't construct your own _request call )
	// this will specify whether to use an 'Authorize' header instead of passing the access_token as a query parameter
	exports.OAuth2.prototype.useAuthorizationHeaderforGET = function (useIt) {
	  this._useAuthorizationHeaderForGET = useIt;
	};

	exports.OAuth2.prototype._getAccessTokenUrl = function () {
	  return this._baseSite + this._accessTokenUrl; /* + "?" + querystring.stringify(params); */
	};

	// Build the authorization header. In particular, build the part after the colon.
	// e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
	exports.OAuth2.prototype.buildAuthHeader = function (token) {
	  return this._authMethod + ' ' + token;
	};

	exports.OAuth2.prototype._chooseHttpLibrary = function (parsedUrl) {
	  var http_library = https;
	  // As this is OAUth2, we *assume* https unless told explicitly otherwise.
	  if (parsedUrl.protocol != "https:") {
	    http_library = http;
	  }
	  return http_library;
	};

	exports.OAuth2.prototype._request = function (method, url, headers, post_body, access_token, callback) {

	  var parsedUrl = URL.parse(url, true);
	  if (parsedUrl.protocol == "https:" && !parsedUrl.port) {
	    parsedUrl.port = 443;
	  }

	  var http_library = this._chooseHttpLibrary(parsedUrl);

	  var realHeaders = {};
	  for (var key in this._customHeaders) {
	    realHeaders[key] = this._customHeaders[key];
	  }
	  if (headers) {
	    for (var key in headers) {
	      realHeaders[key] = headers[key];
	    }
	  }
	  realHeaders['Host'] = parsedUrl.host;

	  if (!realHeaders['User-Agent']) {
	    realHeaders['User-Agent'] = 'Node-oauth';
	  }

	  if (post_body) {
	    if (Buffer.isBuffer(post_body)) {
	      realHeaders["Content-Length"] = post_body.length;
	    } else {
	      realHeaders["Content-Length"] = Buffer.byteLength(post_body);
	    }
	  } else {
	    realHeaders["Content-length"] = 0;
	  }

	  if (access_token && !('Authorization' in realHeaders)) {
	    if (!parsedUrl.query) parsedUrl.query = {};
	    parsedUrl.query[this._accessTokenName] = access_token;
	  }

	  var queryStr = querystring.stringify(parsedUrl.query);
	  if (queryStr) queryStr = "?" + queryStr;
	  var options = {
	    host: parsedUrl.hostname,
	    port: parsedUrl.port,
	    path: parsedUrl.pathname + queryStr,
	    method: method,
	    headers: realHeaders
	  };

	  this._executeRequest(http_library, options, post_body, callback);
	};

	exports.OAuth2.prototype._executeRequest = function (http_library, options, post_body, callback) {
	  // Some hosts *cough* google appear to close the connection early / send no content-length header
	  // allow this behaviour.
	  var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(options.host);
	  var callbackCalled = false;
	  function passBackControl(response, result) {
	    if (!callbackCalled) {
	      callbackCalled = true;
	      if (!(response.statusCode >= 200 && response.statusCode <= 299) && response.statusCode != 301 && response.statusCode != 302) {
	        callback({ statusCode: response.statusCode, data: result });
	      } else {
	        callback(null, result, response);
	      }
	    }
	  }

	  var result = "";

	  var request = http_library.request(options);
	  request.on('response', function (response) {
	    response.on("data", function (chunk) {
	      result += chunk;
	    });
	    response.on("close", function (err) {
	      if (allowEarlyClose) {
	        passBackControl(response, result);
	      }
	    });
	    response.addListener("end", function () {
	      passBackControl(response, result);
	    });
	  });
	  request.on('error', function (e) {
	    callbackCalled = true;
	    callback(e);
	  });

	  if ((options.method == 'POST' || options.method == 'PUT') && post_body) {
	    request.write(post_body);
	  }
	  request.end();
	};

	exports.OAuth2.prototype.getAuthorizeUrl = function (params) {
	  var params = params || {};
	  params['client_id'] = this._clientId;
	  return this._baseSite + this._authorizeUrl + "?" + querystring.stringify(params);
	};

	exports.OAuth2.prototype.getOAuthAccessToken = function (code, params, callback) {
	  var params = params || {};
	  params['client_id'] = this._clientId;
	  params['client_secret'] = this._clientSecret;
	  var codeParam = params.grant_type === 'refresh_token' ? 'refresh_token' : 'code';
	  params[codeParam] = code;

	  var post_data = querystring.stringify(params);
	  var post_headers = {
	    'Content-Type': 'application/x-www-form-urlencoded'
	  };

	  this._request("POST", this._getAccessTokenUrl(), post_headers, post_data, null, function (error, data, response) {
	    if (error) callback(error);else {
	      var results;
	      try {
	        // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
	        // responses should be in JSON
	        results = JSON.parse(data);
	      } catch (e) {
	        // .... However both Facebook + Github currently use rev05 of the spec
	        // and neither seem to specify a content-type correctly in their response headers :(
	        // clients of these services will suffer a *minor* performance cost of the exception
	        // being thrown
	        results = querystring.parse(data);
	      }
	      var access_token = results["access_token"];
	      var refresh_token = results["refresh_token"];
	      delete results["refresh_token"];
	      callback(null, access_token, refresh_token, results); // callback results =-=
	    }
	  });
	};

	// Deprecated
	exports.OAuth2.prototype.getProtectedResource = function (url, access_token, callback) {
	  this._request("GET", url, {}, "", access_token, callback);
	};

	exports.OAuth2.prototype.get = function (url, access_token, callback) {
	  if (this._useAuthorizationHeaderForGET) {
	    var headers = { 'Authorization': this.buildAuthHeader(access_token) };
	    access_token = null;
	  } else {
	    headers = {};
	  }
	  this._request("GET", url, headers, "", access_token, callback);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(193).Buffer))

/***/ },
/* 558 */
/***/ function(module, exports) {

	"use strict";

	function NullStore(options) {}

	NullStore.prototype.store = function (req, cb) {
	  cb();
	};

	NullStore.prototype.verify = function (req, providedState, cb) {
	  cb(null, true);
	};

	module.exports = NullStore;

/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var uid = __webpack_require__(560);

	/**
	 * Creates an instance of `SessionStore`.
	 *
	 * This is the state store implementation for the OAuth2Strategy used when
	 * the `state` option is enabled.  It generates a random state and stores it in
	 * `req.session` and verifies it when the service provider redirects the user
	 * back to the application.
	 *
	 * This state store requires session support.  If no session exists, an error
	 * will be thrown.
	 *
	 * Options:
	 *
	 *   - `key`  The key in the session under which to store the state
	 *
	 * @constructor
	 * @param {Object} options
	 * @api public
	 */
	function SessionStore(options) {
	  if (!options.key) {
	    throw new TypeError('Session-based state store requires a session key');
	  }
	  this._key = options.key;
	}

	/**
	 * Store request state.
	 *
	 * This implementation simply generates a random string and stores the value in
	 * the session, where it will be used for verification when the user is
	 * redirected back to the application.
	 *
	 * @param {Object} req
	 * @param {Function} callback
	 * @api protected
	 */
	SessionStore.prototype.store = function (req, callback) {
	  if (!req.session) {
	    return callback(new Error('OAuth 2.0 authentication requires session support when using state. Did you forget to use express-session middleware?'));
	  }

	  var key = this._key;
	  var state = uid(24);
	  if (!req.session[key]) {
	    req.session[key] = {};
	  }
	  req.session[key].state = state;
	  callback(null, state);
	};

	/**
	 * Verify request state.
	 *
	 * This implementation simply compares the state parameter in the request to the
	 * value generated earlier and stored in the session.
	 *
	 * @param {Object} req
	 * @param {String} providedState
	 * @param {Function} callback
	 * @api protected
	 */
	SessionStore.prototype.verify = function (req, providedState, callback) {
	  if (!req.session) {
	    return callback(new Error('OAuth 2.0 authentication requires session support when using state. Did you forget to use express-session middleware?'));
	  }

	  var key = this._key;
	  if (!req.session[key]) {
	    return callback(null, false, { message: 'Unable to verify authorization request state.' });
	  }

	  var state = req.session[key].state;
	  if (!state) {
	    return callback(null, false, { message: 'Unable to verify authorization request state.' });
	  }

	  delete req.session[key].state;
	  if (Object.keys(req.session[key]).length === 0) {
	    delete req.session[key];
	  }

	  if (state !== providedState) {
	    return callback(null, false, { message: 'Invalid authorization request state.' });
	  }

	  return callback(null, true);
	};

	// Expose constructor.
	module.exports = SessionStore;

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies
	 */

	var crypto = __webpack_require__(256);

	/**
	 * 62 characters in the ascii range that can be used in URLs without special
	 * encoding.
	 */
	var UIDCHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

	/**
	 * Make a Buffer into a string ready for use in URLs
	 *
	 * @param {String}
	 * @returns {String}
	 * @api private
	 */
	function tostr(bytes) {
	  var chars, r, i;

	  r = [];
	  for (i = 0; i < bytes.length; i++) {
	    r.push(UIDCHARS[bytes[i] % UIDCHARS.length]);
	  }

	  return r.join('');
	}

	/**
	 * Generate an Unique Id
	 *
	 * @param {Number} length  The number of chars of the uid
	 * @param {Number} cb (optional)  Callback for async uid generation
	 * @api public
	 */

	function uid(length, cb) {

	  if (typeof cb === 'undefined') {
	    return tostr(crypto.pseudoRandomBytes(length));
	  } else {
	    crypto.pseudoRandomBytes(length, function (err, bytes) {
	      if (err) return cb(err);
	      cb(null, tostr(bytes));
	    });
	  }
	}

	/**
	 * Exports
	 */

	module.exports = uid;

/***/ },
/* 561 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `AuthorizationError` error.
	 *
	 * AuthorizationError represents an error in response to an authorization
	 * request.  For details, refer to RFC 6749, section 4.1.2.1.
	 *
	 * References:
	 *   - [The OAuth 2.0 Authorization Framework](http://tools.ietf.org/html/rfc6749)
	 *
	 * @constructor
	 * @param {String} [message]
	 * @param {String} [code]
	 * @param {String} [uri]
	 * @param {Number} [status]
	 * @api public
	 */
	function AuthorizationError(message, code, uri, status) {
	  if (!status) {
	    switch (code) {
	      case 'access_denied':
	        status = 403;break;
	      case 'server_error':
	        status = 502;break;
	      case 'temporarily_unavailable':
	        status = 503;break;
	    }
	  }

	  Error.call(this);
	  Error.captureStackTrace(this, this.constructor);
	  this.name = this.constructor.name;
	  this.message = message;
	  this.code = code || 'server_error';
	  this.uri = uri;
	  this.status = status || 500;
	}

	/**
	 * Inherit from `Error`.
	 */
	AuthorizationError.prototype.__proto__ = Error.prototype;

	/**
	 * Expose `AuthorizationError`.
	 */
	module.exports = AuthorizationError;

/***/ },
/* 562 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `TokenError` error.
	 *
	 * TokenError represents an error received from a token endpoint.  For details,
	 * refer to RFC 6749, section 5.2.
	 *
	 * References:
	 *   - [The OAuth 2.0 Authorization Framework](http://tools.ietf.org/html/rfc6749)
	 *
	 * @constructor
	 * @param {String} [message]
	 * @param {String} [code]
	 * @param {String} [uri]
	 * @param {Number} [status]
	 * @api public
	 */
	function TokenError(message, code, uri, status) {
	  Error.call(this);
	  Error.captureStackTrace(this, this.constructor);
	  this.name = this.constructor.name;
	  this.message = message;
	  this.code = code || 'invalid_request';
	  this.uri = uri;
	  this.status = status || 500;
	}

	/**
	 * Inherit from `Error`.
	 */
	TokenError.prototype.__proto__ = Error.prototype;

	/**
	 * Expose `TokenError`.
	 */
	module.exports = TokenError;

/***/ },
/* 563 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `InternalOAuthError` error.
	 *
	 * InternalOAuthError wraps errors generated by node-oauth.  By wrapping these
	 * objects, error messages can be formatted in a manner that aids in debugging
	 * OAuth issues.
	 *
	 * @constructor
	 * @param {String} [message]
	 * @param {Object|Error} [err]
	 * @api public
	 */
	function InternalOAuthError(message, err) {
	  Error.call(this);
	  Error.captureStackTrace(this, this.constructor);
	  this.name = this.constructor.name;
	  this.message = message;
	  this.oauthError = err;
	}

	/**
	 * Inherit from `Error`.
	 */
	InternalOAuthError.prototype.__proto__ = Error.prototype;

	/**
	 * Returns a string representing the error.
	 *
	 * @return {String}
	 * @api public
	 */
	InternalOAuthError.prototype.toString = function () {
	  var m = this.name;
	  if (this.message) {
	    m += ': ' + this.message;
	  }
	  if (this.oauthError) {
	    if (this.oauthError instanceof Error) {
	      m = this.oauthError.toString();
	    } else if (this.oauthError.statusCode && this.oauthError.data) {
	      m += ' (status: ' + this.oauthError.statusCode + ' data: ' + this.oauthError.data + ')';
	    }
	  }
	  return m;
	};

	/**
	 * Expose `InternalOAuthError`.
	 */
	module.exports = InternalOAuthError;

/***/ },
/* 564 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * Parse profile.
	 *
	 * @param {object|string} json
	 * @return {object}
	 * @access public
	 */
	exports.parse = function (json) {
	  if ('string' == typeof json) {
	    json = JSON.parse(json);
	  }

	  var profile = {};
	  profile.id = json.id;
	  profile.username = json.username;
	  profile.displayName = json.name;
	  profile.name = { familyName: json.last_name,
	    givenName: json.first_name,
	    middleName: json.middle_name };

	  profile.gender = json.gender;
	  profile.profileUrl = json.link;

	  if (json.email) {
	    profile.emails = [{ value: json.email }];
	  }

	  if (json.picture) {
	    if (_typeof(json.picture) == 'object' && json.picture.data) {
	      // October 2012 Breaking Changes
	      profile.photos = [{ value: json.picture.data.url }];
	    } else {
	      profile.photos = [{ value: json.picture }];
	    }
	  }

	  return profile;
	};

/***/ },
/* 565 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `FacebookAuthorizationError` error.
	 *
	 * FacebookAuthorizationError represents an error in response to an
	 * authorization request on Facebook.  Note that these responses don't conform
	 * to the OAuth 2.0 specification.
	 *
	 * References:
	 *   - https://developers.facebook.com/docs/reference/api/errors/
	 *
	 * @constructor
	 * @param {string} [message]
	 * @param {number} [code]
	 * @access public
	 */
	function FacebookAuthorizationError(message, code) {
	  Error.call(this);
	  Error.captureStackTrace(this, arguments.callee);
	  this.name = 'FacebookAuthorizationError';
	  this.message = message;
	  this.code = code;
	  this.status = 500;
	}

	// Inherit from `Error`.
	FacebookAuthorizationError.prototype.__proto__ = Error.prototype;

	// Expose constructor.
	module.exports = FacebookAuthorizationError;

/***/ },
/* 566 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `FacebookTokenError` error.
	 *
	 * FacebookTokenError represents an error received from a Facebook's token
	 * endpoint.  Note that these responses don't conform to the OAuth 2.0
	 * specification.
	 *
	 * References:
	 *   - https://developers.facebook.com/docs/reference/api/errors/
	 *
	 * @constructor
	 * @param {string} [message]
	 * @param {string} [type]
	 * @param {number} [code]
	 * @param {number} [subcode]
	 * @param {string} [traceID]
	 * @access public
	 */
	function FacebookTokenError(message, type, code, subcode, traceID) {
	  Error.call(this);
	  Error.captureStackTrace(this, arguments.callee);
	  this.name = 'FacebookTokenError';
	  this.message = message;
	  this.type = type;
	  this.code = code;
	  this.subcode = subcode;
	  this.traceID = traceID;
	  this.status = 500;
	}

	// Inherit from `Error`.
	FacebookTokenError.prototype.__proto__ = Error.prototype;

	// Expose constructor.
	module.exports = FacebookTokenError;

/***/ },
/* 567 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * `FacebookGraphAPIError` error.
	 *
	 * References:
	 *   - https://developers.facebook.com/docs/reference/api/errors/
	 *
	 * @constructor
	 * @param {string} [message]
	 * @param {string} [type]
	 * @param {number} [code]
	 * @param {number} [subcode]
	 * @param {string} [traceID]
	 * @access public
	 */
	function FacebookGraphAPIError(message, type, code, subcode, traceID) {
	  Error.call(this);
	  Error.captureStackTrace(this, arguments.callee);
	  this.name = 'FacebookGraphAPIError';
	  this.message = message;
	  this.type = type;
	  this.code = code;
	  this.subcode = subcode;
	  this.traceID = traceID;
	  this.status = 500;
	}

	// Inherit from `Error`.
	FacebookGraphAPIError.prototype.__proto__ = Error.prototype;

	// Expose constructor.
	module.exports = FacebookGraphAPIError;

/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	//---------------------------Local Strategy-------------------------------------


	exports.default = function (User) {
	  _passport2.default.use('local-signup', new _passportLocal.Strategy({
	    usernameField: 'username',
	    passwordField: 'password',
	    passReqToCallback: true
	  }, function (req, username, password, done) {
	    console.log('sign them up!');
	    process.nextTick(function () {
	      if (!req.user) {
	        User.findOrCreate({
	          username: username,
	          password: password
	        }).then(function (user) {
	          return done(null, user[0]);
	        }).catch(function (err) {
	          return done(err);
	        });
	      } else {
	        //user exists and is logged in
	        done(null, false);
	      }
	    });
	  }));
	  //---------------------------local login----------------------------------------
	  _passport2.default.use('local-login', new _passportLocal.Strategy({
	    usernameField: 'username',
	    passwordField: 'password',
	    passReqToCallback: true
	  }, function (req, username, password, done) {
	    return User.find({ username: username }).then(function (user) {
	      console.log('checking username and password');
	      if (user.length === 0) {
	        return done(null, false);
	      }
	      return [User.isValidPassword(password, user[0].id), user];
	    }).then(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      var match = _ref2[0];
	      var user = _ref2[1];

	      if (match) {
	        return done(null, user);
	      } else {
	        return done(null, false);
	      }
	    }).catch(function (err) {
	      return done(err);
	    });
	  }));
	};

	var _passportLocal = __webpack_require__(569);

	var _passport = __webpack_require__(437);

	var _passport2 = _interopRequireDefault(_passport);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var Strategy = __webpack_require__(570);

	/**
	 * Expose `Strategy` directly from package.
	 */
	exports = module.exports = Strategy;

	/**
	 * Export constructors.
	 */
	exports.Strategy = Strategy;

/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Module dependencies.
	 */
	var passport = __webpack_require__(441),
	    util = __webpack_require__(263),
	    lookup = __webpack_require__(571).lookup;

	/**
	 * `Strategy` constructor.
	 *
	 * The local authentication strategy authenticates requests based on the
	 * credentials submitted through an HTML-based login form.
	 *
	 * Applications must supply a `verify` callback which accepts `username` and
	 * `password` credentials, and then calls the `done` callback supplying a
	 * `user`, which should be set to `false` if the credentials are not valid.
	 * If an exception occured, `err` should be set.
	 *
	 * Optionally, `options` can be used to change the fields in which the
	 * credentials are found.
	 *
	 * Options:
	 *   - `usernameField`  field name where the username is found, defaults to _username_
	 *   - `passwordField`  field name where the password is found, defaults to _password_
	 *   - `passReqToCallback`  when `true`, `req` is the first argument to the verify callback (default: `false`)
	 *
	 * Examples:
	 *
	 *     passport.use(new LocalStrategy(
	 *       function(username, password, done) {
	 *         User.findOne({ username: username, password: password }, function (err, user) {
	 *           done(err, user);
	 *         });
	 *       }
	 *     ));
	 *
	 * @param {Object} options
	 * @param {Function} verify
	 * @api public
	 */
	function Strategy(options, verify) {
	  if (typeof options == 'function') {
	    verify = options;
	    options = {};
	  }
	  if (!verify) {
	    throw new TypeError('LocalStrategy requires a verify callback');
	  }

	  this._usernameField = options.usernameField || 'username';
	  this._passwordField = options.passwordField || 'password';

	  passport.Strategy.call(this);
	  this.name = 'local';
	  this._verify = verify;
	  this._passReqToCallback = options.passReqToCallback;
	}

	/**
	 * Inherit from `passport.Strategy`.
	 */
	util.inherits(Strategy, passport.Strategy);

	/**
	 * Authenticate request based on the contents of a form submission.
	 *
	 * @param {Object} req
	 * @api protected
	 */
	Strategy.prototype.authenticate = function (req, options) {
	  options = options || {};
	  var username = lookup(req.body, this._usernameField) || lookup(req.query, this._usernameField);
	  var password = lookup(req.body, this._passwordField) || lookup(req.query, this._passwordField);

	  if (!username || !password) {
	    return this.fail({ message: options.badRequestMessage || 'Missing credentials' }, 400);
	  }

	  var self = this;

	  function verified(err, user, info) {
	    if (err) {
	      return self.error(err);
	    }
	    if (!user) {
	      return self.fail(info);
	    }
	    self.success(user, info);
	  }

	  try {
	    if (self._passReqToCallback) {
	      this._verify(req, username, password, verified);
	    } else {
	      this._verify(username, password, verified);
	    }
	  } catch (ex) {
	    return self.error(ex);
	  }
	};

	/**
	 * Expose `Strategy`.
	 */
	module.exports = Strategy;

/***/ },
/* 571 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.lookup = function (obj, field) {
	  if (!obj) {
	    return null;
	  }
	  var chain = field.split(']').join('').split('[');
	  for (var i = 0, len = chain.length; i < len; i++) {
	    var prop = obj[chain[i]];
	    if (typeof prop === 'undefined') {
	      return null;
	    }
	    if ((typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) !== 'object') {
	      return prop;
	    }
	    obj = prop;
	  }
	  return null;
	};

/***/ },
/* 572 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (app) {
	  app.get('/', function (req, res) {
	    console.log('redirected back');
	    res.render('index');
	  });
	};

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (app) {
	  // AUTHENTICATION
	  app.route('/login').get(function (req, res) {
	    res.render('login', { errMsg: false });
	  }).post(_passport2.default.authenticate('local-login', {
	    successRedirect: '/spots',
	    failureRedirect: '/login'
	  }));

	  app.route('/signup').get(function (req, res) {
	    res.render('signup');
	  }).post(_passport2.default.authenticate('local-signup', {
	    successRedirect: '/spots',
	    failureRedirect: '/signup'
	  }));
	  // route for facebook authentication and login
	  // different scopes while logging in
	  app.get('/auth/facebook', _passport2.default.authenticate('facebook', { session: false, scope: 'email' }));

	  app.get('/auth/facebook/callback', _passport2.default.authenticate('facebook', { session: false, failureRedirect: '/login' }));

	  app.get('/logout', function (req, res) {
	    req.logout();
	    res.redirect('/');
	  });
	  // isAuthenticated,
	  console.log(_isAuthenticated2.default);
	  // Get all of a user's spots.
	  app.get('/spots', _isAuthenticated2.default, function (req, res) {
	    console.log('redirected to spots');
	    res.sendFile(_path2.default.join(__dirname, '/../../index.html')); // index.html for react app
	  });
	};

	var _path = __webpack_require__(230);

	var _path2 = _interopRequireDefault(_path);

	var _passport = __webpack_require__(437);

	var _passport2 = _interopRequireDefault(_passport);

	var _isAuthenticated = __webpack_require__(574);

	var _isAuthenticated2 = _interopRequireDefault(_isAuthenticated);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 574 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (req, res, next) {
	  if (req.isAuthenticated()) {
	    return next();
	  }
	  res.redirect('/login');
	};

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (app) {
	  // RESTFUl API for retrieving spots from the db
	  app.get('/api/spots', function (req, res) {
	    _Spots2.default.getAll().then(function (spots) {
	      return (0, _queryHelpers.sendBackJSON)(res, spots, 'got all spots');
	    }).catch(function (err) {
	      return console.log(err);
	    });
	  });

	  app.get('/api/spots/:id', function (req, res) {
	    _Spots2.default.getOne(req.params.id).then(function (spot) {
	      return (0, _queryHelpers.sendBackJSON)(res, spots, 'got one spot');
	    }).catch(function (err) {
	      return console.log(err);
	    });
	  });

	  app.post('/api/spots', function (req, res) {
	    _Spots2.default.create(req.body).then(function (result) {
	      return (0, _queryHelpers.sendBackJSON)(res, result, 'created new spot');
	    }).catch(function (err) {
	      return (0, _queryHelpers.sendBackJSON)(res, err, 'error');
	    });
	  });

	  app.put('/api/spots/:id', function (req, res) {
	    _Spots2.default.update(req.body).then(function (result) {
	      return (0, _queryHelpers.sendBackJSON)(res, result, 'updated a spot');
	    }).catch(function (err) {
	      return (0, _queryHelpers.sendBackJSON)(res, err, 'error');
	    });
	  });

	  app.delete('/api/spots/:id', function (req, res) {
	    _Spots2.default.update(req.body).then(function (result) {
	      return (0, _queryHelpers.sendBackJSON)(res, result, 'updated a spot');
	    }).catch(function (err) {
	      return (0, _queryHelpers.sendBackJSON)(res, err, 'error');
	    });
	  });
	};

	var _Spots = __webpack_require__(448);

	var _Spots2 = _interopRequireDefault(_Spots);

	var _queryHelpers = __webpack_require__(451);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }
/******/ ]);